<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>『初丶晴』旧忆 &lt;二&gt;</title>
      <link href="/2024/02/21/%E3%80%8E%E5%88%9D%E3%80%81%E6%99%B4%E3%80%8F%E6%97%A7%E5%BF%86-%E5%8D%B7%E4%BA%8C/"/>
      <url>/2024/02/21/%E3%80%8E%E5%88%9D%E3%80%81%E6%99%B4%E3%80%8F%E6%97%A7%E5%BF%86-%E5%8D%B7%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="欸? 这个『通行证』看着不太对, 再试试看呢..." data-whm="密码不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0b54e41a0596f121f9900342d9a416ec5b3dd59bb2c26022956b8789efa1838b">8dfed501bcaa90b15714e3bdc993ce4cd992d53dfa3b2cc635d9ae939003f1dd5c23e709214466c64cc05b7d50a033468843e6e1d17550cd53a7131095d274f2850d470cbe9b7892e6105451e82f5643d7dc6013111635a5003fa407b004d0c6d5ee5940fb598547f2255b69385136e3183ff73360e9e406a937a1f92a19270372b419175f2c15b570e5ea7f10140cd742ab0116e14aeb78979d88fe63a3c03456eae4cc002e02045a64025ba6c5ee81a7d4a6c630b1924a6c4e0f536f8c56a4749d63aa8e617f1959b9b2bda7473c2cbd270d96b0602d2b66ef7ab1d99ece8b36845e6da01d66b5a9f204f123651f96a4132400613bbf4b55cda3b0c18131ae0fa4b0d13a511a06e3d9434053de26e52aee2be54866e5240dc7bea5c301fe96feff4f17e8d6d0b61c595140ddaa7f70663fcac410c28c65540df9efbc49a8a7fee4a9319ccb67ab9bc88f8c4583ff8d13193aa8fc9d41d26aa43ba2a2944c3f552e2bf6823afeacc62fdc47ba1bd866147bf727d4f37199de75ab9afdebd0ac74f706f06449bbab4941b6cd9536bf0fe06312ade45e2ca6905b710afbca3471a316374f49ef3696df5a5500c6060d3048024c61a1ca1e4520ac156a69ace43eb65167e27abe97bcc26a643fc22b224c768eaec40dc338d4902c01f7e10eba24096f50471b236d57ff8989e80a248bfb0618010d665254b4bd8e4723cbf44c1d6d81f2a6885efff47cbad5318eeaac18ada31cd675017202583da6cc5a9a40d4738b0820b49629f3c834eea2c4509274922a25af857e01c1b7edaf4bc343d4af4c9b2a97adfde70c19c40a9e8c939efd06f610ff1365a8a382888335e8256e29285fbbedd47ba4e695fad88f231fb2129d093ea288397c20306989c6193a6378aad6f92152cc7ef0fc67fcad40695c1207be60dba49b2083d52219544922509762494a6bc7cfdbafc254a347388b37c8e8a222f979dfca45d824afef4f4ab52394352661846a89050471bc34fabb8d412b6cca216271e7f03604790a256c2d96968bf0f02b1d6a609fa35b1fd6fba20ab4ed329c9801168869de097cda98ffad375e146d31685f3e2916e0bc882016268760dc911340aaf142cc389b0ad492a7b5a8510e2efa7d6e3945ea375a9521b88cc97326e20946c46b9eb5cc5c6a3db1f5772d3458e67d7530dce386d6075d80755f79070958cb5b11a6bb62e86c1ae6a4a4cbeb2559340cd559d1a84b54b4316bacdbf3a3b3bf625e74370eacd4a783b99cacc8afaef486a0b796961fa4b01c44ca8ac0338b5e84eb3d0251b7d60fadf9a1a0ad318df0143b0334c2611a1e0a5d77ce75f89e94ff604445db7a6aea79dc9f8f0fd22b5a2d6b75e5d6a136ef65e5742c30e4259c2f55a75e1c0b62e17f877c33c92c792b22c91e44df734f74839a8bab02f971cc00219bd08b9c4468b988abdba1dd3ec9b30071561283acec4e441c68f464aece6110e52a70dd99080ff2870ccc89571be5fe211991d26f94634933bb4e593db9891cb024824f0713419e65df948d5d01573677db2a5435fa38496c5264016dab08b03e1f5f0bff44c33b1bc5cdad05014f3d59cdb2d76115b5c9e382a219c70c79db02e97e8fcabbc4378686371b2e8c3de8490edd036785b2ead911fa8b97d7dc6ae26f96454b6ff1b98360f5d3a06394ee6a32e1d2b31b37d3f70594b70bf2994da7727eeede74704656ccf48233a420e1887b9f3d98c5dada120894ec0b08b54479c61b7c1e798342c0d4733189f48ca18a454d4cff69903f78b591b2dc749c5cef0b485796c2e41cbf62dec0b8df9e46f7821deeb4909ba6ca38fc5dafc523dd1c83353ee4b8edc460013c2b909b60367ac8880cd30ba2ac83766910000c00b6e4676a863a4eccce16055f14c4956bd5d4b15e4d8365ddd247f417424b47167c60b3b478035a1ae46d1edbacef15e779adf86d2e9aeba2dab4b22dbf0971f515fa54e19cb19ee4c5577befb29c903b6b6f07a9a4b0cae4298f1e7fd52a41155a734f593d8a23509387138453de3cff0b136e9842b8dbe0dfa271b5a418cd29893d036ff0384cea1bdaabd27836f6044231c41680adf1b457d0facf7ab2372fa8922d87e20328e5f2318586459b5afc0592ccc1e6b1cc28e6bc90aa0c67b94eaaf7e5a88c95658341f8ff2013215177f94c4e3433b9cb83bd7cf7e7437d9b6c86bfc58351a3c7e02bdda25bd1428a42d76248565c0cb519692c016279ef64f4a3bb302d3150a4f4c515d08aeb2acd77c7c9594b1e0d9a262666a71f79496d823ae7762c020c5f4cc3239eddeeecf858326ffb013f90d46be8ce1619b0208c8016f436111ce014884cd56194898d4a32363897f5769d94e52c3dd5552cdb70edd41ee9d6b70922b6b29d14fd9dfb175ce06e7fe86769bc3ebe5c7bc259fc40296fe8a44dff63996c58c44e808f23f7d738c936636609b8d0045acef47c2771b281ff2e2ad002004c3840b4d328962f6dcc2dd8aa6b8b63d3c8293043986ab3d35d4f3387ba9501706b9c6c37f8c74a881010d540021904472015f6b4926a5ea352a6a9b295137529ed9dcf4f3fde03abcf7da000cff8fc6826ef4929ad323b6e2da332223bf7d891f2975655b01c4a9d94becf0e7f5f69723311b31a8b89b4e8ac9d7cfdad5ba1221d466f684d02640984ca6e0f2b66aaabf46b5514d74896b6f69193919b779c56761b1858e0bf0bcc942e6579db740ff11a819bdac7509b0e6dc31d418e3cffb82a884b2c4f2a7e1aabd3aebc46120dd080e7efff16f25555b39864f4d6fd4b2ae817dd31973e327feab2b7a1eb61c5c9a7a33c693bd8e15d676d6fb9691233658f85942e456cbadadf525f32123bfe364ba582e9dd539007d2465e055b3cd77c9174cf99921d1d44a155455ece4ce85b3d7d724cc16c7f730674e8a8c19b9afc3badbfa2df61695e85dc1cbbd1e8879a557ef5dfea08c005994bac86f0b1200a90ff297a74a2cff3b6cb5ebc755b70c666ef35732a7a73f843771892dfe091cfd096f6e61ee9137c5d06aacf968ddde6d59e978d6e21331a1311f2007f6ca777aca5e27ecc1f3e934672699c2c82ef27678b8660b9a299b1e94c541f49411811b9e530cb285a9a659723f0a6843031fc8778fa276a465659cd39eab36124d96b926aea6da8fa1bb019defb76b966e04ba063b9305cbef6df1be985c3a353f3f08d0240d6537f4915a4d2df6f2254fedd4098c3ef4061d6e9b9256957c87e450a6f0aa94d5ea842bdb3abbb883570dcd399884dfe91d051bd9906bdf7a8060056a953bace17bb74f621c5e8e9d34bb44ef79d35191d33a5ff20195bb77bb2179065d8ef2735a832e018b17999d1c3ea93827c9ef714e840bdea8b03d8fc6bfe5830696cc1f14a7b8bf07cb4c9b9fdbe3b21221441454238aa8d5810c730072bf3a1b5bb67bc629e26fd70e5ff37b829b246855c3f0ef820ab1e653fc536de95979e633c213f172cbb608cf0a45d1b0027330eabc6f37229d740e84753de604166849d5c52d1fb982086a5dfcc585bd9acc17602ced20c486574ab9d2f50b654bc95a04c8b8719ca3117a50b0837a6640c68b804bac3e0bb0dfc98287904eab0bbf9dc99aa61014b101d32d323a8d47c1a747fc6b11e42bb4a12ec4d30b5a32669bd088dd740b2c432619770ab97c5df1388ee64d072d0ced53064df4732941450847c4178725e195aaf738d7febedeb9ec62b07254b751f9cae12dfdc9ddd8d78196b163c3aabffb763f5c86824bac076320fb0baf52904fad6627bfbf3bbe2510e36b78fc66d6d56e79a2065c578f70bf73f4bd85c242d3b7ac559d873b73c83c1885e297966725fd5f2d1cf8162eac9bb21c4c4432024b6f740f311c932c3c1c52f20866c13a59980c3172300ad6417a439cc0114ac757a33456bfcfcbdfd9cf65867a5fddbd8f6d950a4fa54dbbe12a7279fab1b1dbc2744b5442254190032ed9fec7196eee3f3f39f5c0c5dd6c71da393913d9ac7697806d34a339b8e18d2b484a78e4203e8d325abd757498735b8416aba24da5c782e34d7f074334b3baec7b154b5c45653393f0edade903e9a75f6b5247d23daf311d32bb33e0d6c0ff7f3240d2cecaa5a35abd7c1a038ba9e3e62b21c96ca8d19412e0cfdbab60d184cddfa9221cdb0b0d8c93b61a2a03b94df90ee5fb9a31c7f37d51509e8b4a3c383743745a7c349bffdf874bdde97c2bb2a2d94e622b93c5e1f26c45bfeb520b89e1f56c659fcd228f577f328d63c4024903839e9484607f897826f5362bae556cf40ff704047be20dd6a7df57fb613a76d42aaf21805cb0afcf7fe5b4d5b874b41a2d97dcbe032f7f80578b00b48424d05e105c0bf11194c1650ae7d7b9892db5f36f22deccdc6383a0322380305ac2f5302d82e3df39e365e5a61bb35191cc52b67cf9f8951189407a36097b644a14af0d6a6c80a33c2be626e76faff19f23df6c7cfc20741a6e3b589c2fe7dcc486fa85a2d3ae762727e5fcf04ec2d26b3d378f97eb59fad9382693927120680b4368f6db977763ce67c242893db4b8f11c6d68769d547dfb9f1182e085c2ac318d0903e98280f9adde3b16fd595946a7bd04bcd5486736281be2361b8c1d9580de4ab4ef1b0a437656391a2aa5937666e51e13138298362f4104de212a4d271b14735f8f937d4a946be18b52a5add1684f432063712fc2aaf486ea0cf4848aec3bbc6ec56579adb276359c3f8ac9a50a8ef392914aa809bb5cbbee48b246b3ecd579759a737d49c806c9b628e318716122acb89ae9fe718eb3b08972678fb736126c9b6ec606e544d8980de3bf11e60826f55e29f3ba0022a4cdcec86a76aebf9289820624804553e7b744381af1b2056e6004688fe4078f5f6fe252118f567879edb18477b39b7db46cddff794c4cbe8bff334e026b43faa87c8f817fbd00b145c4543c225363d76f2fad96678964ef432565a39351a7acaf4eea6d728c5fa1dd862e3655f2e937a8ee2cef38f3bf06ab232cd923dad9308350dd24ec8af66db05228a68a57a739df8ed5308d797f7691df1ffc3677539e139795a3c65c867abe8bf5252ec90178ce95d7832ee8f48cd052fed81c68b07541d996b598f906fe1835c7a59f5762aca4f4a6c9d0042a299e3e52ac75963703bc9939495b2a6518760d1b2c29f53921766a90abe37f10fce76bf2fc9bc7648900d243669abe130aa6982a6aeb220252c46fe4dbb15fb08918aa35374c8a0ad997098e78571278555d31a8109664a53893a0e065543c459c50fbe960779c3bbfb996d3c3e9a39a6929501b290ae1e23f99891f1bbebc38cc8fe91d4e8f48d50b6d778cbeea6f0e1004247b48b5ebe4f8cce18443bafe2cb53343d02d46deecbfe0217bd0189c01815d0b654f67ff888564d7f9e5987c4130a172295141c5f2f1e88952fea4ec71da06cae53d51dcd99636d3cbbbb3220d040a75b0611246dde4271ee741a6067aa826d45eae3d5d0840d4c29cd1aece78b0a9b94653633c4015aa62ee68d0261270640706bc3b147b9c8afe9ee87d0f75259ef19175e6c8f81fe110160f83c3ddf9cb39c36149bdd2b50a3a7c81a36fdfb4da28b60da339888aa6d668f6a812a49ee10fad41bf046b03b26214e0c31b0e82f671a184959092cabf3e3e3e0535a07efa1653fc03ef0bd163ab77360bf2a8b641d020a615081a68bac15139de790c830c31cbd4815c0f706b48367f6ad1f3604a1ce6520ed8bdd5b8afcab64d0bc58434777a4854fa7bafb7ac23a9b8e49feabfce998bbeea84dc0fbb07ce715beb56336a8d1da542a00c58487344da7878e114248acf15a06f1ea95a8a0c72fe4723e921391c08b51e471bceab526bd1fd3afbf9ac128d5cd1ad7efb39004afbebaeae58a206c2677862d23e8cdb6468e5b35e7bf31191b4223fd0a0d534b0b8490da7da774ade872451f52f9a2aa575b70ac8c608c16f06db89ece938a73ad93d926aeb3634eb0288d1b2d40205f5a2097ca304d1b76de17a7070e6fb71495b26712f28f577e706cc9a5c8d38229ab5cd4d49f26877db7f27a2485449f395d76d0df019c72d9998a88407d19839fd34a5c28aacc7ef2eb37737eaa8c52e3f9957c7067ce8292a94fe9ad435a08ca539b96c3440ea7d73c92d57dc0acf616ac5a8726495f5cbb42941ea426e22c35952b39d3d2bd41612ba8b486567464b6895f500fcb5fee69cf7c3ab1030cabdde67e580b7661121ddfcfe651b70a28087d28a28bf1d17761eb2a1d268cf08580500de7415c99273621108baa6d0a2e6b515091f742379ffcbf0c67a97dd374baf5be240cd0d1f0715fec3c601a352c0f55503dd049ea726adcec39fe63cd0d5115e1e795dab90329669ef918fa4d42c68905ac8ac809816868b3aa7f991dc049228f46e594eb05849e6024b9ba41388824d789ce094de1c2dd60835265738b492dd505837bda927938a87cfadca1f42fbb545fd174b2064039f18a98ab38bdec1298b862c56c6db6cf6f088fa10d1c7f8d1e2988dbc7e458a119ef10a4f03e9dd6753e0120cd94cbe979c9e07997ba2b17bd186380fa0e70fd792bc7c0aa21f1192c76268cebccb2f98f99ac4352a0b3eb809ef71a5351b6c3d9057e2f0d92841fc2d1a9004c4a85a9a46fc6fe3ca6f79109c6002a8d632aaf54bea2e3237e7d749d7d1f45d5419b98b7b5db995435771bda056c5de0ccd9cd53598c607a131232338706fd1909beb2ac12837f475d8c4434e7f7146e519b5cc0239082d0d49da4a66947730c39bd058d8fbceab3e9ab520bf99528100f3897bd710819d7d081df7d6faf0470237ac888fbfba79b94156c0478e17c18</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">文章被主人加密了, 小窝要核验主人给的『通行证』.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指数、对数、双曲函数的导数与极限</title>
      <link href="/2024/01/19/%5Bcalculus04%5D%E6%8C%87%E6%95%B0%E3%80%81%E5%AF%B9%E6%95%B0%E3%80%81%E5%8F%8C%E6%9B%B2%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/"/>
      <url>/2024/01/19/%5Bcalculus04%5D%E6%8C%87%E6%95%B0%E3%80%81%E5%AF%B9%E6%95%B0%E3%80%81%E5%8F%8C%E6%9B%B2%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>微积分学习笔记 - 04 指数、对数、双曲函数的导数与极限</p><p>进入 <a href="/categories/微积分学习笔记/">传送门</a>，阅读刊载在专栏《微积分阅读笔记》下的全部文章。</p></blockquote><h1 id="六、指数函数与对数函数的导数"><a href="#六、指数函数与对数函数的导数" class="headerlink" title="六、指数函数与对数函数的导数"></a>六、指数函数与对数函数的导数</h1><p>本节通过对自然常数 $\mathrm{e}$ 的探究推出指数与对数函数的导数。请务必在阅读本节前了解指数与对数的基本运算性质。</p><h2 id="6-1-emsp-mathrm-e-的定义与相关极限"><a href="#6-1-emsp-mathrm-e-的定义与相关极限" class="headerlink" title="6.1 &emsp; $\mathrm{e}$ 的定义与相关极限"></a>6.1 &emsp; $\mathrm{e}$ 的定义与相关极限</h2><p><strong>$\mathrm{e}$ 的定义</strong> &emsp; 对于极限，定义</p><script type="math/tex; mode=display">\mathrm{e}=\lim\limits_{h\to 0^+}(1+h)^{\frac1h}</script><p>关于它的求解与证明暂时略去。通过上述极限可以推出许多性质。</p><p>考虑极限</p><script type="math/tex; mode=display">L=\lim\limits_{n\to \infty}(1+\dfrac rn)^n</script><p>令 $h=\dfrac rn$，这样 $n=\dfrac rh$，对上述极限变形，有</p><script type="math/tex; mode=display">L=\lim\limits_{h\to 0^+}(1+h)^{\frac rh}=\lim\limits_{h\to 0^+}((1+h)^{\frac 1h})^r=\mathrm{e}^r</script><p>注意此时变成了 $h\to 0^+$ 处的极限。这样，就有重要极限</p><script type="math/tex; mode=display">\boxed{\lim\limits_{n\to \infty}(1+\dfrac xn)^n=\mathrm{e}^x}\tag{1}</script><p>特殊地，当 $x=1$ 时，有</p><script type="math/tex; mode=display">\boxed{\lim\limits_{n\to \infty}(1+\dfrac 1n)^n=\mathrm{e}}</script><p>对于极限 $(1)$，令 $h=\dfrac 1n$，有</p><script type="math/tex; mode=display">\lim\limits_{h\to 0^+}(1+rh)^{\frac 1h}=\mathrm{e}^r</script><p>注意极限位置。得出另一个重要极限</p><script type="math/tex; mode=display">\boxed{\lim\limits_{h\to 0^+}(1+xh)^{\frac 1h}=\mathrm{e}^x}</script><p>特殊地，当 $x=1$ 时，有</p><script type="math/tex; mode=display">\boxed{\lim\limits_{h\to 0^+}(1+h)^{\frac 1h}=\mathrm{e}}</script><h2 id="6-2-emsp-对数函数与指数函数的导数"><a href="#6-2-emsp-对数函数与指数函数的导数" class="headerlink" title="6.2 &emsp; 对数函数与指数函数的导数"></a>6.2 &emsp; 对数函数与指数函数的导数</h2><p>使用导数的定义，令 $f(x)=\log_bx$，则有</p><script type="math/tex; mode=display">\begin{aligned}f'(x)&=\lim\limits_{h\to 0}\dfrac{f(x+h)-f(x)}{h}=\lim\limits_{h\to 0}\dfrac{\log_b(x+h)-\log _bx}h\\&=\lim\limits_{h\to 0}\dfrac 1h\log_b(\dfrac{x+h}x)\\&=\lim\limits_{h\to 0}\log_b(1+\dfrac hx)^{\frac 1h}\end{aligned}</script><p>上一节中，我们证明了</p><script type="math/tex; mode=display">\lim\limits_{h\to 0^+}(1+rh)^{\frac 1h}=\mathrm{e}^r</script><p>不妨令 $r=\dfrac 1x$，则有</p><script type="math/tex; mode=display">\begin{aligned}f'(x)&=\lim\limits_{h\to 0}\log_b(1+\dfrac hx)^{\frac 1h}=\log_b(\mathrm{e}^\frac1x)\\&=\dfrac{\ln \mathrm{e}^\frac 1x}{\ln b}\\&=\dfrac 1{x\ln b}\end{aligned}</script><p>这就证明了<strong>对数函数的导数</strong>为</p><script type="math/tex; mode=display">\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\log_bx=\dfrac 1{x\ln b}}</script><p>特殊地，自然对数的导数为</p><script type="math/tex; mode=display">\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\ln x=\dfrac 1x}</script><p>接下来推导指数函数的导数。对于指数函数 $y=a^x$，等价于 $x=\log_ay$。现在关于 $y$ 求导，有：</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}x}{\mathrm{d}y}=\dfrac1{x\ln a}</script><p>根据链式求导法则，$\dfrac{\mathrm{d}x}{\mathrm{d}x}=\dfrac{\mathrm{d}y}{\mathrm{d}x}\dfrac{\mathrm{d}x}{\mathrm{d}y}=1$，可以上下颠倒得到：</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}y}{\mathrm{d}x}=y\ln a=a^x\ln a</script><p>这就证明了<strong>指数函数的导数</strong>为</p><script type="math/tex; mode=display">\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}a^x=a^x\ln a}</script><p>特殊地，以自然常数为底数的指数，导数为</p><script type="math/tex; mode=display">\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\mathrm{e}^x=\mathrm{e}^x}</script><p>这是一个独特的公式。发现它的导数还是它自己。</p><h2 id="6-3-emsp-伸缩函数的导数"><a href="#6-3-emsp-伸缩函数的导数" class="headerlink" title="6.3 &emsp; 伸缩函数的导数"></a>6.3 &emsp; 伸缩函数的导数</h2><p>这里的<strong>伸缩函数</strong>，定义为：对于函数 $y=f(x)$，则其伸缩函数为 $y’=f(ax)$，其中，$a$ 为常数。</p><p>对伸缩函数求导，即 $\dfrac{\mathrm{d}}{\mathrm{d}x} f(ax)$，根据链式求导法则，令 $u=ax$，则 $y=f(u)$，有</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}y}{\mathrm{d}x}=\dfrac{\mathrm{d}y}{\mathrm{d}u}\dfrac{\mathrm{d}u}{\mathrm{d}x}=af'(u)=af'(ax)</script><p>可以发现，伸缩函数的导数与原本函数的导数相比，前面多了 $a$ 的常数。</p><p>这个规律对指数对数函数、三角函数同样适用，例如，$y=\mathrm{e}^{-3x}$，则其导数为 $\dfrac{\mathrm{d}y}{\mathrm{d}x}=-3\mathrm{e}^{-3x}$。</p><h2 id="6-4-emsp-取对数求导法"><a href="#6-4-emsp-取对数求导法" class="headerlink" title="6.4 &emsp; 取对数求导法"></a>6.4 &emsp; 取对数求导法</h2><p>对于类似 $y=f(x)^{g(x)}$ 一类指数与底数均为 $x$ 的函数的导数问题，通常使用取对数求导法，具体地：</p><ul><li>对等号两边取自然对数，使指数移下来成为系数得到类似 $\ln y=g(x)\ln f(x)$ 的式子；</li><li>对等号两边进行隐函数求导，有 $\dfrac 1y\dfrac{\mathrm{d}y}{\mathrm{d}x}=\dfrac{\mathrm{d}}{\mathrm{d}x}g(x)\ln f(x)$；</li><li>对等式化简，完成求解。</li></ul><blockquote><p><strong>例子</strong> &emsp; 求解导数 $\dfrac{\mathrm{d}}{\mathrm{d}x}x^{\sin(x)}$。</p></blockquote><p>令 $y=x^{\sin(x)}$，对等式两边取对数得到 $\ln y=\sin(x)\ln x$，对隐函数求导有</p><script type="math/tex; mode=display">\dfrac 1y \dfrac{\mathrm{d}y}{\mathrm{d}x}=\cos(x)\ln x+\dfrac {\sin(x)}x</script><p>化简得到</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}y}{\mathrm{d}x}x^{\sin(x)}=(\cos(x)\ln x+\dfrac {\sin(x)}x)x^{\sin(x)}</script><h1 id="七、指数函数与对数函数的极限"><a href="#七、指数函数与对数函数的极限" class="headerlink" title="七、指数函数与对数函数的极限"></a>七、指数函数与对数函数的极限</h1><p>本节将借助指数函数与对数函数的导数，求解二者在特殊位置的极限与变化率。将其变化率与其他初等函数比较，会有重要的性质。</p><h2 id="7-1-emsp-涉及-mathrm-e-的极限"><a href="#7-1-emsp-涉及-mathrm-e-的极限" class="headerlink" title="7.1 &emsp; 涉及 $\mathrm e$ 的极限"></a>7.1 &emsp; 涉及 $\mathrm e$ 的极限</h2><p>涉及 $\mathrm e$ 的极限，通常借助重要结论求解：</p><script type="math/tex; mode=display">\lim\limits_{h\to 0^+}(1+h)^{\frac 1h}=\mathrm{e}\tag{2}</script><blockquote><p><strong>例子</strong> &emsp; 求解极限 $\lim\limits_{h\to 0}(1+h^2)^{\frac1{3h^2}}$。</p></blockquote><p>容易发现，这个式子形式很像 $(2)$ 式，不妨就通过这个突破点思考。令 $x=h^2$，则原极限等价于</p><script type="math/tex; mode=display">\lim\limits_{x\to 0}(1+x^2)^{\frac 1{x}\cdot \frac 13}=\mathrm e ^{\frac 13}</script><p>便可求解。</p><h2 id="7-2-emsp-指数函数的行为"><a href="#7-2-emsp-指数函数的行为" class="headerlink" title="7.2 &emsp; 指数函数的行为"></a>7.2 &emsp; 指数函数的行为</h2><p>下面是指数函数 $y=\mathrm e^x$ 的图像。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=OEon7oi0" style="zoom:67%;" /></p><p>根据指数函数图像，不难发现指数函数 $y=a^x(a&gt;1)$ 有两个重要极限</p><script type="math/tex; mode=display">\lim\limits_{x\to \infty}a^x=\infty\quad,\quad \lim\limits_{x\to -\infty}a^x=0</script><p>当 $0&lt;a&lt;1$ 是有相反的性质</p><script type="math/tex; mode=display">\lim\limits_{x\to \infty}a^x=0\quad,\quad \lim\limits_{x\to -\infty}a^x=\infty</script><p><strong>指数函数增长迅速</strong>：对于任意多项式函数 $f(x)$，都有 $\boxed{\lim\limits_{x\to \infty}\dfrac{f(x)}{\mathrm e^x}=0}$。</p><p>下面分析指数函数在 $0$ 附近的行为。</p><p>根据函数过定点，显然有 $\lim\limits_{x\to 0}\mathrm e^x=1$。</p><p>设 $f(x)=\mathrm e^x$，其导数为 $\mathrm e^x$，在 $x=0$ 时为 $1$。换一种方式分析，根据导数定义有：</p><script type="math/tex; mode=display">\begin{aligned}\lim\limits_{h\to 0}\dfrac{\mathrm e^{x+h}+\mathrm e^x}h=\mathrm e^x\end{aligned}</script><p>在 $x\to 0$ 时有</p><script type="math/tex; mode=display">\lim\limits_{h\to 0}\dfrac{\mathrm e^h-1}h=1</script><h2 id="7-3-emsp-对数函数的行为"><a href="#7-3-emsp-对数函数的行为" class="headerlink" title="7.3 &emsp; 对数函数的行为"></a>7.3 &emsp; 对数函数的行为</h2><p>下面是对数函数 $y=\ln x$ 的图像。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=wRfD30Hf" style="zoom: 67%;" /></p><p>根据指数函数图像，不难发现指数函数 $y=\log _ax(a&gt;1)$ 有两个重要极限</p><script type="math/tex; mode=display">\lim\limits_{x\to 0^+}\log_ax=-\infty\quad,\quad \lim\limits_{x\to \infty}\log_ax=\infty</script><p>当 $0&lt;a&lt;1$ 是有相反的性质</p><script type="math/tex; mode=display">\lim\limits_{x\to 0^+}a^x=\infty\quad,\quad \lim\limits_{x\to -\infty}\log_ax=-\infty</script><p><strong>对数函数增长缓慢</strong>：对于任意多项式函数 $f(x)$，都有 $\boxed{\lim\limits_{x\to \infty}\dfrac{\ln x}{f(x)}=0}$</p><p>对于极限 $\lim\limits_{x\to 0^+}x\ln x$，令 $t=\dfrac 1x$，则有：</p><script type="math/tex; mode=display">\lim\limits_{x\to 0^+}x\ln x=\lim\limits_{t\to \infty}\dfrac 1t\ln \dfrac 1t=\lim\limits_{t\to \infty}\dfrac{-\ln t}t=0</script><p>得到结论，<strong>对数函数在 $0$ 附近增长缓慢</strong>：$\forall a&gt;0,\boxed{\lim\limits_{x\to 0^+}x^a\ln x=0}$。</p><h1 id="八、双曲函数的导数"><a href="#八、双曲函数的导数" class="headerlink" title="八、双曲函数的导数"></a>八、双曲函数的导数</h1><p>下面探究一下<strong>双曲函数</strong>。双曲函数与三角函数有比较相似的性质。</p><h2 id="8-1-emsp-双曲正弦函数与双曲余弦函数"><a href="#8-1-emsp-双曲正弦函数与双曲余弦函数" class="headerlink" title="8.1 &emsp; 双曲正弦函数与双曲余弦函数"></a>8.1 &emsp; 双曲正弦函数与双曲余弦函数</h2><p>下面给出定义：</p><ul><li><strong>双曲正弦函数</strong>：$\sinh(x)=\dfrac{\mathrm e^x-\mathrm e^{-x}}2$；</li><li><strong>双曲余弦函数</strong>：$\cosh(x)=\dfrac{\mathrm e^x+\mathrm e^{-x}}2$。</li></ul><p>会发现，$\cosh^2(x)-\sinh^2(x)=\dfrac{\mathrm e^{2x}+\mathrm e^{-2x}+2}4-\dfrac{\mathrm e^{2x}+\mathrm e^{-2x}2}4=1$，得出与三角函数很像的结论：</p><script type="math/tex; mode=display">\cosh^2(x)-\sinh^2(x)=1</script><p>接下来对两式求导：</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}}{\mathrm{d}x}\sinh(x)=\dfrac{\mathrm{d}}{\mathrm{d}x}(\dfrac{\mathrm e^x-\mathrm e^{-x}}2)=\dfrac{\mathrm e^x+\mathrm e^{-x}}2=\cosh(x)</script><script type="math/tex; mode=display">\dfrac{\mathrm{d}}{\mathrm{d}x}\cosh(x)=\dfrac{\mathrm{d}}{\mathrm{d}x}(\dfrac{\mathrm e^x+\mathrm e^{-x}}2)=\dfrac{\mathrm e^x-\mathrm e^{-x}}2=\sinh(x)</script><p>发现二者互为导数，即：</p><script type="math/tex; mode=display">\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\sinh(x)=\cosh(x)}\quad,\quad \boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\cosh(x)=\sinh(x)}</script><p>下面是两函数的图像。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=kC7j0DFk" style="zoom:67%;" /></p><h2 id="8-2-emsp-其他双曲函数"><a href="#8-2-emsp-其他双曲函数" class="headerlink" title="8.2 &emsp; 其他双曲函数"></a>8.2 &emsp; 其他双曲函数</h2><p>借助双曲正弦与双曲余弦函数的定义，推出下面四种双曲函数的定义与导数：</p><ul><li><strong>双曲正切函数</strong>：$\tanh(x)=\dfrac{\sinh(x)}{\cosh(x)}=\dfrac{\mathrm e^x-\mathrm e^{-x}}{\mathrm e^x+\mathrm e^{-x}}$；</li><li><strong>双曲余切函数</strong>：$\coth(x)=\dfrac{\cosh(x)}{\sinh(x)}=\dfrac{\mathrm e^x+\mathrm e^{-x}}{\mathrm e^x-\mathrm e^{-x}}$；</li><li><strong>双曲正割函数</strong>：$\text{sech}(x)=\dfrac1{\cosh(x)}=\dfrac2{\mathrm e^x+\mathrm e^{-x}}$；</li><li><strong>双曲余割函数</strong>：$\text{csch}(x)=\dfrac1{\sinh(x)}=\dfrac2{\mathrm e^x-\mathrm e^{-x}}$。</li></ul><p>从 $\cosh^2(x)-\sinh^2(x)=1$ 可以推出：</p><script type="math/tex; mode=display">1-\tanh^2(x)=\text{sech}^2(x)</script><p>与双曲正弦与双曲正切函数类似，它们的导数为：</p><script type="math/tex; mode=display">\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\tanh(x)=\text{sech}^2(x)}\quad,\quad \boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\coth(x)=-\text{csch}^2(x)}</script><script type="math/tex; mode=display">\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\text{sech}(x)=-\text{sech}(x)\tanh(x)}\quad,\quad \boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\text{csch}(x)=-\text{csch}(x)\coth(x)}</script><p>下面是这四个函数的图像。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=O08RO95A" style="zoom:67%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 微积分学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隐函数求导</title>
      <link href="/2024/01/19/%5Bcalculus03%5D%E9%9A%90%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC/"/>
      <url>/2024/01/19/%5Bcalculus03%5D%E9%9A%90%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>微积分学习笔记 - 03 隐函数求导</p><p>进入 <a href="/categories/微积分学习笔记/">传送门</a>，阅读刊载在专栏《微积分阅读笔记》下的全部文章。</p></blockquote><h1 id="五、隐函数求导"><a href="#五、隐函数求导" class="headerlink" title="五、隐函数求导"></a>五、隐函数求导</h1><p>这一节与其他节相关很少，但后面也要经常用到，所以只好单拎出来。</p><h2 id="5-1-emsp-隐函数求导"><a href="#5-1-emsp-隐函数求导" class="headerlink" title="5.1 &emsp; 隐函数求导"></a>5.1 &emsp; 隐函数求导</h2><p>考虑两个导数</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}}{\mathrm{d}x}(x^2) \quad,\quad \dfrac{\mathrm{d}}{\mathrm{d}x}(y^2)</script><p>前者显然为 $2x$，但后者却不一定。这主要取决于变量 $y$ 与变量 $x$ 间的变化关系。</p><p>那怎样求它的导数呢？参考链式求导法则，变量 $x$ 的改变会导致变量 $y$ 的改变，而变量 $y$ 的改变又会导致 $y^2$ 的改变。</p><p>令 $u=y^2$，则 $\dfrac{\mathrm{d}u}{\mathrm{d}y}=2y$，则：</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}}{\mathrm{d}x}(y^2)=\dfrac{\mathrm{d}u}{\mathrm{d}y}\dfrac{\mathrm{d}y}{\mathrm{d}x}=2y\dfrac{\mathrm{d}y}{\mathrm{d}x}</script><p>这就求出了它的导数。显然，若 $x$ 与 $y$ 毫不相干的时候，导数就为 $0$。</p><blockquote><p><strong>例子</strong> &emsp; 对于圆的方程 $x^2+y^2=4$，求圆上各点的切线的斜率。</p></blockquote><p>对于这个例子，因为 $y$ 并不是 $x$ 的函数，并不能直接求导，可以通过在等式两边同时加上 $\dfrac{\mathrm{d}}{\mathrm{d}x}$ 对隐函数求导，即：</p><script type="math/tex; mode=display">\begin{aligned}\dfrac{\mathrm{d}}{\mathrm{d}x}(x^2+y^2)&=\dfrac{\mathrm{d}}{\mathrm{d}x}4\\\dfrac{\mathrm{d}}{\mathrm{d}x}(x^2)+\dfrac{\mathrm{d}}{\mathrm{d}x}(y^2)&=0\\2x+2y\dfrac{\mathrm{d}y}{\mathrm{d}x}&=0\\\dfrac{\mathrm{d}y}{\mathrm{d}x}&=-\dfrac xy\end{aligned}</script><p>只需要对圆上的每个点 $(x,y)$ 对应求导即可。</p><p>对于求隐函数导数的问题，通常采用以下方法：</p><ul><li>对原方程进行简化；</li><li>对等式两边同时对一个变量求导，即同时乘上 $\dfrac{\mathrm{d}}{\mathrm{d}x}$，并化简；</li><li>若需求出曲线上某点的切线方程，则需代入对应 $x,y$ 求解。</li></ul><h2 id="5-2-emsp-隐函数求二阶导"><a href="#5-2-emsp-隐函数求二阶导" class="headerlink" title="5.2 &emsp; 隐函数求二阶导"></a>5.2 &emsp; 隐函数求二阶导</h2><p>隐函数求二阶导的方法和普通函数类似——在一阶导的基础上求导。</p><blockquote><p><strong>例子</strong> &emsp; 求函数 $2y+\sin(y)=\dfrac{x^2}\pi +1$ 的二阶导 $\dfrac{\mathrm{d}^2y}{\mathrm{d}x^2}$。</p></blockquote><p>对隐函数先求一阶导，有：</p><script type="math/tex; mode=display">2\dfrac{\mathrm{d}y}{\mathrm{d}x}+\cos(y)\dfrac{\mathrm{d}y}{\mathrm{d}x}=\dfrac{2x}\pi\tag{1}</script><p>在 $(1)$ 上进而对其求二阶导：</p><script type="math/tex; mode=display">\begin{aligned}\dfrac{\mathrm{d}}{\mathrm{d}x}(2\dfrac{\mathrm{d}y}{\mathrm{d}x})+\dfrac{\mathrm{d}}{\mathrm{d}x}(\cos(y)\dfrac{\mathrm{d}y}{\mathrm{d}x})&=\dfrac{\mathrm{d}}{\mathrm{d}x}(\dfrac{2x}\pi)\\2\dfrac{\mathrm{d}^2y}{\mathrm{d}x^2}-\sin(y)(\dfrac{\mathrm{d}y}{\mathrm{d}x})^2+\cos(y)\dfrac{\mathrm{d}^2y}{\mathrm{d}x^2}&=\dfrac2\pi\\\end{aligned}</script><p>化简得到</p><script type="math/tex; mode=display">2\dfrac{\mathrm{d}^2y}{\mathrm{d}x^2}=(\dfrac{\mathrm{d}y}{\mathrm{d}x})^2+\dfrac2\pi</script><p>下面解决 $\dfrac{\mathrm{d}y}{\mathrm{d}x}$ 的求解，根据 $(1)$ 得：</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}y}{\mathrm{d}x}=\dfrac{2x}{\pi(2+\cos(y))}</script><p>代入得</p><script type="math/tex; mode=display">\begin{aligned}\dfrac{\mathrm{d}^2y}{\mathrm{d}x^2}&=\dfrac{(\dfrac{2x}{\pi(2+\cos(y))})^2+\dfrac2\pi}{2}\\&=\dfrac{2x^2}{\pi^2(2+\cos(y))^2}+\frac1\pi\end{aligned}</script>]]></content>
      
      
      <categories>
          
          <category> 微积分学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三角函数的极限和导数</title>
      <link href="/2024/01/14/%5Bcalculus02%5D%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E9%99%90%E5%92%8C%E5%AF%BC%E6%95%B0/"/>
      <url>/2024/01/14/%5Bcalculus02%5D%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E9%99%90%E5%92%8C%E5%AF%BC%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>  微积分学习笔记 - 02 三角函数的极限和导数</p><p>  进入 <a href="/categories/微积分学习笔记/">传送门</a>，阅读刊载在专栏《微积分阅读笔记》下的全部文章。</p></blockquote><h1 id="三、三角函数的极限"><a href="#三、三角函数的极限" class="headerlink" title="三、三角函数的极限"></a>三、三角函数的极限</h1><p>本节简短记录几个比较重要的三角函数极限，对后文推出三角函数的导数有重要作用。</p><h2 id="3-1-emsp-正弦函数的极限"><a href="#3-1-emsp-正弦函数的极限" class="headerlink" title="3.1 &emsp; 正弦函数的极限"></a>3.1 &emsp; 正弦函数的极限</h2><p>首先考虑一个重要极限</p><script type="math/tex; mode=display">\lim\limits_{x\to 0}\dfrac{\sin(x)}{x}</script><p>这个极限的求解将借助单位圆完成。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=4CRL3xmn" alt=""></p><p>三角形 OAC、扇形 OAB、三角形 ODB 的面积分别等于 $\dfrac{\sin(x)}{2}$，$\dfrac x 2$，$\dfrac{\tan(x)} 2$，有不等关系</p><script type="math/tex; mode=display">\sin(x)<x<\tan(x)</script><p>对于 $x&gt;0$ 的情况进一步转化可得</p><script type="math/tex; mode=display">\cos(x)<\dfrac{\sin(x)}x<1</script><p>使用三明治定理，在 $x=0$ 的位置，$\cos(x)=1$，所以得到右极限 </p><script type="math/tex; mode=display">\lim\limits_{x\to 0^+}\dfrac{\sin(x)}{x}=1</script><p>由于上述函数是奇函数，不难得到双侧极限</p><script type="math/tex; mode=display">\boxed{\lim\limits_{x\to 0}\dfrac{\sin(x)}{x}=1}</script><p>求解正弦函数的极限，通常利用正弦函数的值域特征 $-1\le \sin(x)\le 1$ 简化问题。</p><h2 id="3-2-emsp-余弦函数的极限"><a href="#3-2-emsp-余弦函数的极限" class="headerlink" title="3.2 &emsp; 余弦函数的极限"></a>3.2 &emsp; 余弦函数的极限</h2><p>显然，我们有极限</p><script type="math/tex; mode=display">\lim \limits_{x\to 0}\cos(x)=1</script><p>接下来考虑极限</p><script type="math/tex; mode=display">\lim \limits_{x\to 0}\dfrac{1-\cos(x)}{x}</script><p>尝试让分子出现 $1-\cos^2(x)$，从而出现 $\sin^2(x)$，借助正弦函数极限求解。</p><script type="math/tex; mode=display">\begin{aligned}\lim \limits_{x\to 0}\dfrac{1-\cos(x)}{x}&=\lim\limits_{x\to 0}\dfrac{1-\cos(x)}{x}\times \dfrac{1+\cos(x)}{1+\cos(x)} \\&=\lim \limits_{x\to 0}\dfrac{1-\cos^2(x)}{x(1+\cos(x))}\\&=\lim \limits_{x\to 0}\dfrac{\sin^2(x)}{x}\times \dfrac{1}{1+\cos(x)}\\&=\lim \limits_{x\to 0}\sin(x)\times \dfrac{\sin(x)}{x}\times \dfrac{1}{1+\cos(x)}\\&=0\times 1\times \dfrac{1}{1+1}\\&=0\end{aligned}</script><p>所以得到重要结论</p><script type="math/tex; mode=display">\boxed{\lim \limits_{x\to 0}\dfrac{1-\cos(x)}{x}=0}</script><p>考虑另一个极限</p><script type="math/tex; mode=display">\lim \limits_{x\to 0}\dfrac{1-\cos(x)}{x^2}</script><p>借助上面的思路，不难得到</p><script type="math/tex; mode=display">\begin{aligned}\lim \limits_{x\to 0}\dfrac{1-\cos(x)}{x^2}&=\lim \limits_{x\to 0}\dfrac{1-\cos(x)}{x^2}\times \dfrac{1+\cos(x)}{1+\cos(x)}\\&=\lim \limits_{x\to 0}\dfrac{1-\cos^2(x)}{x^2}\times \dfrac{1}{1+cos(x)}\\&=\lim \limits_{x\to 0}(\dfrac{\sin(x)}{x})^2\times \dfrac{1}{1+\cos(x)}\\&=1^2\times \dfrac{1}{1+1}\\&=\dfrac12\end{aligned}</script><h2 id="3-3-emsp-正切函数的极限"><a href="#3-3-emsp-正切函数的极限" class="headerlink" title="3.3 &emsp; 正切函数的极限"></a>3.3 &emsp; 正切函数的极限</h2><p>考虑极限</p><script type="math/tex; mode=display">\lim \limits_{x\to 0}\dfrac{\tan(x)}{x}</script><p>作变换 $\tan(x)=\dfrac{\sin(x)}{\cos(x)}$ 可得</p><script type="math/tex; mode=display">\begin{aligned}\lim \limits_{x\to 0}\dfrac{\tan(x)}{x}&=\lim \limits_{x\to 0}\dfrac{\dfrac{\sin(x)}{\cos(x)}}{x}\\&=\lim \limits_{x\to 0}\dfrac{sin(x)}{x}\times \dfrac1{cos(x)}\\&=1\times \dfrac11\\&=1\end{aligned}</script><p>这也就证明了</p><script type="math/tex; mode=display">\boxed{\lim \limits_{x\to 0}\dfrac{\tan(x)}{x}=1}</script><h1 id="四、三角函数的导数"><a href="#四、三角函数的导数" class="headerlink" title="四、三角函数的导数"></a>四、三角函数的导数</h1><p>借助第三节的推论，可以推出六种三角函数的导数。本节将对它们分别推出与证明。</p><p>下面是六种三角函数的导数对照表：</p><script type="math/tex; mode=display">\begin{array}{|c|c|}f(x)=&f'(x)=\\\sin(x)&\cos(x)\\\cos(x)&-\sin(x)\\\tan(x)&\sec^2(x)\\\cot(x)&-\csc^2(x)\\\sec(x)&\sec(x)\tan(x)\\\csc(x)&-\csc(x)\cot(x)\end{array}</script><h2 id="4-1-emsp-正弦函数的导数"><a href="#4-1-emsp-正弦函数的导数" class="headerlink" title="4.1 &emsp; 正弦函数的导数"></a>4.1 &emsp; 正弦函数的导数</h2><p>借助第三节中的两个极限</p><script type="math/tex; mode=display">\lim \limits_{h\to 0}\dfrac{\sin(h)}{h}=1\quad,\quad \lim \limits_{h\to 0}\dfrac{1-\cos(h)}{h}=0</script><p>直接使用导数定义与和角公式，令 $f(x)=\sin(x)$，推出：</p><script type="math/tex; mode=display">\begin{aligned}f'(x)&=\lim \limits_{h\to 0}\dfrac{f(x+h)-f(x)}{h}=\lim \limits_{h\to 0}\dfrac{\sin(x+h)-\sin(h)}{h}\\&=\lim \limits_{h\to 0}\dfrac{\sin(x)\cos(h)+\cos(x)\sin(h)-\sin(x)}h\\&=\lim \limits_{h\to 0}\dfrac{\sin(x)(\cos(h)-1)+\cos(x)\sin(h)}h\\&=\lim \limits_{h\to 0}(\sin(x)\times \dfrac{\cos(h)-1}h+\cos(x)\times \dfrac{\sin(h)}h)\\&=\sin(x)\times 0+\cos(x)\times 1\\&=\cos(x)\end{aligned}</script><p>得出其导数为</p><script type="math/tex; mode=display">\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\sin(x)=\cos(x)}</script><h2 id="4-2-emsp-余弦函数的导数"><a href="#4-2-emsp-余弦函数的导数" class="headerlink" title="4.2 &emsp; 余弦函数的导数"></a>4.2 &emsp; 余弦函数的导数</h2><p>令 $f(x)=\cos(x)$，借助和角公式可得得到：</p><script type="math/tex; mode=display">\begin{aligned}f'(x)&=\lim \limits_{h\to 0}\dfrac{f(x+h)-f(x)}h=\lim \limits_{h\to 0}\dfrac{\cos(x+h)-\cos(x)}h\\&=\lim \limits_{h\to 0}\dfrac{\cos(x)\cos(h)-\sin(x)\sin(h)-\cos(x)}h\\&=\lim \limits_{h\to 0}\cos(x)\times \dfrac{\cos(h)-1}h-\sin(x)\times \dfrac{\sin(h)}h\\&=\cos(x)\times 0-\sin(x)\times 1\\&=-\sin(x)\end{aligned}</script><p>得出其导数为</p><script type="math/tex; mode=display">\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\cos(x)=-\sin(x)}</script><h2 id="4-3-emsp-正切函数的导数"><a href="#4-3-emsp-正切函数的导数" class="headerlink" title="4.3 &emsp; 正切函数的导数"></a>4.3 &emsp; 正切函数的导数</h2><p>令 $y=\tan(x)=\dfrac{\sin(x)}{\cos(x)}$，再令 $u=\sin(x),v=\cos(x)$，使用商法则得到：</p><script type="math/tex; mode=display">\begin{aligned}\dfrac{\mathrm{d}y}{\mathrm{d}x}&=\dfrac{v\dfrac{\mathrm{d}u}{\mathrm{d}x}-u\dfrac{\mathrm{d}v}{\mathrm{d}x}}{v^2}=\dfrac{\cos(x)\cos(x)-\sin(x)(-\sin(x))}{\cos^2(x)}\\&=\dfrac{1}{\cos^2(x)}\\&=\sec^2(x)\end{aligned}</script><p>得出其导数为</p><script type="math/tex; mode=display">\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\tan(x)=\sec^2(x)}</script><h2 id="4-4-emsp-余切函数的导数"><a href="#4-4-emsp-余切函数的导数" class="headerlink" title="4.4 &emsp; 余切函数的导数"></a>4.4 &emsp; 余切函数的导数</h2><p>令 $y=\cot(x)=\dfrac{\cos(x)}{\sin(x)}$，再令 $u=\cos(x),v=\sin(x)$，使用商法则得到：</p><script type="math/tex; mode=display">\begin{aligned}\dfrac{\mathrm{d}y}{\mathrm{d}x}&=\dfrac{v\dfrac{\mathrm{d}u}{\mathrm{d}x}-u\dfrac{\mathrm{d}v}{\mathrm{d}x}}{v^2}=\dfrac{\sin(x)(-\sin(x))-\cos(x)\cos(x)}{\sin^2(x)}\\&=\dfrac{-1}{\sin^2(x)}\\&=-\csc^2(x)\end{aligned}</script><p>得到其导数为</p><script type="math/tex; mode=display">\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\cot(x)=\csc^2(x)}</script><h2 id="4-5-emsp-正割函数的导数"><a href="#4-5-emsp-正割函数的导数" class="headerlink" title="4.5 &emsp; 正割函数的导数"></a>4.5 &emsp; 正割函数的导数</h2><p>令 $y=\sec(x)=\dfrac1{\cos(x)}$，再令 $u=\cos(x)$，则 $y=\dfrac1{u}$，使用链式求导法则得到：</p><script type="math/tex; mode=display">\begin{aligned}\dfrac{\mathrm{d}y}{\mathrm{d}x}&=\dfrac{\mathrm{d}y}{\mathrm{d}u}\dfrac{\mathrm{d}u}{\mathrm{d}x}=-\dfrac1{\cos^2(x)}(-\sin(x))\\&=\dfrac1{\cos(x)}\times\dfrac{\sin(x)}{\cos(x)}\\&=\sec(x)\tan(x)\end{aligned}</script><p>得出其导数为</p><script type="math/tex; mode=display">\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\sec(x)=\sec(x)\tan(x)}</script><h2 id="4-6-emsp-余割函数的导数"><a href="#4-6-emsp-余割函数的导数" class="headerlink" title="4.6 &emsp; 余割函数的导数"></a>4.6 &emsp; 余割函数的导数</h2><p>令 $y=\csc(x)=\dfrac1{\sin(x)}$，再令 $u=\sin(x)$，则 $y=\dfrac1{u}$，使用链式求导法则得到：</p><script type="math/tex; mode=display">\begin{aligned}\dfrac{\mathrm{d}y}{\mathrm{d}x}&=\dfrac{\mathrm{d}y}{\mathrm{d}u}\dfrac{\mathrm{d}u}{\mathrm{d}x}=-\dfrac1{\sin^2(x)}\cos(x)\\&=-\dfrac1{\sin(x)}\times\dfrac{\cos(x)}{\sin(x)}\\&=-\csc(x)\cot(x)\end{aligned}</script><p>得出其导数为</p><script type="math/tex; mode=display">\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\csc(x)=-\csc(x)\cot(x)}</script>]]></content>
      
      
      <categories>
          
          <category> 微积分学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>极限导论与微分</title>
      <link href="/2024/01/14/%5Bcalculus01%5D%E6%9E%81%E9%99%90%E5%AF%BC%E8%AE%BA%E4%B8%8E%E5%BE%AE%E5%88%86/"/>
      <url>/2024/01/14/%5Bcalculus01%5D%E6%9E%81%E9%99%90%E5%AF%BC%E8%AE%BA%E4%B8%8E%E5%BE%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>  微积分学习笔记 - 01 极限导论与微分</p><p>  进入 <a href="/categories/微积分学习笔记/">传送门</a>，阅读刊载在专栏《微积分阅读笔记》下的全部文章。</p></blockquote><h1 id="一、极限导论"><a href="#一、极限导论" class="headerlink" title="一、极限导论"></a>一、极限导论</h1><h2 id="1-1-emsp-极限的定义"><a href="#1-1-emsp-极限的定义" class="headerlink" title="1.1 &emsp; 极限的定义"></a>1.1 &emsp; 极限的定义</h2><p><strong>极限</strong>：对于函数 $f(x)$，任选 $\epsilon&gt;0$，可以任选 $\delta&gt;0$，使得：对于所有满足 $0&lt;|x-a|&lt;\delta$ 的 $x$，有 $|f(x)-L|&lt;\epsilon$，则称函数 $f(x)$ 在 $a$ 处的极限为 $L$，记作：</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow a}=L</script><p>上述定义可以简单理解成，在变量 $x$ 接近于 $a$ 时，函数值无限接近于 $L$。</p><p>例如，对于函数 $f(x)=x+1$，通过分析函数图像可知，有 $\lim\limits_{x\rightarrow 2}=3$。</p><p>再例如，对于函数 $g(x)=\begin{cases}x-1&amp;\text{如果}x\not=2\\3&amp;\text{如果}x=2\end{cases}$，事实上 $\lim\limits_{x\rightarrow 2}=1$。这是因为只有那些在 $x$ 接近于 $2$ 时的 $g(x)$ 的值，才是它的极限。</p><p><strong>左极限</strong>：与极限的定义类似地，只考虑 $x&lt;a$ 的部分，函数在这部分中，自变量接近于 $a$ 的时候，函数值的接近值，记作：</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow a^{-}} = L</script><p><strong>右极限</strong>：只考虑 $x&gt;a$ 的部分，函数在这部分中，之变量接近于 $a$ 的时候，函数值的接近值，记作：</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow a^{+}}=L</script><p>例如，函数 $f(x)=x^{-1}$ ，在 $0$ 附近的极限为：$\lim\limits_{x\rightarrow 0^{-}}=-\infty,\lim\limits_{x\rightarrow 0^{+}}=\infty$。发现 $0$ 附近的左极限和右极限不相等，所以 $f(x)$ 在 $0$ 附近的极限不存在。</p><p>通过总结发现，极限存在当且仅当此处的<strong>左极限和右极限存在且相等</strong>。也就是说，</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow a^{-}}=\lim\limits_{x\rightarrow a^{+}}=L</script><p>等价于</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow a}=L</script><p>相反的，<strong>极限不存在</strong>，记作</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow a}\text{DNE}</script><h2 id="1-2-emsp-三明治定理-夹逼定理"><a href="#1-2-emsp-三明治定理-夹逼定理" class="headerlink" title="1.2 &emsp; 三明治定理(夹逼定理)"></a>1.2 &emsp; 三明治定理(夹逼定理)</h2><p>如果对于所有在 $a$ 附近的 $x$ 都有 $g(x)\leq f(x)\leq h(x)$，且 $\lim\limits_{x\rightarrow a}g(x)=\lim\limits_{x\rightarrow a}h(x)=L$，则</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow a}f(x)=L</script><h2 id="1-3-emsp-求解-x-rightarrow-a-时多项式的极限问题"><a href="#1-3-emsp-求解-x-rightarrow-a-时多项式的极限问题" class="headerlink" title="1.3 &emsp; 求解 $x\rightarrow a$ 时多项式的极限问题"></a>1.3 &emsp; 求解 $x\rightarrow a$ 时多项式的极限问题</h2><p><strong>例题1</strong>：求解极限</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow -1}\frac{x^2-3x+2}{x-2}</script><p>因为函数定义域包含 $-1$，可以将 $x=-1$ 带入表达式中，得到这个极限为 $-2$。</p><p><strong>例题2</strong>：求解极限</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow 2}\frac{x^2-3x+2}{x-2}</script><p>我们发现直接将 $x=2$ 带入，分母为 $0$，不能这样求解。考虑对其因式分解，有</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow 2}\frac{x^2-3x+2}{x-2}=\lim\limits_{x\rightarrow 2}\frac{(x-2)(x-1)}{x-2}=\lim\limits_{x\rightarrow 2}(x-1)=1</script><p><strong>例题3</strong>：求解极限</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow 1}\frac{2x^2-x-6}{x(x-1)^3}</script><p>我们不能直接带入 $x=1$，尝试进行<strong>符号分析</strong>。其关键因子是 $(x-1)^3$，当 $x\rightarrow 1^+$ 时，其为正，并代入整个式子分析符号，有$\frac{(-)}{(+)(+)}=(-)$；当 $x\rightarrow 1^-$ 时，其为负，分析式子的符号，有$\frac{(-)}{(+)(-)}=(+)$。因此，这个极限<strong>不存在</strong>，但是存在左极限和右极限：</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow 1^-}\frac{2x^2-x-6}{x(x-1)^3}=-\infty \qquad \lim\limits_{x\rightarrow 1+}\frac{2x^2-x-6}{x(x-1)^3}=\infty</script><p><strong>例题4</strong>：求解极限</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow 5}\frac{\sqrt{x^2-9}-4}{x-5}</script><p>不能直接带入 $x=5$，考虑进行<strong>分子有理化</strong>，即分子分母共同乘上 $\sqrt{x^2-9}-4$ 的<strong>共轭表达式</strong>，有</p><script type="math/tex; mode=display">\begin{aligned}\lim\limits_{x\rightarrow 5}\frac{\sqrt{x^2-9}-4}{x-5}&=\lim\limits_{x\rightarrow 5}\frac{\sqrt{x^2-9}-4}{x-5}\times \frac{\sqrt{x^2-9}+4}{\sqrt{x^2-9}+4}\\&=\lim\limits_{x\rightarrow 5}\frac{x^2-25}{(x-5)(\sqrt{x^2-9}+4)}\\&=\lim\limits_{x\rightarrow 5}\frac{x+5}{\sqrt{x^2-9}+4}\\&=\frac{5}{4}\end{aligned}</script><h2 id="1-4-emsp-求解-x-rightarrow-infty-时多项式的极限问题"><a href="#1-4-emsp-求解-x-rightarrow-infty-时多项式的极限问题" class="headerlink" title="1.4 &emsp; 求解 $x\rightarrow \infty$ 时多项式的极限问题"></a>1.4 &emsp; 求解 $x\rightarrow \infty$ 时多项式的极限问题</h2><p>对于一个有理函数的极限</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow \infty}\frac{p(x)}{q(x)}</script><p>令 $p_L(x)$ 为函数 $p(x)$ 的最高次项，我们有</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow \infty}\frac{p(x)}{p_L(x)}=1</script><p>事实上，对于任意的 $n&gt;0$，$C$ 为常数，有</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow \infty}\frac{C}{x^n}=0</script><p><strong>例题5</strong>：求解极限</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow \infty}\frac{x-8x^4}{7x^4+5x^3+2000x^2-6}</script><p>我们找到分子的首项 $-8x^4$，分母的首项 $7x^4$，有</p><script type="math/tex; mode=display">\begin{aligned}\lim\limits_{x\rightarrow \infty}\frac{x-8x^4}{7x^4+5x^3+2000x^2-6}&=\lim\limits_{x\rightarrow \infty}\frac{\dfrac{x-8x^4}{-8x^4}\times (-8x^4)}{\dfrac{7x^4+5x^3+2000x^2-6}{7x^4}\times 7x^4}\\&=\lim\limits_{x\rightarrow \infty}\frac{-\dfrac{1}{8x^3}+1}{1+\dfrac{5}{7x}+\dfrac{2000}{7x^2}-\dfrac{6}{7x^4}}\times  \dfrac{-8x^4}{7x^4}\\&=\frac{0+1}{1+0+0-0}\times \frac{-8}{7}\\&=-\frac{8}{7}\end{aligned}</script><p>一般地，考虑极限</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow \infty}\frac{p(x)}{q(x)}</script><p>其中 $p,q$ 为多项式，我们有：</p><ol><li>如果 $p$ 的次数等于 $q$ 的次数，则极限是<strong>有限的且非零</strong>；</li><li>如果 $p$ 的次数大于 $q$ 的次数，则极限是 $\infty$ <strong>或</strong> $-\infty$；</li><li>如果 $p$ 的次数等于 $q$ 的次数，则极限是 $0$。</li></ol><h2 id="1-5-emsp-求解-x-rightarrow-infty-时多项式的极限问题"><a href="#1-5-emsp-求解-x-rightarrow-infty-时多项式的极限问题" class="headerlink" title="1.5 &emsp; 求解 $x\rightarrow -\infty$ 时多项式的极限问题"></a>1.5 &emsp; 求解 $x\rightarrow -\infty$ 时多项式的极限问题</h2><p>求解 $x\rightarrow -\infty$ 时的极限，答题思路和上面相仿，特殊地，需要考虑被开方数的<strong>正负性</strong>。</p><p><strong>例题6</strong>：求解极限</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow -\infty}\frac{\sqrt{4x^6+8}}{2x^3+6x+1}</script><p>可以找到分母的首项 $2x^3$，分子的首项 $\sqrt{4x^6}$，特别注意 $x&lt;0$ 时，$\sqrt{4x^6}=-2x^3$。有</p><script type="math/tex; mode=display">\begin{aligned}\lim\limits_{x\rightarrow -\infty}\frac{\sqrt{4x^6+8}}{2x^3+6x+1}&=\lim\limits_{x\rightarrow \infty}\frac{\dfrac{\sqrt{4x^6+8}}{\sqrt{4x^6}}\times \sqrt{4x^6}}{\dfrac{2x^3+6x+1}{2x^3}\times 2x^3}\\&=\lim\limits_{x\rightarrow \infty}\frac{\sqrt{\dfrac{4x^6+8}{4x^6}}}{\dfrac{2x^3+6x+1}{2x^3}}\times \frac{\sqrt{4x^6}}{2x^3}\\&=\lim\limits_{x\rightarrow \infty}\frac{\sqrt{1+\dfrac{8}{4x^6}}}{1+\dfrac{6x}{2x^3}+\dfrac{1}{2x^3}}\times \frac{-2x^3}{2x^3}\\&=\frac{\sqrt{1+0}}{1+0+0}\times (-1)\\&=-1\end{aligned}</script><h1 id="二、求解微分问题"><a href="#二、求解微分问题" class="headerlink" title="二、求解微分问题"></a>二、求解微分问题</h1><h2 id="2-1-emsp-幂函数的导数"><a href="#2-1-emsp-幂函数的导数" class="headerlink" title="2.1 &emsp; 幂函数的导数"></a>2.1 &emsp; 幂函数的导数</h2><p>事实上，当 $a$ 是任意实数时，</p><script type="math/tex; mode=display">\frac{\mathrm{d}}{\mathrm{d}x}(x^a)=ax^{a-1}</script><p>特殊地，如果 $C$ 是常数，那么 $\dfrac{\mathrm{d}}{\mathrm{d}x}(C)=0$。</p><p>如果 $a=1$，有 $\dfrac{\mathrm{d}}{\mathrm{d}x}(x)=1$。</p><p><strong>例子</strong> &emsp; $\dfrac{\mathrm{d}}{\mathrm{d}x}(x^\frac{1}{3})=\dfrac{1}{3}x^{-\frac{2}{3}}$。</p><h2 id="2-2-emsp-求导法则"><a href="#2-2-emsp-求导法则" class="headerlink" title="2.2 &emsp; 求导法则"></a>2.2 &emsp; 求导法则</h2><p>下面内容默认 $f’(x)$ 为函数 $f(x)$ 的导数，$a$ 为任意实数。</p><h3 id="2-2-1-emsp-函数的常数倍"><a href="#2-2-1-emsp-函数的常数倍" class="headerlink" title="2.2.1 &emsp; 函数的常数倍"></a>2.2.1 &emsp; 函数的常数倍</h3><p>若 $k$ 为任意实数，$f(x)=kx^a$，其导数为</p><script type="math/tex; mode=display">f'(x)=kax^{a-1}</script><h3 id="2-2-2-emsp-函数的和与差"><a href="#2-2-2-emsp-函数的和与差" class="headerlink" title="2.2.2 &emsp; 函数的和与差"></a>2.2.2 &emsp; 函数的和与差</h3><p>若 $f(x)=g(x)\pm h(x)$，其导数为</p><script type="math/tex; mode=display">f'(x)=g'(x)\pm h'(x)</script><h3 id="2-2-3-emsp-乘积法则"><a href="#2-2-3-emsp-乘积法则" class="headerlink" title="2.2.3 &emsp; 乘积法则"></a>2.2.3 &emsp; 乘积法则</h3><p><strong>乘积法则</strong> &emsp; 若 $h(x)=f(x)g(x)$，则其导数为</p><script type="math/tex; mode=display">h'(x)=f'(x)g(x)+f(x)g'(x)</script><p>用微分的形式表示，若 $y=uv$，则</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}y}{\mathrm{d}x}=v\dfrac{\mathrm{d}u}{\mathrm{d}x}+u\dfrac{\mathrm{d}v}{\mathrm{d}x}</script><p>乘积法则可推广。若 $y=uvw$，则</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}y}{\mathrm{d}x}=\dfrac{\mathrm{d}u}{\mathrm{d}x}vw+u\dfrac{\mathrm{d}v}{\mathrm{d}x}w+uv\dfrac{\mathrm{d}w}{\mathrm{d}x}</script><h3 id="2-2-4-emsp-商法则"><a href="#2-2-4-emsp-商法则" class="headerlink" title="2.2.4 &emsp; 商法则"></a>2.2.4 &emsp; 商法则</h3><p><strong>商法则</strong> &emsp; 若函数 $h(x)=\dfrac{f(x)}{g(x)}$，则其导数为</p><script type="math/tex; mode=display">h'(x)=\dfrac{f'(x)g(x)-f(x)g'(x)}{(g(x))^2}</script><p>用微分的形式表示，若 $y=\dfrac uv$，则</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}y}{\mathrm{d}x}=\dfrac{v\dfrac{\mathrm{d}u}{\mathrm{d}x}-u\dfrac{\mathrm{d}v}{\mathrm{d}x}}{v^2}</script><h3 id="2-2-5-emsp-链式求导法则"><a href="#2-2-5-emsp-链式求导法则" class="headerlink" title="2.2.5 &emsp; 链式求导法则"></a>2.2.5 &emsp; 链式求导法则</h3><p><strong>链式求导法则</strong> &emsp; 若函数 $h(x)=f(g(x))$，则其导数为</p><script type="math/tex; mode=display">h'(x)=f'(g(x))g'(x)</script><p>用微分的形式表示，若 $y$ 是 $u$ 的函数，$u$ 是 $x$ 的函数，则</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}y}{\mathrm{d}x}=\dfrac{\mathrm{d}y}{\mathrm{d}u}\dfrac{\mathrm{d}u}{\mathrm{d}x}</script><p>链式求导法则可以推广，若 $y$ 是 $u$ 的函数，$u$ 是 $v$ 的函数，$v$ 是 $x$ 的函数，则</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}y}{\mathrm{d}x}=\dfrac{\mathrm{d}y}{\mathrm{d}u}\dfrac{\mathrm{d}u}{\mathrm{d}v}\dfrac{\mathrm{d}v}{\mathrm{d}x}</script>]]></content>
      
      
      <categories>
          
          <category> 微积分学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>做题笔记[AGC002]</title>
      <link href="/2023/11/04/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%5BAGC002%5D/"/>
      <url>/2023/11/04/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%5BAGC002%5D/</url>
      
        <content type="html"><![CDATA[<p>做题笔记[AGC002]</p><h1 id="A-Range-Product"><a href="#A-Range-Product" class="headerlink" title="A - Range Product"></a>A - Range Product</h1><blockquote><p>标签：数学</p><p>难度：★☆☆☆☆</p></blockquote><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你两个整数 $a$ 和 $b$ ($a≤b$)。</p><p>判断 $\prod\limits_{i=a}^b i$ 是正、负还是零。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>$-10^9\le a\le b\le 10^9$。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>判断正负性，经过 $0$ 的乘积为 $0$，再判断负数个数即可。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;=<span class="number">0</span>&amp;&amp;b&gt;=<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;Zero&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a&gt;<span class="number">0</span>||(b-a+<span class="number">1</span>)%<span class="number">2</span>==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;Positive&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Negative&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Box-and-Ball"><a href="#B-Box-and-Ball" class="headerlink" title="B - Box and Ball"></a>B - Box and Ball</h1><blockquote><p>标签：思维</p><p>难度：★★☆☆☆</p></blockquote><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>我们有$N$个盒子，一开始，$1$ 号盒子里有一个红球，其他每个盒子里都有一个白球。</p><p>逐一执行给定的 $M$ 操作。在第 $i$ 次操作中，他会从 $x_i$ 盒子中随机选取一个球，然后将其放入 $y_i$ 盒子中。</p><p>求所有操作完成后，可能装有红球的盒子数。</p><h2 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h2><p>$2\le N,M\le 10^5,1\le x_i,y_i\le N$。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>判断 $1$ 号球可能到达的位置，每次移动将 $y$ 盒子打上“可能”的标记，如果 $x$ 盒子空了，就撤销 $x$ 的“可能”标记即可。</p><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="type">int</span> n,m,sz[MAXN];</span><br><span class="line"><span class="type">bool</span> f[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sz[i]=<span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x,y,i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        sz[x]--;</span><br><span class="line">        sz[y]++;</span><br><span class="line">        f[y]|=f[x];</span><br><span class="line">        <span class="keyword">if</span>(!sz[x]) f[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans+=f[i];</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Knot-Puzzle"><a href="#C-Knot-Puzzle" class="headerlink" title="C -  Knot Puzzle"></a>C -  Knot Puzzle</h1><blockquote><p>标签：贪心、构造</p><p>难度：★★★☆☆</p></blockquote><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>我们有 $N$ 根绳子，第 $i$ 段的长度是 $a_i$。起初，每条和相邻的绳子打上结，形成一条有 $N-1$ 个结的长绳。尝试通过重复执行以下操作来解开所有绳结：</p><ul><li>选择一条总长度至少为 $L$ 的（相连）绳子，然后解开其中一个绳结。</li></ul><p>通过正确的操作是否可以解开所有的 $N-1$ 个绳结？如果答案是肯定的，请找出一种可能的解结顺序。</p><h2 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h2><p>$2\le N\le 10^5,1\le L,a_i\le 10^9$。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>考虑贪心。如果全部能解开，则最后解开的那一对相邻的绳子长度一定大于等于 $L$。我们找到这对绳子，从两边开始解开所有的绳子。</p><p>如果没有这样一对相邻的绳子，则判断无解。</p><h2 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="type">int</span> n,len,a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;len;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]+a[i<span class="number">-1</span>]&gt;=a[s]+a[s<span class="number">-1</span>]) s=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[s]+a[s<span class="number">-1</span>]&lt;len)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Possible&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s<span class="number">-1</span>;i++) cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=s;i--) cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;s<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Stamp-Rally"><a href="#D-Stamp-Rally" class="headerlink" title="D - Stamp Rally"></a>D - Stamp Rally</h1><blockquote><p>标签：图论、kruskal 重构树</p><p>难度：★★★★☆</p></blockquote><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>有一个 $N$ 个顶点和 $M$ 条边的无向连通图。一共有 $Q$ 此询问，每次询问给定两个点 $x,y$，要求是同这两个点开始走，一共走 $z$ 个点，最小化所经过的边的权值最大值。</p><h2 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h2><p>$3\le N,Q\le 10^5,N−1\le M\le 10^5,1\le a_i&lt;b_i\le N$。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为要最小化路径最大权值，想到构建最小生成树，这样能保证连通图的最大边权最小。</p><p>因为要从两个顶点开始，一共走 $z$ 条边，考虑构建 kruskal 重构树，利用其<strong>一条路径的最大边权在两点的 LCA 位置处</strong>的性质，找到 $x,y$ 的最近公共祖先，再判断 $z$ 是否满足即可。</p><p>判断 $z$ 是否满足，只需要再重构树上往祖先走的时候判断子树叶子节点个数即可。可利用倍增加速。时间复杂度 $O(Q\log n)$。</p><h2 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="type">int</span> n,m,dsu[MAXN],w[MAXN],f[MAXN][<span class="number">30</span>],tot,root,lim,dep[MAXN],sz[MAXN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">&#125;edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.z&lt;y.z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dsu[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> dsu[x]=<span class="built_in">find</span>(dsu[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>]=fa;</span><br><span class="line">    dep[u]=dep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(g[u].<span class="built_in">size</span>()==<span class="number">1</span>) sz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=lim;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[f[x][i]]&lt;=c) x=f[x][i];</span><br><span class="line">        <span class="keyword">if</span>(w[f[y][i]]&lt;=c) y=f[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> sz[x];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> sz[x]+sz[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;edge[i].x&gt;&gt;edge[i].y;</span><br><span class="line">        edge[i].z=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edge+<span class="number">1</span>,edge+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++) dsu[i]=i;</span><br><span class="line">    tot=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>,i=<span class="number">1</span>;t&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=edge[i].x,y=edge[i].y;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(x)!=<span class="built_in">find</span>(y))&#123;</span><br><span class="line">            t++,tot++;</span><br><span class="line">            g[<span class="built_in">find</span>(x)].<span class="built_in">push_back</span>(tot);</span><br><span class="line">            g[tot].<span class="built_in">push_back</span>(<span class="built_in">find</span>(x));</span><br><span class="line">            g[<span class="built_in">find</span>(y)].<span class="built_in">push_back</span>(tot);</span><br><span class="line">            g[tot].<span class="built_in">push_back</span>(<span class="built_in">find</span>(y));</span><br><span class="line">            w[tot]=edge[i].z;</span><br><span class="line">            dsu[<span class="built_in">find</span>(x)]=tot;</span><br><span class="line">            dsu[<span class="built_in">find</span>(y)]=tot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root=tot;</span><br><span class="line">    <span class="built_in">dfs</span>(root,<span class="number">0</span>);</span><br><span class="line">    lim=<span class="built_in">log2</span>(n*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=lim;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)&#123;</span><br><span class="line">            f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> Q;</span><br><span class="line">    cin&gt;&gt;Q;</span><br><span class="line">    w[<span class="number">0</span>]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=m;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(x,y,mid)&gt;=z) r=mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-Candy-Piles"><a href="#E-Candy-Piles" class="headerlink" title="E - Candy Piles"></a>E - Candy Piles</h1><blockquote><p>标签：博弈论、思维</p><p>难度：★★★★★</p></blockquote><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p>桌子上有 $N$ 堆糖果，第 $i$ 堆里有 $a_i$ 颗糖果。</p><p>两个人轮流玩游戏，在每个回合中，当前玩家必须执行以下两个操作中的一个：</p><ol><li>选择剩余糖果数量最多的一堆，然后吃掉这一堆中的所有糖果。</li><li>从每堆糖果中吃掉一颗或多颗糖果。</li></ol><p>吃掉桌上最后一颗糖果的玩家输掉游戏。如果双方都以最佳方式玩游戏，请确定哪一方会获胜。</p><h2 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1\le N\le 10^5,1\le a_i\le 10^9$。</p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>很巧妙的人类智慧题！</p><p>我们考虑将这个棋局表示为一个二维平面，第 $i$ 列表示第 $i$ 堆糖果，每列从下到上有 $j$ 个添上的格子，表示第 $i$ 堆糖果有 $j$ 个。如下图：左图表示拿走最多的一堆（操作 1），右图表示每堆拿走一颗（操作 2）。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=2b5yyZIi" alt=""></p><p>实际上，我们将问题转化成了：每次从左或下消除一列或一行，直到无法消去。问谁会赢。</p><p>将消去一列操作视为向右走一格，消去一行操作视为向上走一格，可以表示成下图。双方交替进行，红色表示先手，蓝色表示后手。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=22cFH3sJ" alt=""></p><p>可以看到，只要走到边界，就会失败，所以给边界上的点一个“必败”的标记，考虑其他的点：</p><ul><li>如果这个点上方或右方有必胜点，则此点必胜（对于先手而言，下同）；</li><li>否则此点必败。</li></ul><p>如下图所示，红点为必败点，蓝点为必胜点。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=yRKKGDNu" alt=""></p><p>不难发发现，<strong>一个点和其右上方的点属性相同</strong>。利用这个性质，我们可以从起点一直向右上方走，直到不能走，判断这个点的胜负性。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=cIGm5e6V" alt=""></p><p>发现，对于靠近边界，不能向右上方走的点，如果其上方或右方能延伸的格子数有一个为奇数，则为必胜点，否则先手必败。</p><h2 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="type">int</span> n,a[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="type">int</span> p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[p+<span class="number">1</span>]&gt;=p+<span class="number">1</span>) p++;</span><br><span class="line">    <span class="type">int</span> p1=<span class="number">0</span>,p2=a[p]-p;</span><br><span class="line">    <span class="keyword">while</span>(a[p+p1+<span class="number">1</span>]&gt;=p) p1++;</span><br><span class="line">    <span class="keyword">if</span>((p1|p2)&amp;<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;First&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Second&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-Leftmost-Ball"><a href="#F-Leftmost-Ball" class="headerlink" title="F - Leftmost Ball"></a>F - Leftmost Ball</h1><blockquote><p>标签：组合数学、动态规划</p><p>难度：★★★★★</p></blockquote><h2 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h2><p>一共有 $N×K$ 个球，每种他喜欢的 $N$ 种颜色有$K$个。他会把所有的球从左到右任意排成一排。然后，对于每种颜色的球，他都会把最左边的那个颜色的球涂成 $0$ 号颜色（一种不同于 $N$ 种原始颜色的颜色）。</p><p>求涂色后，球的颜色可能有多少个序列（取模）。</p><h2 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1\le N,K\le 000$。</p><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>组合问题考虑动态规划。我们设状态 $f_{i,j}$ 表示我们放置了 $i$ 个白球和 $j$ 个<strong>类</strong>颜色的球，显然 $i\ge j$。考虑转移：</p><ul><li>若当前位置放一个白球，则有转移方程：</li></ul><script type="math/tex; mode=display">f_{i-1,j} \to f_{i,j}</script><ul><li>若当前位置放一个有颜色的球。根据定义，我们一次安排一类 $k-1$ 个同颜色的球的位置，那么这个位置是一个<strong>没有出现过的颜色的球</strong>。因为是从 $f_{i,j-1}$ 转移过来，所以这个球的颜色有 $n-j+1$ 种。当前位置放一个，前面有一个此颜色转换成的白球，后面此种颜色共安排 $k-2$ 个，则可以安排在后面 $nk-i-(j-i)(k-1)-1$ 个空位种的 $k-2$ 个位置，则有转移方程：</li></ul><script type="math/tex; mode=display">f_{i,j-1}\times (n-j+1)\times {nk-i-(j-1)(k-1)-1\choose k-2}\to f_{i,j}</script><p>边界：$f_{0,0}=1$，答案：$f_{n,n}$。</p><p>时间复杂度 $O(nk)$。</p><h2 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 2005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll f[MAXN][MAXN],mul[MAXN*MAXN],inv[MAXN*MAXN];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) w=w*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;<span class="number">0</span>||n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> mul[n]*inv[m]%mod*inv[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mul[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k*n;i++) mul[i]=mul[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[n*k]=<span class="built_in">qpow</span>(mul[n*k],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k*n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) inv[i]=inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=j) f[i][j]+=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j) f[i][j]+=f[i][j<span class="number">-1</span>]*(n-j+<span class="number">1</span>)%mod*<span class="built_in">C</span>(n*k-i-(j<span class="number">-1</span>)*(k<span class="number">-1</span>)<span class="number">-1</span>,k<span class="number">-2</span>)%mod;</span><br><span class="line">            f[i][j]%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 做题笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>做题笔记[AGC001]</title>
      <link href="/2023/10/27/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%5BAGC001%5D/"/>
      <url>/2023/10/27/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%5BAGC001%5D/</url>
      
        <content type="html"><![CDATA[<p>做题笔记[AGC001]</p><h1 id="A-BBQ-Easy"><a href="#A-BBQ-Easy" class="headerlink" title="A - BBQ Easy"></a>A - BBQ Easy</h1><blockquote><p>标签：贪心</p><p>难度：★☆☆☆☆</p></blockquote><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>将 $2n$ 个数分为 $n$ 组，每个数有值 $L_i$，每组两个数，每个数都被且只被分到一组。一组的权值是两个数值的最小值，分组方案的值就是每组值之和，求分组方案的最大值。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1\le n\le 100,1\le L_i\le 100$。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>考虑贪心。将数组排序后按顺序两两分组即可。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 205</span></span><br><span class="line"><span class="type">int</span> n,a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    n*=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i+=<span class="number">2</span>) ans+=a[i];</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Mysterious-Light"><a href="#B-Mysterious-Light" class="headerlink" title="B - Mysterious Light"></a>B - Mysterious Light</h1><blockquote><p>标签：思维</p><p>难度：★★★☆☆</p></blockquote><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>有一个边长为 $N$ 的三枚镜子构成的正三角形，顶点为 $A, B, C$。有一束光线，放在 $AB$ 段的 $P$ 点上，使得 $AP=X$。这个步枪将会沿着平行于 $BC$ 的方向发射一道光。</p><p>光以直线传播，以镜子的形式反射，也会被自己的轨迹反射，当光回到初始点的时候，光被吸收。</p><p>下面的图显示了当 $N=5, x=2$ 时的光轨迹。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=2CMCJl5q" alt=""></p><p>给定 $N$ 和 $x$，求出光线的总长度。</p><h2 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h2><p>$2≤N≤10^{12}$，$1≤x≤N-1$。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>把这个三角形看成被对角线分割的正方形，手动模拟长度，可以发现每一段的长度是一个辗转相减的过程，最后剩下的那一段就是 $(N,x)$。可以得到答案就是 $3(N-(N,x))$。</p><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n,x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    cout&lt;&lt;<span class="number">3ll</span>*(n-__gcd(x,n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Shorten-Diameter"><a href="#C-Shorten-Diameter" class="headerlink" title="C - Shorten Diameter"></a>C - Shorten Diameter</h1><blockquote><p>标签：树论、枚举</p><p>难度：★★☆☆☆</p></blockquote><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一棵 $N$ 个点的无向树，定义点 $u$ 和 $v$ 之间的距离是从 $u$ 到 $v$ 的简单路径上的边数。</p><p>你需要删除一些点，使树的直径小于等于 $K$，当且仅当删除某点不会对树的联通性产生影响时才可以删除。</p><p>问至少删除多少点才可以满足要求。</p><h2 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h2><p>$2≤N≤2000$，$1≤K≤N-1$。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为 $N$ 比较小，我们考虑枚举每个点，计算以这个点为中心时，最少删去多少个点才能满足要求，具体地：</p><ul><li>若 $N$ 为偶数，我们设这个点为中心，遍历整张图，删去距离这个点超过 $k/2$ 的点。</li><li>若 $N$ 为奇数，我们设这个点连接的某一条边为中心（枚举），遍历整张图，删去距离这个点超过 $\lfloor k/2 \rfloor$。</li></ul><p>时间复杂度 $O(n^2)$。</p><h2 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 2005</span></span><br><span class="line"><span class="type">int</span> n,k,cnt,ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> dis)</span></span>&#123;</span><br><span class="line">    cnt+=(dis&gt;k/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u,dis+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x,y,i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">                cnt=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(v,u,<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">dfs</span>(u,v,<span class="number">0</span>);</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v,u,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Arrays-and-Palindrome"><a href="#D-Arrays-and-Palindrome" class="headerlink" title="D - Arrays and Palindrome"></a>D - Arrays and Palindrome</h1><blockquote><p>标签：构造、回文串</p><p>难度：★★★★☆</p></blockquote><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个长 $m$ 的序列 $A$，和参数 $n=\sum\limits_{i=1}^m A_i$，构造两个正整数数列 $a,b$，满足：</p><ul><li>$a$ 数列的数字总和是 $N$ 且是 $A$ 序列的一个排列；</li><li>$b$ 数列的数字总和是 $N$；</li><li>如果存在某个数列 $s$ 满足以下两个条件， 则 $s$ 的所有元素必定相同：<ul><li>对于 $s$ 的最开始的 $a_1$ 个元素，接下来的 $a_2$ 个元素，更后面的 $a_3$ 个，等等，都构成回文串；</li><li>对于 $s$ 的最开始的 $b_1$ 个元素，接下来的 $b_2$ 个元素，更后面的 $b_3$ 个，等等，都构成回文串。</li></ul></li></ul><h2 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1\le N,A_i\le 10^5,1\le M\le 100$。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>一道很好的构造题。</p><p>考虑构成一个长度为 $n$ 的回文串，会有 $n/2$ 个相等关系。而让所有元素相等，必须交叉安排两个数组，使得串首尾都留出一个接口，如下图：</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=Dm0o2AWB" alt=""></p><p>不难发现，如果 $A$ 中有大于两个长度为奇数的串，就无法满足制约关系。对于合法的解，不妨将长度为奇数的串转到两边，然后让 $b$ 数组差 $a$ 的空子安排就好。</p><h2 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="type">int</span> n,m,a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        cnt+=(a[i]&amp;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="keyword">if</span>(a[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>) <span class="built_in">swap</span>(a[i],a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;<span class="number">1</span>;i--) <span class="keyword">if</span>(a[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=m) <span class="built_in">swap</span>(a[i],a[m]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="number">1</span>) cout&lt;&lt;<span class="number">2</span>&lt;&lt;endl&lt;&lt;a[<span class="number">1</span>]<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">1</span>]==<span class="number">1</span>) cout&lt;&lt;m<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;a[<span class="number">1</span>]<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;m;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;a[m]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-BBQ-Hard"><a href="#E-BBQ-Hard" class="headerlink" title="E - BBQ Hard"></a>E - BBQ Hard</h1><blockquote><p>标签：组合计数、动态规划</p><p>难度：★★★★☆</p></blockquote><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p>有 $n$ 个数对 $(a_i, b_i)$，求</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\sum_{j=i + 1}^{n}{a_i+b_i+a_j+b_j \choose a_i+a_j}</script><p>答案对 $10 ^ 9 + 7$ 取模。</p><h2 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h2><p>$2\le N\le 2\times 10^5,1\le A_i,B_i\le 2000$。</p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先考虑一个组合式 $x+y\choose x$ 的几何意义，就是从点 $(0,0)$ 走到 $(x,y)$，每一步只能向右或向上走的方案数。这个式子是可以转移的：</p><script type="math/tex; mode=display">{x+y\choose x }={x+y-1\choose x}+{x+y\choose x-1}</script><p>单独求一次可以在 $O(A_iB_i)$ 的时间求出来。现在考虑题目中的式子，也就是说对于每个 $1\le i&lt;j\le n$，求从 $(0,0)$ 按照上述方案走到 $(a_i+a_j,b_i+b_j)$ 的方案数。</p><p>为了简化思考，我们现在改变一下表述方式：对于每个 $1\le i&lt;j\le n$，求从 $(-a_j,-b_j)$ 走到 $(a_i,b_i)$，即向左下平移，但是大小不变。我们以 $(a_i,a_j)$ 为主元，求解其他点（负的）到这个点的方案和即可。</p><p>我们考虑动态规划。开始给每个负点 $(-a_i,-b_i)$ $1$ 的权值，设计 $f_{i,j}$ 表示从左下角走到这个点的方案数，求解即可。</p><p>注意上述状态求解了所有的 $i,j$ 的解，我们需要删去 $i,i$ 的解，通过组合计数可得这部分要删去的解的个数是 $\sum\limits_{i=1}^n{2a_i+2b_2\choose2a_i}$。因为 $i,j$ 和 $j,i$ 算重，需要将答案数除以 $2$。</p><h2 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXA 2005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll f[MAXA&lt;&lt;<span class="number">1</span>][MAXA&lt;&lt;<span class="number">1</span>],n,a[MAXN],b[MAXN];</span><br><span class="line">ll maxa,maxb,ans;</span><br><span class="line">ll mul[MAXA&lt;&lt;<span class="number">2</span>],inv[MAXA&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mul[n]*inv[m]%mod*inv[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) w=w*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mul[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4009</span>*<span class="number">2</span>;i++) mul[i]=mul[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[<span class="number">4009</span>*<span class="number">2</span>]=<span class="built_in">qpow</span>(mul[<span class="number">4009</span>*<span class="number">2</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4009</span>*<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) inv[i]=inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">        f[<span class="number">2005</span>-a[i]][<span class="number">2005</span>-b[i]]++;</span><br><span class="line">        maxa=<span class="built_in">max</span>(maxa,a[i]);</span><br><span class="line">        maxb=<span class="built_in">max</span>(maxb,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2005</span>-maxa;i&lt;=<span class="number">2005</span>+maxa;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2005</span>-maxb;j&lt;=<span class="number">2005</span>+maxb;j++)&#123;</span><br><span class="line">            f[i][j]=(f[i][j]+f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=(ans+f[<span class="number">2005</span>+a[i]][<span class="number">2005</span>+b[i]])%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=(ans-<span class="built_in">C</span>((a[i]+b[i])&lt;&lt;<span class="number">1</span>,a[i]&lt;&lt;<span class="number">1</span>))%mod;</span><br><span class="line">    ans=<span class="number">1ll</span>*ans*inv[<span class="number">2</span>]%mod;</span><br><span class="line">    ans=(ans%mod+mod)%mod;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-Wide-Swap"><a href="#F-Wide-Swap" class="headerlink" title="F - Wide Swap"></a>F - Wide Swap</h1><blockquote><p>标签：思维、拓扑排序、线段树</p><p>难度：★★★★★</p></blockquote><h2 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一个元素集合为 $\{1,2,\dots,N\}$ 的排列 $P$，当有 $i,j$ $(1\leq i&lt;j\leq N)$ 满足 $j-i\geq K$ $(1\leq K\leq N-1)$ 且 $|P_{i}-P_{j}|=1$时，可以交换 $P_{i}$ 和 $P_{j}$。</p><p>求：可能排列中字典序最小的排列。</p><h2 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1\leq N\leq 5\times10^5$ 。</p><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>考虑按照上述方式交换元素有什么特殊性质。</p><p>我们建立 $P$ 的反置换 $Q$，即 $P_{Q_i}=i$，将 $P_i$ 的值作为 $Q$ 的下标，$i$ 作为 $Q$ 的值。不难发现，可以交换 $Q_i$ 和 $Q_{i+1}$ 的条件是 $|Q_i-Q_{i+1}|\le K$。</p><p>通过人类的智慧思考发现，若存在一组 $1\le i<j\le N$，满足 $|Q_i-Q_j|>K$，不管怎样交换，这两个数的<strong>相对位置不会改变</strong>。</p><p>这个性质放回到 $P$ 中，等价于：$\forall 1\le i \le N,j\in(i-K,i+k),i\not=j$，若 $P_i$ 和 $P_j$ 满足偏序关系 $P_i&lt;P_j$，则无论怎样交换，最后在 $i,j$ 位置上的数仍满足偏序关系 $P_i&lt;P_j$。</p><blockquote><p>例子 $\quad$ 对于排列 $P=\{4,5,7,8,3,1,2,6\}$，有 $P_2=5,P_3=7$，在 $K=3$ 的情况下，无论怎样交换，两个位置上的数仍满足小于关系。例如交换成 $P’=\{1,2,6,7,5,3,4,8\}$，满足 $2&lt;6$。</p></blockquote><p>这样，我们可以找出所有的偏序关系，建图后通过拓扑排序，就可以知道这些数的最小排列。</p><p>例如，我们按照大于关系见图，即找到下标 $(i-K,i+K)$ 内比 $P_i$ 小的数连边，按照拓扑顺序给下标从 $N$ 到 $1$ 赋值。</p><p>但是这个图是 $O(NK)$ 大小的，无法建图，我们利用这道题的特殊性质：每个点可能连出边的节点范围是 $(i-K,i+K)$。一开始没有入度的点就是这个范围内的最大值，可以利用线段树查找。然后在左右子区间找区间最大值，再检查是否合法即可（见代码）。</p><p>时间复杂度 $O(N\log N)$。</p><h2 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((tree[p].l+tree[p].r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (p&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (p&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">int</span> n,k,a[MAXN],ans[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,maxx,pos;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[ls].maxx&gt;tree[rs].maxx)&#123;</span><br><span class="line">        tree[p].maxx=tree[ls].maxx;</span><br><span class="line">        tree[p].pos=tree[ls].pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tree[p].maxx=tree[rs].maxx;</span><br><span class="line">        tree[p].pos=tree[rs].pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].l=l,tree[p].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[p].maxx=a[l];</span><br><span class="line">        tree[p].pos=l;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,ls);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pii <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> &#123;-inf,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r) <span class="keyword">return</span> &#123;tree[p].maxx,tree[p].pos&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(l,r,rs);</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(l,r,ls);</span><br><span class="line">    pii lc=<span class="built_in">query</span>(l,r,ls),rc=<span class="built_in">query</span>(l,r,rs),c;</span><br><span class="line">    <span class="keyword">if</span>(lc.first&gt;rc.first) c=lc;</span><br><span class="line">    <span class="keyword">else</span> c=rc;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> goal,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].l==tree[p].r)&#123;</span><br><span class="line">        tree[p].maxx=-inf;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(goal&lt;=mid) <span class="built_in">modify</span>(goal,ls);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(goal,rs);</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chk</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    pii now=<span class="built_in">query</span>(<span class="built_in">max</span>(<span class="number">1</span>,p-k+<span class="number">1</span>),<span class="built_in">min</span>(p+k<span class="number">-1</span>,n),<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(now.second==p&amp;&amp;now.first!=-inf) q.<span class="built_in">push</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">chk</span>(i);</span><br><span class="line">    <span class="type">int</span> now=n;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        ans[u]=now--;</span><br><span class="line">        <span class="built_in">modify</span>(u,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> lpos=<span class="built_in">query</span>(<span class="built_in">max</span>(<span class="number">1</span>,u-k+<span class="number">1</span>),u<span class="number">-1</span>,<span class="number">1</span>).second;</span><br><span class="line">        <span class="type">int</span> rpos=<span class="built_in">query</span>(u+<span class="number">1</span>,<span class="built_in">min</span>(u+k<span class="number">-1</span>,n),<span class="number">1</span>).second;</span><br><span class="line">        <span class="built_in">chk</span>(lpos);<span class="built_in">chk</span>(rpos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 做题笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟退火</title>
      <link href="/2023/10/27/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"/>
      <url>/2023/10/27/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/</url>
      
        <content type="html"><![CDATA[<p>模拟退火</p><h1 id="一、模拟退火"><a href="#一、模拟退火" class="headerlink" title="一、模拟退火"></a>一、模拟退火</h1><p>模拟退火算法用于计算运算量大或随机概率较高的多峰函数最值问题，在多次退火下，正确的概率表现的还是非常出色的。</p><h2 id="1-1-quad-劣解的接受与-Metropolis-准则"><a href="#1-1-quad-劣解的接受与-Metropolis-准则" class="headerlink" title="1.1  $\quad$ 劣解的接受与 Metropolis 准则"></a>1.1  $\quad$ 劣解的接受与 Metropolis 准则</h2><p>爬山算法只能应用于单峰函数，因为它每次只在附近只寻找更加优秀的解。放在多峰函数下容易陷入局部最大值，而无法找到全局最大值。</p><p>不同于爬山算法，在模拟退火算法中，我们在当前位置的一定范围内随机一个位置进行决策。如果这个决策比现在的决策更加优秀，我们无条件地接受；如果这个决策不如当前的决策我们以<strong>某种概率接受</strong>这个劣解。</p><p>具体地，我们像冶金工业退火一样，一开始，我们有一个<strong>温度</strong> $T$，表示当前的活跃性。这个温度随着随机次数的增加而降低，当最终小于某一个温度 $t_0$ 时就终止退火。</p><p>我们设接受一个比当前解劣 $\Delta E$ 的劣解的概率为 $P(\Delta E)$。根据 Metropolis 准则，我们划定这个概率，并让其与当前温度有关。即表示：随机次数较小时，我们有更大概率接受劣解；随机次数过多时，我们有较小的概率接受劣解。这样既能保证向着最大值的方向查找，又能避免陷入局部最大值。</p><p><strong>Metropolis 准则</strong> $\quad$ 当前温度为 $T$ 时，对于新状态 $S’$ 与当前最优状态 $S$ 的关于最优值的差为 $\Delta E\ge 0$，则发生状态转移（接受新状态）的概率为：</p><script type="math/tex; mode=display">P(\Delta E)=\begin{cases}1,&S'\text{比} S \text{更优,} \\e^{\frac{-\Delta E}{T}}, & \text{otherwise.}\end{cases}</script><p><img src="https://oi-wiki.org/misc/images/simulated-annealing.gif" alt=""></p><h2 id="1-2-quad-算法的实现"><a href="#1-2-quad-算法的实现" class="headerlink" title="1.2 $\quad$ 算法的实现"></a>1.2 $\quad$ 算法的实现</h2><p>一开始，我们有三个参数：</p><ul><li>初始温度 $T_0$；</li><li>降温系数 $d$，即每经过依次随机，温度变为 $T_0d$，$d$ 一般为趋近于 $1$ 的小数；</li><li>终止温度 $T_k$。</li></ul><p>对于每次随机，我们在当前最优解的附近随机新状态（随机范围也与当前温度有关），经计算后依靠 Metropolis 准则决定是否接受。</p><p>在依靠 Metropolis 准则决策时需要注意：</p><ul><li>在 C++ 语言中，我们可以用 <code>cmath</code> 库中的 <code>exp</code> 函数计算以 $e$ 为底的指数函数。具体地，可以用 <code>exp(-E/T)</code> 表示 $e^{\frac{-\Delta E}{T}}$；</li><li>注意计算接受劣解的概率时 $e$ 的指数是<strong>负数</strong>；</li><li>根据函数图像可知，对于函数 $f(x)=e^x(x<0)$ 的值域是 $(0,1)$。所以我们可以将 $e^{\frac{-\Delta E}{T}}$ 与一个在 $(0,1)$ 范围内的随机数比较。需要注意的是，因为随机次数越多，$T$ 越小，$\frac{-\Delta E}{T}$ 也越小，$f(x)$ 的函数值也越趋近于 $0$，接受的概率也应该越低。所以，**无论求最大值还是最小值，都只能依靠 `exp(-E/T) >= randFromRange(0,1)<code>或其他单调判断**来决策，**注意不等号方向和随机值范围，否则有概率退化成爬山算法**。其中</code>randFromRange` 函数是在 $(l,r)$ 范围内生成随机数。</li></ul><p>一般利用模拟退火解决问题，通常有如下设置：</p><ul><li>$T_0$ 一般取 $[2000,3000]$ 中的数；</li><li>$d$ 通常取 $0.999$，这个值取决于不同题目；</li><li>$T_k$ 通常取 $[10^{-16},10^{-5}]$ 之间；</li><li>通常情况下会进行多轮退火。每轮结束后不必要清空最优值，只需要重置温度等参数即可。</li></ul><h1 id="二、例题练习"><a href="#二、例题练习" class="headerlink" title="二、例题练习"></a>二、例题练习</h1><h2 id="2-1-quad-分金币"><a href="#2-1-quad-分金币" class="headerlink" title="2.1 $\quad$ 分金币"></a>2.1 $\quad$ 分金币</h2><p>题目来源：<a href="https://www.luogu.com.cn/problem/P3878">TJOI2010，洛谷P3878</a></p><blockquote><p><strong>例题</strong> $\quad$ 现在有 $n$ 枚金币，第 $i$ 枚金币的价值为 $v_i$。现在要把它们分成两部分，要求这两部分金币数目之差不超过 $1$，求这样分成的两部分金币的价值之差的最小值。</p></blockquote><p>考虑模拟退火，先把原序列随便分成两个部分，之后随机交换两个部分中的两个数。</p><p>核心代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> temp=<span class="number">2333</span>;<span class="comment">//初始温度</span></span><br><span class="line">    <span class="keyword">while</span>(temp&gt;=<span class="number">1e-15</span>)&#123;<span class="comment">//终止温度</span></span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">rnd</span>()%mid+<span class="number">1</span>;<span class="comment">//在两个部分随机一个数交换</span></span><br><span class="line">        <span class="type">int</span> y=<span class="built_in">rnd</span>()%(n-mid)+mid+<span class="number">1</span>;</span><br><span class="line">        ll dis=<span class="built_in">abs</span>(s1-a[x]+a[y]-(s2-a[y]+a[x]));<span class="comment">//计算新贡献</span></span><br><span class="line">        ll D=dis-ans;</span><br><span class="line">        <span class="keyword">if</span>(D&lt;<span class="number">0</span>)&#123;<span class="comment">//优解，注意D和上文定义的E是相反数，D是负数表示的是解较优</span></span><br><span class="line">            ans=dis;</span><br><span class="line">            s1=s1-a[x]+a[y];</span><br><span class="line">            s2=s2-a[y]+a[x];</span><br><span class="line">            <span class="built_in">swap</span>(a[x],a[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span>(D/temp)&gt;<span class="number">1.</span>*(<span class="built_in">rnd</span>()%<span class="number">100000</span>)/<span class="number">100000</span>)&#123;<span class="comment">//劣解，注意随机范围和不等号方向</span></span><br><span class="line">            s1=s1-a[x]+a[y];</span><br><span class="line">            s2=s2-a[y]+a[x];</span><br><span class="line">            <span class="built_in">swap</span>(a[x],a[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        temp*=<span class="number">0.999</span>;<span class="comment">//每次温度降低</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">        mid=(<span class="number">1</span>+n)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        s1=s2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=mid;i++) s1+=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>;i&lt;=n;i++) s2+=a[i];</span><br><span class="line">        ans=<span class="built_in">abs</span>(s1-s2);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++) <span class="built_in">sa</span>();<span class="comment">//多进行几轮退火</span></span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-quad-Run-Away"><a href="#2-2-quad-Run-Away" class="headerlink" title="2.2 $\quad$ Run Away"></a>2.2 $\quad$ Run Away</h2><p>题目来源：<a href="https://www.luogu.com.cn/problem/SP34">SP34</a></p><blockquote><p><strong>例题</strong> $\quad$ 给定 $n$ 个点的坐标，在给定范围内找一个点，使得距离所有点的最小值最大。</p></blockquote><p>考虑模拟退火，一开始将这个点的位置设置在范围的正中心。每次在一定范围内随机新点，范围与当前温度有关，见代码。</p><p>核心代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> temp=<span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp&gt;=<span class="number">1e-4</span>)&#123;</span><br><span class="line">        <span class="comment">//随机新点</span></span><br><span class="line">        <span class="type">double</span> nowx=<span class="built_in">getrnd</span>(<span class="built_in">max</span>(<span class="number">0.</span>,nx-temp),<span class="built_in">min</span>(<span class="number">1.</span>*X,nx+temp));</span><br><span class="line">        <span class="type">double</span> nowy=<span class="built_in">getrnd</span>(<span class="built_in">max</span>(<span class="number">0.</span>,ny-temp),<span class="built_in">min</span>(<span class="number">1.</span>*Y,ny+temp));</span><br><span class="line">        <span class="comment">//计算新值</span></span><br><span class="line">        <span class="type">double</span> dis=<span class="built_in">calc</span>(nowx,nowy);</span><br><span class="line">        <span class="type">double</span> D=dis-ans;</span><br><span class="line">        <span class="comment">//方案较优</span></span><br><span class="line">        <span class="keyword">if</span>(D&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ans=dis;</span><br><span class="line">            ansx=nx=nowx;</span><br><span class="line">            ansy=ny=nowy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以一定概率接受劣解，注意不等号方向</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span>(D/temp)&gt;=<span class="built_in">getrnd</span>(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">            nx=nowx;</span><br><span class="line">            ny=nowy;</span><br><span class="line">        &#125;</span><br><span class="line">        temp*=<span class="number">0.999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;X&gt;&gt;Y&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;ax[i]&gt;&gt;ay[i];</span><br><span class="line">        ansx=nx=<span class="number">1.</span>*X/<span class="number">2</span>;</span><br><span class="line">        ansy=ny=<span class="number">1.</span>*Y/<span class="number">2</span>;</span><br><span class="line">        ans=<span class="built_in">calc</span>(nx,ny);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++) <span class="built_in">sa</span>();<span class="comment">//多进行几次退火</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The safest point is (%.1lf, %.1lf).\n&quot;</span>,ansx,ansy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随机化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渐近记号与主定理</title>
      <link href="/2023/10/27/%E6%B8%90%E8%BF%9B%E8%AE%B0%E5%8F%B7%E4%B8%8E%E4%B8%BB%E5%AE%9A%E7%90%86/"/>
      <url>/2023/10/27/%E6%B8%90%E8%BF%9B%E8%AE%B0%E5%8F%B7%E4%B8%8E%E4%B8%BB%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>渐近记号与主定理</p><p>渐近记号用来描述函数的运行时间，刻画运行时间的上界、确界、下界。使用递归定义的函数通常使用主定理分析时间复杂度。</p><h1 id="一、渐近记号"><a href="#一、渐近记号" class="headerlink" title="一、渐近记号"></a>一、渐近记号</h1><p>本节定义一些基本函数，用于描述时间复杂度。</p><h2 id="1-1-quad-渐进记号、函数与运行时间"><a href="#1-1-quad-渐进记号、函数与运行时间" class="headerlink" title="1.1 $\quad$ 渐进记号、函数与运行时间"></a>1.1 $\quad$ 渐进记号、函数与运行时间</h2><h3 id="1-1-1-quad-Theta-记号"><a href="#1-1-1-quad-Theta-记号" class="headerlink" title="1.1.1 $\quad$ $\Theta$ 记号"></a>1.1.1 $\quad$ $\Theta$ 记号</h3><p>我们使用 $\Theta$ 记号描述函数的<strong>渐近紧确界</strong>。</p><p>形式化地， $\Theta (g(n))=\{f(n):\exists c_1,c_2,n_0:\forall n\ge n_0,0\le c_1g(n)\le f(n)\le c_2g(n) \}$。</p><p>其中，冒号意为“使得”。</p><p>也就是说，存在常量 $c_1,c_2,n_0$，可以将 $f(n)$ 夹入 $c_1g(n)$ 和 $c_2(n)$ 中。$\Theta(g(n))$ 要求每个成员 $f(n)\in \Theta(g(n))$ <strong>渐近非负</strong>。</p><p>我们通常使用 $\Theta(1)$ 表示常量或某个变量的常量函数。</p><h3 id="1-1-2-quad-O-记号"><a href="#1-1-2-quad-O-记号" class="headerlink" title="1.1.2 $\quad$ $O$ 记号"></a>1.1.2 $\quad$ $O$ 记号</h3><p>当函数只有一个<strong>渐近上界</strong>时，使用 $O$ 记号。</p><p>形式化地， $O (g(n))=\{f(n):\exists c,n_0:\forall n\ge n_0,0\le f(n)\le cg(n) \}$。</p><p>使用 $O$ 记号描述上界，我们常常可以检查算法的总体结构来描述算法运行的时间，如循环嵌套等，这里不再展开。</p><h3 id="1-1-3-quad-Omega-记号"><a href="#1-1-3-quad-Omega-记号" class="headerlink" title="1.1.3 $\quad$ $\Omega$ 记号"></a>1.1.3 $\quad$ $\Omega$ 记号</h3><p>$\Omega$ 记号提供了函数的<strong>渐近下界</strong>。</p><p>形式化地，$\Omega (g(n))=\{f(n):\exists c,n_0:\forall n\ge n_0,0\le cg(n)\le f(n)\}$。</p><p>我们不难有如下定理：</p><p><strong>定理</strong> $\quad$ 对于任意两个函数 $f(n),g(n)$，我们有 $f(n)=\Theta(g(n))$，当且仅当 $f(n)=O(g(n))$ 且 $f(n)=\Omega(g(n))$。</p><h3 id="1-1-4-quad-o-记号"><a href="#1-1-4-quad-o-记号" class="headerlink" title="1.1.4 $\quad$ $o$ 记号"></a>1.1.4 $\quad$ $o$ 记号</h3><p>前面的 $O$ 记号描述的渐近上界，我们使用 $o$ 记号来描述一个<strong>非渐近紧确的上界</strong>，如 $2n=o(n^2)$ 而 $2n^2\not=o(n^2)$。</p><p>形式化地，$o (g(n))=\{f(n):\forall c&gt;0,\exists n_0&gt;0:\forall n\ge n_0, 0\le f(n) &lt; cg(n) \}$。</p><p>直观上，在 $o$ 记号中，当 $n\rightarrow + \infty$，函数$f(n)$ 相对于 $g(n)$ 来说变得微不足道了。</p><h3 id="1-1-5-quad-omega-记号"><a href="#1-1-5-quad-omega-记号" class="headerlink" title="1.1.5 $\quad$ $\omega$ 记号"></a>1.1.5 $\quad$ $\omega$ 记号</h3><p>我们使用 $\omega$ 记号描述一个<strong>非渐近紧确的下界</strong>。</p><p>形式化地，$\omega (g(n))=\{f(n):\forall c&gt;0,\exists n_0&gt;0:\forall n\ge n_0, 0\le cg(n) &lt; f(n) \}$。</p><h2 id="1-2-quad-渐近函数的性质"><a href="#1-2-quad-渐近函数的性质" class="headerlink" title="1.2 $\quad$ 渐近函数的性质"></a>1.2 $\quad$ 渐近函数的性质</h2><p>我们令 $f(n),g(n)$ 渐近为正。</p><p>渐近函数具有<strong>传递性</strong>，即 $f(n)=\Theta (g(n)),g(n)=\Theta h(n)\Rightarrow f(n)=\Theta(h(n))$。其他记号同理。</p><p>渐近函数具有<strong>自反性</strong>，即 $f(n)=\Theta f(n)$，对于 $O,\Omega$ 记号同理。</p><p>$\Theta$ 函数具有<strong>对称性</strong>，即 $f(n)=\Theta(g(n))$ 当且仅当 $g(n)=\Theta (f(n))$。</p><p>渐近函数具有<strong>转置对称性</strong>，即 $f(n)=O(g(n))$ 当且仅当 $g(n)=\Omega f(n)$；$f(n)=o(g(n))$ 当且仅当 $g(n)=\omega (f(n))$。</p><h1 id="二、使用主方法求解递归式"><a href="#二、使用主方法求解递归式" class="headerlink" title="二、使用主方法求解递归式"></a>二、使用主方法求解递归式</h1><p>对于类似</p><script type="math/tex; mode=display">T(n)=aT(n/b)+f(n)</script><p>的递归式，通常使用主定理求解其渐近界。</p><h2 id="2-1-quad-主定理"><a href="#2-1-quad-主定理" class="headerlink" title="2.1 $\quad$ 主定理"></a>2.1 $\quad$ 主定理</h2><p><strong>定理（主定理）</strong> $\quad$ 令 $a\ge 1$ 和 $b\ge 1$ 是常数，$f(n)$ 是一个函数，$T(n)$ 是定义在非负整数上的递归式：</p><script type="math/tex; mode=display">T(n)=aT(n/b)+f(n)</script><p>我们将其中的 $n/b$ 解释为 $\lceil n/b \rceil$ 或者 $\lfloor n/b \rfloor$，那么 $T(n)$ 有如下渐近界：</p><ol><li>若对某个常数 $\epsilon &gt;0$ 有 $f(n)=O(n^{\log_b a-\epsilon})$，则有 $T(n)=\Theta(n^{\log_ba})$。</li><li>若 $f(n)=\Theta(n^{\log_b a})$，则 $T(n)=\Theta(n^{\log_b a}\lg n)$。</li><li>若对某个常数 $\epsilon&gt;0$ 有 $f(n)=\Omega(n^{\log_b a+\epsilon})$，且对某个常数 $c&lt;1$ 和所有足够大的 $n$ 有 $af(n/b)\le cf(n)$，则 $T(n)=\Theta(f(n))$。</li></ol><p>上面就是主定理。注意这三种情况并未覆盖 $f(n)$ 的所有可能性，下面将说明如何正确地使用主定理。</p><h2 id="2-2-quad-使用主方法"><a href="#2-2-quad-使用主方法" class="headerlink" title="2.2 $\quad$ 使用主方法"></a>2.2 $\quad$ 使用主方法</h2><p>我们把使用主定理求解递归式的方法称为<strong>主方法</strong>。我们只需要确定一个递归式对于主定理的哪种情况成立，即可得到解。</p><blockquote><p> <strong>例子</strong> $\quad$ 对于下面的递归式，求解其渐近界。</p><script type="math/tex; mode=display">T(n)=9T(n/3)+n</script></blockquote><p>对于这个递归式，我们有 $a=9,b=3,f(n)=n$，因此 $n^{\log b a}=b^{\log_3 9}=\Theta(n^2)$。由于 $f(n)=O(n^{\log_39-\epsilon})$，其中 $\epsilon=1$，因此可以应用于情况1，得到 $T(n)=\Theta(n^2)$。</p><blockquote><p><strong>例子</strong> $\quad$ 对于下面的递归式，求解其渐近界。</p><script type="math/tex; mode=display">T(n)=T(2n/3)+1</script></blockquote><p>其中，$a=1,b=\frac{2}{3},f(n)=1$，因此 $n^{\log_b a}=n^0=1$。由于 $f(n)=\Theta(n^{\log _b a})=\Theta(1)$，应用于情况2，得到 $T(n)=\Theta(\lg n)$。</p><blockquote><p><strong>例子</strong> $\quad$ 对于下面的递归式，求解其渐近界。</p><script type="math/tex; mode=display">T(n)=3T(n/4)+n\lg n</script></blockquote><p>其中，$a=3,b=4,f(n)=n\lg n$，因此 $n^{\log_b a}=O(n^{0.793})$。由于 $f(n)=\Omega(b^{\log_4 3-\epsilon})$，其中 $\epsilon\approx 0.2$，因此，如果可以证明正则条件成立，可应用于情况3。当 $n$ 足够大时，有 $af(n/b)\le cf(n)$，得到 $T(n)=\Theta(n\lg n)$。</p><p>上面给出了三种例子，只要算出 $n^{\log_b a}$ 的渐近界，与 $f(n)$ 比较，就可以求出递归式的渐近界。</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组与应用</title>
      <link href="/2023/10/13/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2023/10/13/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>后缀数组与应用</p><p>后缀数组 (Suffix Array) 是处理字符串问题的有力工具之一，通常利用后缀数组 $sa$ 处理字符串子串与后缀串排序、公共前缀等问题。</p><h1 id="一、后缀数组"><a href="#一、后缀数组" class="headerlink" title="一、后缀数组"></a>一、后缀数组</h1><p>通过计算后缀数组与排名数组，辅助解决系列问题。</p><h2 id="1-1-quad-约定与定义"><a href="#1-1-quad-约定与定义" class="headerlink" title="1.1 $\quad$ 约定与定义"></a>1.1 $\quad$ 约定与定义</h2><p>对于一个长度为 $n$ 的字符串 $s$，我们定义 $s_i\dots s_n$ 构成的子串为 $s$ 在 $i$ 位置上的<strong>后缀</strong>，下面给出几个函数的定义：</p><ul><li><p>$sa_i$：<strong>后缀数组</strong>。表示 $s$ 的所有后缀串中，按字典序排名，第 $i$ 小的后缀串的起始位置。</p></li><li><p>$rk_i$：<strong>名次数组</strong>。表示起始位置为 $i$ 的后缀串的排名（按字典序）。</p></li></ul><p>不难发现，上面两个函数<strong>互为反函数</strong>，即：</p><script type="math/tex; mode=display">\begin{aligned}sa[rk[i]]=i\\rk[sa[i]]=i\end{aligned}</script><ul><li>$height_i$：<strong>高度数组</strong>。表示排名为 $i$ 的后缀串与排名为 $i-1$ 的后缀串的最长公共前缀。特殊地，$height_1=0$，因为没有比它排名小的后缀串。形式化地：</li></ul><script type="math/tex; mode=display">ht[i]=\text{LCP}(sa[i],sa[i-1])</script><p>其中，$\text{LCP}(s,t)$ 表示字符串 $s,t$ 的最长公共前缀。</p><ul><li>$h_i$：<strong>公共前缀数组</strong>。表示起始位置为 $i$ 的后缀串，与比其排名小 $1$ 的后缀串的最长公共前缀，即：</li></ul><script type="math/tex; mode=display">h[i]=height[rk[i]]</script><blockquote><p><strong>例子</strong> $\quad$ 给定字符串 $s=aabaaaab$，其后缀数组、名次数组、高度数组、公共前缀数组为别为：</p><script type="math/tex; mode=display">\begin{array}{}&1&2&3&4&5&6&7&8\\s:&a&a&b&a&a&a&a&b\\sa:&4&5&6&1&7&2&8&3\\rk:&4&6&8&1&2&3&5&7\\height:&0&3&2&3&1&2&0&1\\h:&3&2&1&0&3&2&1&0\end{array}</script></blockquote><h2 id="1-2-quad-后缀数组的计算"><a href="#1-2-quad-后缀数组的计算" class="headerlink" title="1.2 $\quad$ 后缀数组的计算"></a>1.2 $\quad$ 后缀数组的计算</h2><p><strong>前置芝士：倍增法、基数排序。</strong></p><p>我们有暴力的做法，对所有后缀串排序，但是这个复杂度并不优秀。</p><p>我们考虑<strong>倍增地</strong>计算后缀数组。也就是说，每次我们计算一段长形如 $[i,i+2^k-1]$ 的子串，而后合并前后两个子串，并按照两个子串的各自的关键字进行排序合并。下面我们考虑怎样合并两个已经排好序的更小的子串，使其拼成一个更长的、有序的子串，进而贡献给后缀数组。如下图：</p><p><img src="https://oi-wiki.org/string/images/sa2.png" alt=""></p><p>这张图中，我们进行了 $O(\log n)$ 次倍增。第一次，我们就以字典序为前后两个关键字合并。其后，我们分别以前面一段的名次、后面一段的名次，为两个关键字进行合并。我们每一次合并需要对 $n$ 个数的两个关键字排序，直接使用快速排序可以获得 $O(n\log^2 n)$ 的复杂度。一定程度上可以接受，但是不是很优秀，我们希望消去一个 $\log$ 的复杂度。</p><p>考虑使用基数排序替换快速排序，每次先对第二关键字开桶记录，而后对第一关键字开桶记录。这样我们放入第一关键字桶的顺序已经满足排序顺序，换句话说，已经满足第二关键字递增的顺序。</p><p>时间复杂度 $O(n\log n)$。</p><h2 id="1-3-quad-代码实现"><a href="#1-3-quad-代码实现" class="headerlink" title="1.3 $\quad$ 代码实现"></a>1.3 $\quad$ 代码实现</h2><p>定义以下变量：</p><ul><li>$m$：桶中最大元素，即桶的上限；</li><li>$c_i$：数组为计数桶。</li><li>$x_i$：起始位置为 $i$ 的串的第一关键字；</li><li>$y_i$：第二关键字排名为 $i$ 的串的起始位置，即 $x$ 的位置。</li></ul><p>下面描述算法流程。</p><ol><li><p>对于第一次递增，我们直接按照每单个字符排序，将每个长度为 $1$ 的串的第一关键字放入桶中。</p></li><li><p>然后对桶 $c$ 进行前缀和处理，这样我们确定了第一关键字为 $k$ 的元素最大排在第几名。</p></li><li><p>我们对后缀数组进行第一次赋值，表示长度为 $1$ 的后缀串排名第 $i$ 的串的起始位置为 $sa_i$。这里注意需要倒序枚举 $i$，因为我们只划定了排序名次的上界。确切的名次需要由上界依次递减得到。</p></li><li><p>而后我们进行更多次的倍增，处理长度为 $k$ 的串。考虑到如果合并两个串时，第一个串的起始位置 $i\ge n-k+1$，我们第二个串就是空串，需要提前处理。而且这些串合并后，排名一定比第二个串非空的靠前。下面的 $num$ 表示第二关键字排名。注意 $y$ 数组保存的是对应的第一关键字的位置。</p></li><li><p>而后我们对于所有可能的第二串加入 $y$ 数组。只有 $sa[i]&gt; k$ 时才可行（短于倍增长度无法找到第一串）。</p></li><li><p>仿照第一次倍增的思路处理第一关键字桶。</p></li><li><p>基数排序，因为 $y$ 的顺序是按照第二关键字的顺序来排的，第二关键字靠后的，在同一个第一关键字桶中排名越靠后。</p></li><li><p>清空第一关键字数组，并根据当前值重新赋关键字。注意到此时我们直接按后缀数组赋值即可，本身有序。更新桶上限 $m$。</p></li></ol><p>完整代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Suffix_Array</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;(s+<span class="number">1</span>);                                                       <span class="comment">//Step.1</span></span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    m=<span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++) c[i]+=c[i<span class="number">-1</span>];                               <span class="comment">//Step.2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--) sa[c[x[i]]--]=i;                               <span class="comment">//Step.3</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k&lt;&lt;=<span class="number">1</span>)&#123;                                          <span class="comment">//Step.4</span></span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n-k+<span class="number">1</span>;i&lt;=n;i++) y[++num]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(sa[i]&gt;k) y[++num]=sa[i]-k;           <span class="comment">//Step.5</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) c[i]=<span class="number">0</span>;                                 <span class="comment">//Step.6</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[x[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--) sa[c[x[y[i]]]--]=y[i];                     <span class="comment">//Step.7</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lstx[i]=x[i],x[i]=<span class="number">0</span>;                    <span class="comment">//Step.8</span></span><br><span class="line">        num=<span class="number">1</span>;</span><br><span class="line">        x[sa[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lstx[sa[i]]==lstx[sa[i<span class="number">-1</span>]]&amp;&amp;lstx[sa[i]+k]==lstx[sa[i<span class="number">-1</span>]+k]) x[sa[i]]=num;</span><br><span class="line">            <span class="keyword">else</span> x[sa[i]]=++num;</span><br><span class="line">        &#125;</span><br><span class="line">        m=num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、子串最长公共前缀"><a href="#二、子串最长公共前缀" class="headerlink" title="二、子串最长公共前缀"></a>二、子串最长公共前缀</h1><p>我们记 $\text{LCP}(i,j)$ 表示字符串排名为 $i$ 的后缀串，和排名为 $j$ 的后缀串的最长公共前缀，根据性质计算。</p><h2 id="2-1-quad-基本性质"><a href="#2-1-quad-基本性质" class="headerlink" title="2.1 $\quad$ 基本性质"></a>2.1 $\quad$ 基本性质</h2><p><strong>性质 1</strong> $\quad$ $\text{LCP}(i,j)=\text{LCP}(j,i)$。</p><p><strong>性质 2</strong> $\quad$ $\text{LCP}(i,i)=\text{len}(sa[i])=n-sa[i]+1$。其中，$\text{len(i)}$ 表示起始位置为 $i$ 的后缀串的长度。</p><p>上面两个性质显然。</p><p><strong>性质 3</strong> $\quad$ $\forall 1\le i\le j\le k\le n\ ,\ \text{LCP}(i,k)=\min(\text{LCP}(i,j),\text{LCP}(j,k))$ 。</p><p>因为是按照后缀排序的，所以易证。</p><p>进而得出，按照后缀排完序的后缀串，两个后缀串的最长公共前缀就等于 $height_{i+1}\cdots height_j$ 取最小值。<br><strong>性质 4</strong> $\quad$ $\forall 1&lt;i\le j\le k\le n\ ,\ \text{LCP}(i,k)=\min(\text{LCP}(j,j-1))$。</p><p><strong>性质 5</strong> $\quad$ $h_i\ge h_{i-1}-1$，这是<strong>关键性质</strong>。</p><p>考虑粗略证明性质5。令第 $i-1$ 位为字符 $s$，则 $i-1$ 位置的后缀为 $sX$，$i$ 位置的后缀为 $X$。</p><p>我们找到后缀排名在 $sX$ 前一名的后缀，即 $sa[rk[i-1]-1]$，记 $k$ 为这个排名。这两个后缀的最长公共前缀就是 $height[rk[i-1]]$。分成两类情况讨论：</p><ul><li>如果第 $k$ 个串和第 $i-1$ 个串第一个字符不同，即没有公共前缀，即 $height[rk[i-1]]=0$，一定有 $height[rk[i]]\ge height[rk[i-1]]+1$，即 $h[i]\ge h_[i-1]-1$。</li><li>如果第 $k$ 个串和第 $i-1$ 个串第一个字符相同，可以表示第 $k$ 个串为 $sY$。一定有 $sY&lt;sX\Rightarrow Y&lt;X$。那么第 $k+1$ 个字符串要排名在 $i$ 前面。那么第 $k+1$ 个字符串和 $i$ 的最长公共前缀就是 $height[rk[i-1]]-1$。根据性质4可得 $h[i]\ge h[i-1]=1$。</li></ul><h2 id="2-2-quad-后缀排序最长公共前缀的计算"><a href="#2-2-quad-后缀排序最长公共前缀的计算" class="headerlink" title="2.2 $\quad$ 后缀排序最长公共前缀的计算"></a>2.2 $\quad$ 后缀排序最长公共前缀的计算</h2><p>我们利用性质5计算后置排序后的 $height$ 数组和 $h$ 数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getheight</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) rnk[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rnk[i]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(j) j--;</span><br><span class="line">        <span class="keyword">while</span>(i+j&lt;=n&amp;&amp;sa[rnk[i]<span class="number">-1</span>]+j&lt;=n&amp;&amp;s[i+j]==s[sa[rnk[i]<span class="number">-1</span>]+j]) j++;</span><br><span class="line">        heigh[rnk[i]]=j;                  <span class="comment">//h[i]=height[rnk[i]]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ramsey 定理</title>
      <link href="/2023/10/13/Ramsey%20%E5%AE%9A%E7%90%86/"/>
      <url>/2023/10/13/Ramsey%20%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Ramsey 定理</p><h1 id="一、Ramsey-定理"><a href="#一、Ramsey-定理" class="headerlink" title="一、Ramsey 定理"></a>一、Ramsey 定理</h1><p>Ramsey 定理是关于鸽巢原理的重要拓展，甚至可以从另一个维度解释鸽巢原理。</p><h2 id="1-1-quad-基本定义"><a href="#1-1-quad-基本定义" class="headerlink" title="1.1 $\quad$ 基本定义"></a>1.1 $\quad$ 基本定义</h2><p>我们先给出一些定义。</p><p>对于由 $n$ 个点构成的图，两两节点直接都有边直接相连，则成这张图是<strong>完全图</strong>。</p><p>我们把 $p$ 个点的完全图，记作 $K_p$。</p><p>我们用两种颜色对所有边进行染色，染色成 $a$ 或者 $b$，如果下面两个条件至少满足其一：</p><ol><li>存在 $n$ 个点的子集，使其构成的完全图中所有边的颜色为同一种颜色 $a$；</li><li>存在 $m$ 个点的子集，使其构成的完全图中所有边的颜色为同一种颜色 $b$。</li></ol><p>我们记作</p><script type="math/tex; mode=display">K_p\rightarrow K_m,K_n</script><p>我们记 Ramsey 数 $r(n,m)$ 是使 $K_p\rightarrow K_n,K_m$ 的最小正整数 $p$。我们不难发现</p><script type="math/tex; mode=display">r(n,m)=r(m,n)</script><blockquote><p><strong>例子</strong> $\quad$ 在 $6$ 个人构成的集合中，要么 $3$ 个人互相认识，要么 $3$ 个人互相不认识。</p></blockquote><p>我们给出这个例子的证明。</p><p>我们对于 $6$ 个点的完全图，两个人间互相认识则边染红色，否则边染蓝色。考虑图中的任意一个点 $p$，与其相连的 $5$ 条边中，至少有 $3$ 条边颜色相同（根据鸽巢原理可得）。因为情况对称，我们令染红色的边数至少为 $3$，那我们举出这三条边连接的三个点 $a,b,c$，分类考虑以下情况：</p><ul><li>如果由 $a,b,c$ 三个点构成的完全图中所有边都是蓝色，那么这三个点构成一个蓝 $K_3$。</li><li>如果由 $a,b,c$ 三个点构成的完全图中有一个边是红色，那么这条红边连接的两个点，和点 $p$ 构成一个红 $K_3$。</li></ul><p>则红 $K_3$ 和蓝 $K_3$ 两个至少有一个成立。即证明了这个结论。</p><h2 id="1-2-quad-基本的-Ramsey-定理"><a href="#1-2-quad-基本的-Ramsey-定理" class="headerlink" title="1.2 $\quad$ 基本的 Ramsey 定理"></a>1.2 $\quad$ 基本的 Ramsey 定理</h2><p>下面给出更广泛的定理和证明。</p><p><strong>定理</strong> $\quad$ $\forall n,m\ge 2,\exists p\in \mathbb{N}_+$，使得</p><script type="math/tex; mode=display">K_p\rightarrow K_m,K_n</script><p><strong>证明</strong> $\quad$ 我们很容易确定 $r(2,n)$ 和 $r(n,2)$ 的值。下面证明 $r(2,n)=r(n,2)=n$。</p><ul><li>确定 $r(2,n)\leq n$：如果所有边都是同一种颜色，则 $K_n$ 成立；否则 $K_2$ 成立。</li><li>确定$r(2,n)&gt;n-1$：如果有一个红 $K_{n-1}$，我们并不能得到蓝 $K_2$ 或者红 $K_n$。</li></ul><p>下面用归纳法证明广泛结论。</p><p>假设 $m,n\ge 3$ ，归纳假设为 $r(m-1,n)$ 和 $r(m,n-1)$ 存在。设 $p=r(m-1,n)+r(m,n-1)$，下面证明 $K_p\rightarrow K_m,K_n$ 存在。</p><p>假设 $K_p$ 已经通过某种方式完成红色和蓝色的染色，我们对其中的一个节点 $x$，记 $B_x,R_x$ 分别为通过蓝色边和红色边在图中与 $x$ 相连的点的集合。有</p><script type="math/tex; mode=display">|R_x|+|B_x|=p-1=r(m-1,n)+r(n,m-1)-1</script><p>也就是说，以下两个条件至少有一个成立：</p><ol><li>$|R_x|\ge r(m-1,n)$；</li><li>$|B_x|\ge r(m,n-1)$。</li></ol><p>可以通过鸽巢原理说明这一点，因为如果两个都不成立，则 $|R_x|+|B_x|\le r(m+1,n)+r(m,n-1)-1=p-2$，矛盾。</p><p>我们假设条件1成立，也就是 $|R_x|\ge r(m-1,n)$，说明下面两个条件至少有一个成立：</p><ul><li>可能存在一个红 $K_{m-1}$，这个图的节点就是 $R_x$ 中的节点。如果我们将 $x$ 加入这个图，因为与 $x$ 相连的边为红色，就可以得到一个 $K_m$，完成证明；</li><li>可能存在一个蓝 $K_n$，这时我们直接完成了证明。</li></ul><p>所以此时结论成立。同理，若条件2成立，则结论也一定成立。</p><p><strong>证毕</strong>。</p><p>上面的证明不仅证明了 Ramsey 数的存在，也给出了不等式</p><script type="math/tex; mode=display">r(m,n)\le r(m-1,n)+r(m,n-1)\quad (m,n\ge 3)</script><p>设函数</p><script type="math/tex; mode=display">f(m,n)=\dbinom{m+n-2}{m-1}\quad (m,n\ge 2)</script><p>得到</p><script type="math/tex; mode=display">f(m,n)=\dbinom{m+n-3}{m-1}+\dbinom{m+n-3}{m-2}=f(m-1,n)+f(m,n-1)</script><p>这是一个等式。因为 $r(2,n)=n=f(2,n)\ ,\ r(m,2)=m=f(m,2)$，所得 Ramsey 数满足</p><script type="math/tex; mode=display">r(m,n)\le \dbinom{m+n-2}{m-1}=\dbinom{m+n-2}{n-1}</script><h2 id="1-3-quad-Ramsey-定理的推广"><a href="#1-3-quad-Ramsey-定理的推广" class="headerlink" title="1.3 $\quad$ Ramsey 定理的推广"></a>1.3 $\quad$ Ramsey 定理的推广</h2><p>上面我们将一个完全图每条边染成了 $2$ 种颜色，我们将其扩展，对一个点数为 $n$ 的完全图，用 $k$ 种颜色染色。如果 $n_1,n_2,\cdots,n_k\ge 2$，则存在 $p$ 使得：</p><script type="math/tex; mode=display">K_p\rightarrow K_{n_1},K_{n_2}\cdots,K_{n_k}</script><p>使得该结论成立的最小整数 $p$ 称为 Ramsey 数 $r(n_1,n_2,\cdots ,n_k)$。</p><p>如果我们把点对（两个元素的子集）扩展成 $t$ 个元素的子集，令 $K_n^t$ 表示 $n$ 元素集合种所有 $t$ 个元素的子集的集合，扩展 Ramsey 定理。</p><p>给定整数 $t\ge 2$ 和整数 $q_1,q_2,\cdots ,q_k\ge t$，存在整数 $p$，使得</p><script type="math/tex; mode=display">K_p^t\rightarrow K_{p_1}^t,K_{p_2}^t,\cdots,K_{p_k}^t</script><p>满足结论的最小整数 $p$ 称为 Ramsey 数 $r(q_1,q_2,\cdots,q_k)$。</p><p>$q_1,q_2,\cdots,q_k$ 的排列并不影响 Ramsey 数的表现。</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 《活着》</title>
      <link href="/2023/10/01/%E6%B4%BB%E7%9D%80/"/>
      <url>/2023/10/01/%E6%B4%BB%E7%9D%80/</url>
      
        <content type="html"><![CDATA[<p>活着</p><p>余华</p><p>2023.10.01 记</p><hr><p>面朝大海 春暖花开 ——读《活着》有感</p><p>自从买这本书时，就看到不止一条评论：余华老师为什么要写得这么惨？但纵观福贵一生，也许在他的眼中，面对生活的态度和我们有所不同吧！</p><p>福贵自富家出身，祖上几代也想兴盛家业，但因子女无能日益破败。青年富贵正是在肆意放纵中度过的，也因此亲手赌出了自己的家产。眼看着祖上的东西丢得一干二净，亲人相继离世，前途的微光愈加消散……</p><p>但在福贵眼里，命运似乎是注定的。他在经历次次打击后，却没有因此堕落，而是坦然地活下去。</p><p>他的一生是乐观的，活着就是为了“活着”本身。对比《骆驼祥子》中的祥子，开始十分努力，而后经历世事变迁，自己也慢慢沦落，活得已不成人形。和祥子活在几乎同一个历史背景的福贵，为什么并没有因家庭破碎、事业破败而选择“放弃活的意义”？就在于自身面对生活的态度。前者虽然努力，但仍以乐观的态度对待“天命”，却早已是“成功地活着”。</p><p>他的一生是宽容的，活着只为了更好地生活。他在极度饥荒时，面对向老丈人借来的为数不多的几粒米，不吝啬于借给队长一部分；面对儿子有庆不公平地以“借血”为由死去，他并不责怪春生。因为他知道，谁的生活都是艰难的，没有被逼无奈也不会出此下策。</p><p>所以，“惨”可能并不是为写而写，更多地，可能时一个无法改变天命的普通人的映射。正如作者在序中写的：</p><blockquote><p>  作家的使命不是发泄，不是控诉活着揭露。他应该向人们展示高尚。这里所说的高尚不是那种单纯的美好，而是对一切事物理解之后的超然、对善和恶的一视同仁，用同情的目光看待世界。</p></blockquote><p>尽管“惨”可能是人生的旋律，但一定不是人生的主题。它的主题应是“希望”。所以，人生遇挫之时，谨记“面朝大海，春暖花开”，而不是悲观地走向汪洋无望的深海——尽管不知以诗人的绝笔诗为题是否合适……</p><p>向死而生，有希望怎么都好。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『初丶晴』的模拟赛题解</title>
      <link href="/2023/09/29/%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
      <url>/2023/09/29/%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="欸? 这个『通行证』看着不太对, 再试试看呢..." data-whm="密码不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a513dcaa343746b0f1a5467ebb86072dcf8886cdeaf7aa57f109fa9f665dbab4">f6941bc60948d3ded0396f371d8df72c0c9411ed47a5b43ad41d15f89ded684584397cdc506c564723021ebd2fb577b3330e12a4d08bd8f515d05345066cf89b4b43666ddee674d7c513c6f2e85944ec844a2b2cb57f8d99d51a9361b7713a9097137632bc873cc2706f7474dfe38c98b21e7c87a124e83d2c467775ce6ad3cd80b3ef8a534235b2d774ecc965132eebea522b4d350ba0af99e115a2b3e6a61294dc6d3c02a129da800a8cdf96d25a61a79bbc54ae718af343143bbc66c833dae8cc7447bd3cf7e676c5997c0153d24b8a646adc5b426190ea13954a7619a1a93cfb6d0dd6c426ee24621a7c18004bf36747563f62f198eb5ced9231d98e58c02ffab1728d1e25ca60a05c1f994b0ec7fa6084cf83c77cea1584dd9b44ae89f5863ebf0b3acbb3899293b5847e65f570f50a5765727bff14689bca7f9c626e9ed19b8721e5c37978278171a29b5eebfb25837ff6181fda1ef1244dec60b4c0723a3c9df071739435e643bc3bcaeb29d9dc32fad55378cbf6391b02b2c0a361218268602cb50d6931805d111ba73494f7d873055ce6666ac4bca55a9489ed590ad07ba6d2bcfb52fd3bd627b59ccf48138651b4990a743060222547b487e974bb52d12602191b73c1f6a1cd3ff238bc7c9d39aa25c153ab09f5ad6c11a44b294f9d7fe97de1b95a9adb51dc5beccc1d05d47d2a45f656626d051089a6ee785f7553713e84f628f2486c1a3665e16c9d5a5cbd21209c41bf5521cb383b7ee6293dbb630de76054a75e65a33080a0177b311bc6015de823b121619f67ad744b2b791f24322513c903bdbe6d0a66bd58edb43bb57933d1e72805d094caf085544636528e0d4427727cae85f0da4f32f052e6f9ebafe3cbc613a2b57a44e64ba47c8bd18af855f159fe90cf836ba80ed628a46996a49c76c681859d0148e60e174295f58b7380f1bccfc3afefc2b9c6c1c1f7a66b400e7dfda88346fa64720dc6e285e680de886b039f9ab14fac3f18b96aca04515c68570643c87bc1ddaab57f64898d1bbcbc3bcffd6d575809b395b3b88235ea6b5f824b70c060bf7b5120ab7de4e7693039da3170e3c778b29ab6bfa073cda631408af99c99078fb9f460536345c2d6d9128020b408be3df9066c5500f87595a95997b059548b346f4d7f23341683a666ee29d89e42f901adf89a4eb92473acee17ab1948455d727ac5ea8d9a2c73ff6b8ea8ff59f5e9335d1af9ed1f5a9026af950d86aa5b45a7f3ccd769a934e42c26419721b91ed406f9a2757394a3cfd1d138349fb10e03f89166d2b391ed7e6bffc04c2184fb569725e70b65899634618a260ac90cd98f48486edf2a5a5b7bdcea0f40e15e6368cb86b13fe7c795e3cb9b081a4e24e95bb6aa4cad5879dcde70d3bfb77f7a7e40f2a03607eaba1123ec8f32388af009b8ce4e519297830577e1587abbe3b616c933d20976ab9e5fa789569060fabe46471eba08d48fe2100e12b929d1665620fcfabf832621aff477e983e4de8a0afed76a9d023ed94559f877f32f66237475f74195294df7db06740562b084b450e1669111580a031ef373ae96487290e96418a2751f932bbb204f00ab1cde23e03c875561e26b785bb529e33ba65ece8a43159c3b180abf05ec2e964b182e0855c2d8c1a44086c94718df902bc710577a05fd0a9cde0fe7d7458f25d78c16eed1bcc6cce6a230049a93cc95579f1004155845c5cacfc3775d95c3b525f19cfd37e9cc689d9539a7cf337fde0251a64b62accdee165356aa07a412d735a12e3d1bddb375eeaaf2ed1a3f8c50384f0f621fce9de25ea5d7f73aea58fc1c69a51f6146edc5b99a29e40a05fa0ed6587130469bca353715a07bbdd0756f6e6b8fa1e4841189bd0337e0a94dcda0e0f85e68af8040b0de21bbd987caf06bcee0d2dcecd201319531f310cb35bbdbd3289bbd2646abcc1b93ade16b62d87f523ba67215af11538d8a4a9eb945f584c22f0c6ffb5378c027982e57e60d951e3ce40ef794c3cd4597e64d7d684f051a9a3bdc997310d49859111e4e59355c8cfecca1812415e208e4007212133c940d3c4786c586efe73c7dee051e08a7e372ccdc8d0dbddd8f4ca8739b115c21026ae14081a135142b96aa25b9ffc956bad3ec38eb18c99c6cad910b360e88e550594c0a4fbe69b093c65a72412b4c90163d30e68158e6cf583fc5d6cd4a8ceeefae00940e1c83dab67eb66de5d90fc403861eedee8dbe0486c1667b4626255196443fed8f5db790572f73d7afd6bf6af407d5dbc01b72b9b29bb273f4ef83afaa0ba773550594d95b7a5031271f2e3e3fc1d70de015e66e9be634892dfbb838bd683de96234b905f4eb8e08d4d0ee7d10ea110d29a5d83448df5fa86005650df9eb94cb53a2a582a072c8c0bbc314e78ee8993585343d4d75efeddaec8d55f58f7f43c0602eb6cf23717c0d95a940adf4ecd3a5431af5990feab0191c1fb8c9a6950d7b01b31589a76c21d26d1e9bb9a20feb2ae8ad0256aecd58fc6f6a948a73ea83d76f17a28cd2a87b9809f5ce7af8d6e61c51e5a53264387bc57fcc7ef42c147a5af306cb59cf94610ac7c000c1b94a901e59cdb9e2645d7eeb6e4f3759cb0a9eb9997292ed23743b5bf0f4a3a0403f8e916753b215957594f6a36b7b4050e7a1824c946ba17b8580c9709d3c050fcd2c1ae296aa6641e90a2099410758ba73497cb60091ffb48b8e72263f79a04a558eb240b8a022fcdc5f965ef1e17a420c2b114b222c943331b13c06085aa11e055c3a1aebd973bd69c2b52b05ecc531b65b0cbd11c2d2776d13d0a232acfd884ba4885a1d1bf6cf717551c80bbe599c80a5610329ebbad60fef57bb419370e3a3b9ba62b3c763cb74454850416c02d0c932012cb68ef83d9e34264c96f46f470a6f0d8ab11463b33326045e9872f1c5f40f433d68bba801a06ea1419f6e1eb5cca1cbb3f7afdcbab253084a76a232ca167cc1128c7cbedcb672d73ac977ae6a7d7a816a72ebd0283b4c32bfa78ba478cc77dd2bd00021b01fcadea392935999ce3844d84c8b6f7b7c6d897887a57bf8dab0b530144a08ad5f670c5e35c983f4b03419dd18f073ac3b6fbb58c33050850805b53a32b9b6c8a30c184c1120fe631169e22881ea5b8d9f67b34d8ad0b084528b74b5c8194713a8cb5952505a110312c7ccc190fa09582ff4b626250eadacfb9068c7d2a28ccc943babc496a20a39bc714f56b3abe7701234e96a2c7570c70f8959ce262454a4ed8bf83f9e35332197d29b26b1d28ee100e983a7cc1afeb66eecdf199c102b08f8ae3516b88f0894ceda153360744dddd629c0daaaf8cd1aad59114c480052d512edae3faa22dbfc1ef13fe833a847177d5dba6c4571bab0c67656b74b9f644e11b1563dd80c5b867de11a04ea5a655d811f78d39dbf06557e1c18cafa39f29711432c43a0f9261a60f9743477e7cb28ed20588b354b26d614829894dbd9d7e3624c4afb3fef389110c9dad89d70ae7415a5201e6e5d1c7bde75be143cba0bd3a5d81597f8cd56ff3147c1365c8cc954a4473db494d88c31b29a2457dce549751670732768faf5d6a9f461b5a8b2d6d84452f12eb7d29afe96fe1a80ae589b8ac7488a8cec37263c525abc812706f32a515e692b954e78a7517af3acb6e7013e45a4ed72cf59fdb6db0ef8d5075ca77ed896b4fb4a1bca857af80dc255f809058be2c1cd880a4975b04faf0c64729f74f9613c402d53a231feb588aab71624e677a02f90498a585bc5aa660adfdf293d2f0d47c088a48e0866786bd7ef1082070116cd480e48eeb8fc8d43e5e7c35eee244522fe15fb608f520f91104f1b4e1225ff9710f3c7ec66c663932c30b58cfa3c9ed69cab37ff1aece1bee573cf7e9d11145a3e1dba7fa78498277b4aa18ed4579503d244d99ec846a51031ab168df7d3409a701e271b60240118b9b1c40ccb5ed4f53c582584e823921966b764da263b67d8b93669a70fcd1345a643b6fe5a7d315dc5686fa331f05658abbaa61cbe69d4bc538649787c58253dc652ab1e22245220996d1abf7077e80f875eabb464a2f9ea099c3a47adf0223237cb0cb0d25dce48cc9f0d3fde64ae5d64cde910e118b67ad36147dbc0618b1fe3f9786fb7e98f89fa5033640769b084318606203db6b6b37da272d39fda1b4b713622f56d222d118dcb99842e7fa7a53d7f52b71137eafa77ba40548b28b5100ee419ad87a29a6ca1a20186681d3864715e6fade97106522a14761a2978b687eb110de5f76b6d9c44bc5c334f96384707db4fcf7d89b82da68f1c1525f3ec4e902d7e3ef5c7d54fad71f8c633824be43e9ccaa76d50dc91de5235f6cd6159a77c9d8817d527262bc708f5e6eeb8845a4c082a365e4137f06f297a5b4242fe1a7b3235aaf99dcd5c4c0028514a20c89ffc86017e10e13498e563625db3460acb87fd8f716ea604d5bcc874ecc3d6a744e0d6287875d5dff7e7dfdf2ecafc494316c3e746ce600789c04eb009a429831460e96319ac44118346802f69ab32e1f44664624f5c1a5ab4b43e1809282a3bfeceb19f278f6efba604d60225be2a4d7fa5b6d08cba2ee4fd0a3463d7268bd9c7b2dc024f0272bb3181f5929a43a08b5749ba071bed027563ee8857e52424cef4e9862c3d33f9f18d217e8a4b62e5b3804d8ffa7dff11551a792a9cb049e7587e3d2d79fb7b4b26afacdb3c917e090febc5d68ad003a80c0e5a24271d6682e9547ffd9634f658ffd7c49ce70a2d70d2c0644c1ff508080d8b1c3aac8495385c1efa044ac4536be17c18fa926e2aca58b3dadba98863f8c4a24a9d9094f1303c5d33f9f788684b017c280303be94663ef6b2c572df969623ee1c6c5efce2a865045929f089c1818b164f6dde23fd8e0a7333dfc1f7da2c0f903dd8f3cd0997dfa6273b3716bfcad2a36957761662d7443eabbaa8363b8341e3bdd3e196a385160fb2f1d305704d55093a5f07ee1e777f68430f28aaf3a2cab88fa0f922b869f7c9aa7e229084e04eea5b3abf42d44b97cac657f13c8ce003964a564fc60b5db899328c3dd45e9969ee2aff565c86f02139b3b6f46dfe6b4628fd0a11054b9c0faa1d02f231318bcb05ec3edaf03768b5d34625040b527a2b769e44d1af89ae003e65f6dc54e3570bccb7c21b7fc6eebccc035c5458d502dee923d7944741b863694c0095e34f011cea853320ca6eb89a5caf888e9acc217ca77f4cd7018e62298b0e583b5b7a92a47edd8c68d9798ef3abe33f43af2fb4c9beb61223f5beb96bc14cbcec4a2988182ad3330f7744ef655449f5b8858ece4a11e3626af2bebb69997af592da94d2d0a59d3eaa6d4eb8b6b8828f7952b547305256697c25da0e18e59cb97b3c098426fddb5c4851e8da9fefd65fcd68170bd28b631c9e3ae4297140718dda72ff028dc1ed4553f1ce714287bbb8d4571bfa5bbf3c91c8bb72ead0514d91d47743114bcde19409300bb1d0fe40d968324f6f98f5f6d18657121549f3f6714753ccd70ebe5095979278fdddbc1b78d5ab1aa1712160bd57d7450b6397dadc105ace5bbee57a592fe9e109993c3d1fcfe6e130b570030e7b2e0776a6b6d9ec8ffe7e63d67bc585dee88763c256f5864f8fb8c1207bf0f607f5c933b243f6923b9d2212936210793764c8b90719f30b12f0f0911d6a143e8f4a261a087f690a7ef24c86fe48515ec04e27a173aa038bbce4a0af88da0605f406447865c7d7c31b0df3ac6c45e8191ba142b231f59c4496662d32c0cf52b4948c39f39e3a28d83d6d8e3ed72d20ecab867ec1f3b1197490405ccddb9058d8a0a8d38f937a19eb641c8cd45bae23a2e6ffa644ddd9f254f4476e2fb30b8b1d235ceb0d81c57894b52077b77d82d5e4de420abed450c1f4cd6e3492dcfb19f038c536519171357bbd74563c15523a2a15859f406df307fe853b310bfb9dde708a32d3e0f577795ecdf0323fc294d6e21276bf8ddbcb9960b1c934049a0dde8fa9b4a71ea222ec0d68607c6aabfd64c1a51a999fb25e9206e10f6ba2c5d0cf1db4741f9e53f63bf0b15508863968f83ace71dda14c0016e720c4bb12e335c84dd4d02a22771064260e2aa17c3125225f57ce0d397ce4da6719fd1b2b2884a6b8ec1394be8e4130f70f5d335bf481f871725f0a88b6af76546839a1bf00e3424906e36b1fed1538358dc0726d37f7f0ecbc7724a00174e6ddac82cfc2eceecad85eca7c52b78287330a66aadb859f1fd68c2bfbd5443e71b604ccd1b409bed3b1d2ec893365c56afb5cbf2c0403b8605ea5125b272ecbb6d4cc058e59a442f69ac5cb72189dacf5996a3de856444065e46b8d19b393c8cbeeaa714cdbeb7ed3c9e6f55a6b1dfe48ea55046023f0f34e6f711bc2a70812a9119cb850f5bf5ebf60b327280004252b0c05d83618fa74e2e4ad9dee3760573d1fd0e5d70ed6a923917167c925abc9d5bbb9e9aadf60f4df4617fe517d12e8b46149035f7ba84a3e83d9349528fe2852e84ae6d651cf82016ef7e620d64409ef426828d99fe69c8daf8bf78d49e8524955825490c8db25d504439d8520afcc145bdecca01f0400aab2a147f5189aa2ac0c943597a437fb21f82a07c8cc08d07b227348bd37e5335ece1938be813299f4c541215c6f7fab5dcaa029211adea68d76d1d64aea664baa83558bdded8977a4426a5e066b59a9d5129cb036c0277af12f5f548517b9b6ce27bd9773061425072a7af006204fcbfbe511b642016d2f8ef45ff14935c56bbe582458c7137e129c727c2ac942f6c2f66413c5ef26bbfb3c3019bd8dc9e76baf3cc6c70bc0a84e9550e78a2bd15de286596dd111cddd3a43cd9e19302dcbd242dc7f2be29c84a51ffd65017f41337ede0a739887af53decfe1736b496138205fa2ea4e4a7fbdb06ca2b4fca8ad2c9b48b241d77a3b50a67911d7564e9d2c42bd29b6c621ea7420728ad85f7e81a7eca38fdc64f4bacb038aae7d6263845c55684334a788faf56844318fdbe78da4df714302a61d6015278ed028bfbd800b12c141aeaaaaacd78776f743bdd02f1e221cb3042baa6c15d36a2564004c9c75b703965f4c8557ec9bdb757635af5a11acd0a2e8406e495c7ece580ac6983456ea338648f75a08f5e424ec4433faa8ebdcb8fb002a658c8dde8fdcdac1abf8ab549a8f6fe0d95430a090f39adc90f0641b61dce6b5e110a2bee342259e3c1785eb5acbbd9f5e0eed6624fb705fa1d187ea4777ac16ed7834bb1296cc75abb7886d9aaab43b94fe7bdc1d10e38e7dcbd87e6b17f66a81e81e9cd985e3dd9b84a1b65b8423d1045a7c630e2c0499c02e19e1cba1ec924a157b64a9c79614eb3a8465c55c47cc97a32b9bf4236f6e121d99530d77feefe3fc5513ef136a5a1d85e0ad86e4a681dad12d3515fcfac15bd974345e448709e3f8b42a4be7bb47366eaea13a3166b8f1e61757cef2626cef85a3d9f250f379564bf4f64cfd22ce99c3e82b263397dc04ee2b9238f0f639c248b4f13a26394e24cdbfbaf61397cdbba07733e71002b6ceb1a30fcdd202b065223492445061a9896385956bcbbbc33712345ef211c707069037c25dd791583b755bb887b42f9309dcce83d34160f7aef7b44048bd02b31c658ca37ba3941e84c0a5efde835db2e692d2c23dd1562fba58c061d397042a814de272ba938e4df7efd039b0b4a16009f77404daa8ce46d8826ca920c90a19a99bbde9217102c9f571c9fd1cdf60f3956a7d8ba9c76280dd4217b4b014bdb535cb4e6a167cda096a841364a5f74217c838ac3ac6b273aa6ccc475acdf2c676f569ff0d062c4efb3d00b6d5d705accfb3f430c9b7e865d6ce8a835491ae3c4b660680c0317f36b603b3461ec750ae665b6adcc370a6054e4217584e6930954af90b23c955a90b48cad6f2d4c0753057d4709b53f282e10f37feabe03900f23967c2c980ef1e1ee060377b97a8848e9b37145506f3f394e33ef6689ccfa12bb8d4977ee3719143a89c807de239d53e6e9a1f07f832f79893f82f772bdd570ea9bc42c308e01408d14503d404863f2ad92ee1d2a97db51a7b1b1ebb752880b4a35ad1e763c4999a94edb3895da0174ace377c39ead5974db9a5bc7dbc98118a5bed761638df247680302869afa349e1b9cd4c69f6a2a25234e67cba94020bf85261667431be445cc719ca2f8beafb8ea22476a5627e2a347dc966f9465fca9c20c8e41c7e0aa9093c743801c915644a5ed9545da37a5344b054f330d399d3688607a40f1b804bcf17e5e4cb5eb3ae338f0e67a9822cece009855d2d681383ab12c434a975acd7827b17ac7676dffd54f80e762657214c96b9e736a4b853634e2960f2ab519c725fc997212efe074b69f3d5447ae283615d0205c35a6fa15fa8630816ff8386958367a327a0ac18ff2e8f155a4b412decda26e4d2508a31f55403f787777a1e172c4a972f90becfce9a16b3aa3a82497c75aac78fd0ab984ca533f48c76358304be521e1233d30bef23ed75c1d6b59872127a8841f68105348587089c33112532cb6b5dbada52c1d339ce534011f4dc9019c20ae59f21f45a903b8303b6898f11acc775f1657428466b372f678ed777772d94963a45aea5667ef134ddd715633b3e58a0908bbb8b58be8f2a337c77539d5cf5bf0cde866fec14fd16ca00c88e11d6d37449991ca4326d5ed2fe6ef10b5c3f4b21508f258250c72476702704fdcb3ace1665c343845ba7b990d365b402ac27d8647a03aa33e6ad4b9ed091f79a28c310c2c898aea88850f749696acd278a52dfb8586d77413c1e62a0734d29400273eadebacd98f964c47da7813d8480b2e6b8085a385c2770827bfadf2ca37b38ecff0ddc277a009fdfa9248b8135fbe30d30b2b23a37da98bbf9053f0dbd3b78e026c810e9afb8b6e47ae52c562928260ea36736e822284098996efb1275eaea6810020e5d484b16ed087c7916c252f00cba23b2859fd63bae412b37932af2c2c6113e661b00ed452c48ddaebcb48ca3ae1194d3bad9b117498bb8fdc2cf52ed5aadf40b2f1e0b77e906883627c9fc0982c900c1623fd62d22b1eb04cf07595c173e5388598bea2031a33d3b06a300d0c3c27fb9c7f10dbf9c3790fdfb45165311f8d1d38d5ba5ac635ab18b969280c3010b13cf0d72a8a46a1c308a86b53dfec18aaa187391be2471a285e28ddf6665851b0366b4851066de768f49da9c183096d767f496ff71ceaf3e34cad126acc931abd5b94777dbee601432ba96622ebe1a43f7cfbaaff8131812e93e6f9c16ae9c0e549e94a5546dc53d84895cb8f5c8a30183f6cdf7d374770a467e9c30b555cda855a502786913dbf192b7150ee68e61831ba6817fd5d0b3a143d56d82ee3c8a3697f56e4242d094d7631793e555932703a51a718e463bb6254bc972045cbf1f45ed704d2ebce892d070c37a893d0cb7fa801324bfc70c82a028e8b1d04b11aab4cfab7ab5991a1b6cdda4e81b3cc8aedfb031d1d95dd2e7a1919969388e0c33882aabba6c55d17b2e35fe6ad4623d7d4125abf05d5bf7bffc7ac9370003c68d0e1aea0d4f7e96e634781278a1c787b8ab2c1ae56c1fc6ff65bb206a73695402e8397eeb5b4ee457bf171332a4fb18e74f82193b30cd5b883593bdcc2411b0897674e9a2143a8a7ff30189e1ee884ff5331c7f759eb58e3b4e5ca35bf9ef77df1a832518581b409487ef768b2d56cafcfacf32b0e30064edb9617294d6b65a85d980d3d126be92f21c63608d0c2f7dee5590502b69796fc7e47a882a2ef886687c025ad4c4fca1a698c67f75c3647fe6f994406c0001e399b41f32a068c0f1c3a39d88695d6a67574139a28c1c923bc3d1788aff68931d04bb58547d08cbe73b02b5e5c84da690f46710c428cb9e06a965cbf169142d03f472061f43286354eeea1468dfd5382790b4b1510ad2302f2eb079fe800946133629650695630121866138dbb7129ca40d96f32e07090ed4da2c7396d1d522cf1cdfab81f45009304c7d761614f6797281833724940dc41abe01b028927ac71a6b9ec9c1077b19ccb8c571a1c942635525c972fa45bddd3de0e883412119fc123e887c96de895e4bc3aacd61be79bc0bec377e043528db819a43203a6830e848989a6b3fdf286da0eac14c928a07f78a4e2b66fef90571f5e0352ecaecfbc5caf0640aa7e3e0e587b7fc93df6ee93e707ae8aa25e70b6284364b477d084b09d2740369db7dfa6654b59d81f7d095aff6e8f035216cb9319db0f3b46d09c76088ad140307b1fc469f938547baaf5ba99bd7846a5100b1d842cb3ce90a3d002434dfd2d277570b0ac5e6883b4a8e5c2de8206d67982023a0c6014f30d83e1318e3f19a582780f1367328fe274428a819310556de6b5c9bfeacab2f947a75c58cb54bb134d0534501257831c35d3843c3d1cd92fa86833327acec542113eed45f0e08a1facf9cfdfe8d734068c5bfc5b65c3ee0106af2d1730f75cbd0d0f67f27cfddc13470e2beca15bde4ea3aa98efda982ea579516cdd13a2f0f7f38d4bd13228626dc59b42ed4ccca5e76d31859c41e34a7e09591822633d460bd828961505255ed64a84f85415f0fb7482eb5533497ec68f54616c2091364cdaec22cc3ec0bd068242078d22a1778f25d0dd4c34a9f8008aaba5e51edcd2677fd881b4ab0692eb02c58566a22905fdc3490e5d48f1f4614f376a03799bed5734cdd3315850007a5a18bb3a5a4c076efc14acc95cf2ecec7eaf3056aa3536b0e49709eb5ec5137b60ffd4ec6e328ce0e48b135a1436e93e561af8b8cc335b9a13ef49f62c2eca013454ab9462fbbb5f1e20d78c849aa2d54d1a84119ed0711594b583674d178bf84948d91453c1ea0b06e8fc42978d8d5584f625c5cd3d6ea5520d06fbcb146d0fd72d346cd905d80e6ee6b2b27429edacb51b7c34a8abc06b4914de056704944468e1624af4daa5496d4cef714deac92f62eac4f91faa3b1d41ed6d89f3173fcde43a08249b33bb4430f21ce8e722471621db88c7ef0076a34dbede8adad4e508ce89345d8c423f89a188baead291ac0a2ec9455da032025d5450e42fcfd9c3375b152e4740d1a0574c30c8cf82e3a1176183e525dadd71af5b8d1a0a4b0525a8d9b7c14e2424f872c52f97a9d4fb74ed5dd2029fc24a255376fb2ed90e1a65424d6ad19d793ff1bdce624f3a3467ae42fe6bf01af4c40b7be277914726917084b5f431d80e6937f9db81302db85d3d67bdb306fb1d91fecdc54267e4e585cc81e8db64726386f27f32df75f63f6762d00635bfa272ced74341dd0f1a2851ae9aad73bb07884465b710607f553483abb9763d71dfc078ab097ac5bb9ab9eb0f1870d31c5f71929458dc8dfc56658704afa4b3f1718e0641908e6b03872064933418de24e0d516233e819487096506210262b51ab25241fe20499abd2a3fb50eea1f4a0358a9ead8c115329e9a20a4c4a285230338667758eaa3a34d3cd5301f114bbba4c182837cd984360091d131ddd4e88d569f28bf8d2bf8b16f1c21821b2ac30d945b577e214c7ac81808a4ae990dc1dfcad64e384f341e793b81e2cb222d6fe7e36e283be1d0dbaaef37db751892bc51c00c2ec7985cea459fef39e99822a3fa8ab35170eafcebf98748d8143f8d0de430168e2e2f54bc706d6c4ad06736801cd267df4837a76c37001c3ae11e9c33ec319c9728dc1ed8e55739459997c719d7a53947ce9cd6acefc7af2540a60fa02ee8f63f07249dcd2a9caf0e80d94780709ea7ad61867a1ce04e9c740f9a71cebf9cc2ffda72f715e45f56fc49ab961bf49f63e676867b98aac4c22e27206bfc8fe61a7ef3ed10239487937ff0dd53739411e057f81cc744038ff16fca866cbafc55abed2e6b3e6f7f111f08c98d144db301ad4a6d9e7b114f34b79a6cd8a7698f2c5cf12208d548079ce80a38a452864f9b838cca860135f016cd17f8ca3c38be34e06f8810e5722e6d565505ed19a07c3d4f8c1ca122c7bc080c3e3b761eea4c889dc4cfdb1be188e16b94b8cff09e193d9e372bca6aafb20db08406616c83e634bb574ab06be505b491b316e7e898ae83028f55473c3359b0a773a1d7409f8bc92c0fdfea39edfb81d838d901912f8e85c3072706e65cfdb4fdba0eb21c8b62ce9d68e8345fd0277cdb912c3d670e5f4d35aa89589047fb5456b0d0a388e46a6871990e92c2a6a84d421bacc54ae8fb13296c28474831e31f99a4280c37e526d7451ee51add5d29f7b85572a55c68a5088c58999aa241e77f140790716fd02a0ffddcf16bc2c61e75db8b1e1a56eebd87aa6e03b555f1e3284530ba9560b813b8e3c4e7821811582a6260c6b749e7e0d5a17be527c194ebc0ecffa4ab3b0a97a6ce5b79c931039c67a127cca1620b55879d0a3922a4f26d7c6e5a97e16bbf05ddbfc7fb6b6b8ca614db34fdb532c338781ab713d84fbcb797f93af1715f5ed5c5e981825b084592e4d1f9510af95c41cecceda65238f93dc92175992a5a64947bf1ab0c22df7cc76b3ad67e63a9f33facc82be5b95ce7149a9d4c7bec160701ca997e726928d6a1f6997050994dc95f287aafcd8ca6435858a41dc11c7e23e4613b0ceffdc45d54b65f225d44134064db69555b751a61febd64923121d6cc32854c665d848081af89ffc51a5b5d0c442944c91d2133ee7ecbc46b6b4f39158c4715b36573784512b963b4667929a82ba05c8d561449a2847f141f72f08ca6a16eef329d94165d6521bb11bc32bcd68c77edb509b4bd06ab3eb40ce9fd8076552b30738ea564343f434432c668ed3ba98d246333c0637c0295508b6d1916045019b321a8c7bccc6a9169a85567a75487410e39024b8f2dec4bf150fa6b4f2a1548db5b2b0fd63adf5dc43e2b26fac515c649a2c92604ec7d3f5f614a397bea9f230e9a93e667d988ab057c47b91ca6ae6fa0336f51bbe30ec2f9be07b73ecfdfb2ec0e1d6895f71ede5c2ab4fd7c86a6b93e1420fce96c8b826850c2c5746205e2353ebae124f14d00c471ce61844821ff8e5c7347b261dd5186dc676c18aa8fe22c71808e5c146b5521eb20c5559bc09f5c1616e85f97ab47bdb254a3e47e9e027f272d6df0d0445bbec5ea85620fc1bbdf03db6371337db113df67e0e44bbd70bed9f5bc7ac7cd1a50d55ec483cdfe0b6ca8729cfb360d167534ddf0ce73e2d1acbc3b5670c2e3866d874b49a1690172175890cf747df74a20da19b09e90fac14f8811101b68f2ad611376ed3369d10cd9f81b12f0bef4372ff7332e3008b284cf53ed525b9dc002b70be95839a7dad75d40f0f70db6501d946feb4ec213604d2d166536371581c3de691174a41ad59ba3db684218b666f5084676aa8fc7b4b51f169372988088b257afbfbe49c519e8ca71443cf05af011e06a3e36b7848ebbb35b3e56bd42d71d51e2cdf997929a660a61d681277f77193f0895d2729ac0b6e73972db2387f8156041020bfe40fe4545efc353694554d36edd2444508c026e05fe676e42d08050cff3057fcee58f9c661e8d6a6116087f8318a2794e9f531ffc9940cdffe95778c9812c0b7976a09ba4b53a74b542cdedd033d039121d0f53dd266a4f3d692b652e306c0accc831568ba853f752c95b1824a3fcc9db971746534e8796ed1c576cff583b6732713d0f3346907c31186e032945f4163b353526e51efd89600d7dabc491ae9cc3e376e7d5ef375e788e18920f9c0766a2573d6c7301dabf6c4543b328e938e01ec040b992db68a90be9dcee966ec5ce63490f3e05daad4ff95c16b2af1a81c4e6084dfa71c279e8986203ec2b3e0ba38425c1f680cfc13e0d60f6e42e3c3d654a196b907e7ad8722374d6ef0c2fa49b479f2fb4b5b606b6b4f8e1a7523c42df8e8b6d1a6dcaabeca5515cde0518929cdff22c6e9cba0f12508babb554762ae9dc3806f38f9edba0824854532e636ce45cd9b66ee5b13c528970850ba146e592b3e11660e10c699250e466bf45681b587a0d909745d071e2f0d1e197c314305804507b098389428bf10e006092c9bf343658932d27a6a2967b8bd7139f43e9cf08f64626e40cca2aa77c98e5e6aac655444befabeeda06ef028ec9268b2f47225ec82bac361245147f2ed2748c8e4f10444e87e7d0fb5eb0bbbb8d97c317404dda7d84ced9e89631084818b0b08cbfb7153066aee5e060a4cb5c46ca7dbc6f3046d0afad156a0726104cdaab795ab7327b38e59b14ed08b58242a79cdc11e08f8564950011d91e55d636441e8a6c60062d28c4d7a4ad0f26a03f9495fdc72a578cd3079d6b97259d3eff1d26bef842967ddf2ca419f99f4638390d058299f61dcaea813c85f5e4fa97bb9220acbc94bae8409a7688a595bd26c97f77bde5bb118dae83e3cc35e35d77b609f677a3b2885fd1bc48ae40cb5b71546f9c7e2eba7b3e790c8bb05737cfa841f4db5bd91d2cc0c16b436d7f2217ca6d3c64e12f030728271857655943e6055a2f905db16824d7ca9bf2ac5e63dd72563b128b594b1cf3b398bf0068d1b9a46ee324d1eebb49cb08760c2a34cbab75bf8a61aa3ee936c9d81978e67a830ca937e49c08d2e8cc7f5bbb8ccee7cc1fe3e66b40e460e1ad725279c7d999483d14f246eafe8bba7fb606324e63795bba506ad8e97a46d84e9363efb876dee0beda7d2cf647b1b86c1fcb91df5ed8983ab96de64be7e222459a7bfae61f946de6262e7adc50762c649c4eb720a62a4b069fb6e221c5b668408d31dc3528633b1448409a58dd9c9a6c81286f7c4bebb31e33bffbc297855f764233478a71cdff07ff20cad9b82d73de52eb07f603a4ec644e591f935ad256435b95508efbce16ea3d4112d9eeb79431ac674e7fc24abcd6500812f1a50090ecb60c40f88cac7ebf3ded9b8946fad6e955c6ad6b611a3778288d00d0e646104436a777eade5660b01e7988bad101e2091ccd24a0324083c48674ff1c0c25a4c300f484f0185bba8b5ae7fa7d7611246845cde2c08e0d5c72994218b2c657e4bd972d3a67be39bdab3f3459b34fef001b31ef2867f552268846f0e4bcb4f516fda5328226f689b7b4983913f9019fa51b879dc8a7aeb6c74a5c1aac05b111ade9b18af27f3b36fefb9fb8ae07f89b306a69ff9f61ad727f0616a76e0c02725be4ba15f412700e31ae2c3f0c7d671e75c54eb529f3db2b09a3f56e059551770894e70527ed4e7d0ce8d81c62018761f8f85f9a18ce30310477e65377e57154b31cc369042f87311a2ae69dd0df4f6ef224cec94a5428b2740992a4514dea0c285bdeccf58353bc3455cf51794962e3aef2d231274c1cf8357989d90afd77373775a05938bf6b6dc8f7766589e21ff98771230ff75eeaa872fb92dd4416c0e540bb4e434bcb42d7081129792e85beed8118bdecadb6c69fdb91719161d6865adf238e1df4a09b9d2ac14518e3638ade867172071babcd015ada5549153818da34d1da179f80c0cd8edd29d2813574eac2a5cbcb594b4a042f408b515a2225a5de8dd086e92e24cc651a39dd9ef00cf85ec95a615597a3a8edfb704619c54ae1ae6632ba864e394d0f96ec93668acf72f72d2c5eef6c7743c2767348b8a0147b4bbf467ae7eefc63146707a9b45f7fb7d646caf57231822de6e54d1dbb32195b81690fbccf1452e9a4c043677c064bb2af903e54cbd616181232bccb3e6bc129aa1e6d6271d76a69b3a813371a0a293a7ad92bba8d767b3d555833af3ff4759ba2a13d98af5062203d603df7c7cf35373f2e6f160112ad8b5721400fd57b9b30f2ce003cb396b8d95225a7deefec5f323f809733a5fde2d85ff64df9ede052ddb1e09913e8b33f40e1deb53b48fb57471a549a6e3d1cb84dfc79add4e64881d51da354f21f31a9439a1f0accd27874d944edd787c33d0d8b3ea9f9108ba53d25aa47abb47b6255dd1afc66b3463c9cee6d628885b80d875dc6f19cba4a61d95c19f6fc2d12edfb6626e9867506746d3f5b656942e4502b9a012d03ea73e0e01a06d648ca6688a0f34c0721bba4d8f2053094d714217012a8b561e5cdad9b6542ea7e92b2a9d8e5c1cdbb550fe5869e4536c03a33934d1f8bbbf87026e939abb65926f44aa452cc573c245ab92d24bd17a77ce9ba5c8f81d3ebeb97ca3b62d1101ad882b7c52dc670f1b92ed3b2fcdfdf5b15641581be252bbc4058fbb2a2a428d312b992c700ff2e03fb2aef698d624767722b19ce5654f7fef2c188bc390cedf9cc5a4255ca7b5cccfd8a1ed3110b543a0c64e617cada1a49c9773283533c90ae7c1ca2463397ff01a8e1d4d5ed705cfe3f17d7f19f71ff12caebfcffaefcbc67c2659b194b0c54fc86e569dac4a3efcd51e0ab8d0c5e7ef2cb6b79e59768f3a1c362dca969c4f5938ca493d522bed40ad8ff972c4a3cd12578d00f7f4d9130e154056753381609092e1be40bad06f835bb4020794047e4dfe60340fd4940cede17def4bd4aaa1a61d4897a3766b7f16d46bce3865f463ef9bbe96b494d6b7229b9998da0dd90187d35c4d98f89e4c1af5377dac4cd53b4f97775e3e41b7869b7502918dac0cc99ac29bab0c2b0ef472b2c1d5e3f813774fc64b82a26c2de17c4315f42f33f251632b251c50cb72c5358ebecd6de262d5d5208c023b51e1ac48d5c4365986aad174a0e0da42dd4887d90b975f809fa32414a17f5522bbf4231b11b97960aea8260736e67e7aadd7655e7f58781e1a22c2a46753f6e040b09bbb1afe279b9f1e80d97f767d6b3fc2c2cd203d9e42922ca733707059e1f7993ea5592d83da1c4058db516966e716197c8785049686e863f4a8706fb700190fef7b030b072fe82f195a36167ec9d1f00a520f483a2329eb15f26707915698cc1114143d5d27c250c2e50b6824a56a798f3ce3d4119d236ca17039e711e41048502c75fb218f5028fee2522fab44eaa8a18c84bd0f2fe3155ae9d3c450001e27025d89d962f8dd35c6b4a3a4d09446cf6e40835588d83689a46402a087586abfa512260ae71b534df768a4b232518f88a3d246ae202f16537f51fd1bcfabb32854b500227d520030b59a582f7047f6d5ab6e0fb607ebb32a56b1b14ab8304609c43044b414fac969b2279e0d6ca9aac10a1faf899b217beabe8a659ad13d3d91404ebb96164f27385164cfd89238683326bd3cb037aa453778fff28f21bfa749395b8f2b9b154806c33f55e8128e1dd28abf46bcd9cdb7616737cf6d42404e8623c3136da133d85c8760dee86cfb46c3fcf68d9acc581d5a0ccc5e5a7184b961cc18983dacaee835392c275d0dc7d6342683f9052699dfde2e5d08fb4ad6ad67bb4c8cbe2cdcc111f8225e8b07de1950d3de3d10c23f62d1ca1d18557947c906793c43751cd5149010f0881a87b9a69ce896dc458fe8703511de314197a1068b1d65a55fb6dbcb634ce38c8e81fe12efa8674a5a3ad3077bb97d3f2869330609733fc86a58530a780d55c930df51ad8545bb7c0c4272dacdff16ae8b09de8c3655ee020f8ecb99de4081f5bdc99ad9137edf15f2796c839864ed53310ba49998c0bfc8e19bd277b2a39e802b0fd1f16e1c9e5ec171e3ec8784fb053a67528a36bbcd3fcd91f06e512bf3872eca96faf4b7e211795b1eefc90bad54fe4a94afeb97306dabedddd57467634f6d12231e1cf5a159f2047b895d17aa3213d82575daa1a4864f0835a1b0d227c64e5705702b15637a960da9c78a3c3a2b6dd55c6ab91ace8090d000a21d32b131d6678a5d39e195f4fc41d05a81b459f3b8ffb00428b18e1aed791862b312bf88e6f4f2323c230a329434a1f496e0c6c3564088803fb83785203fa51c34b94b25787497d8b372c1d3f8cc75df75038fcdbf7fd28430977c4a97e0b47d8540f712d643c87b6ffdaa44a0d13f2a6cee61e9be7271ce9ebd993d918c5849f4fd5a1c98ee316a481e6c01ee56d48b58dd819578ef5adbc3c7d3d174d63a7861c9cd6b0a53d84abaa55317de375be12c7018fcb54ca7c1c3eddb4acb73d768077468fe0bf38f5900be5ecb92b08083dcdf725deadadd32c9b44a2d8c3f2cf31c0d935b570956dae815bbcf949c83424813d20802e09c7edf192de4f08f111e9912623b5a81404faa3ef66bed0cc4338eb11c5e8ff54796a97b8fa1c2b0491eb648cf4f67d3eb10b6ec9e8e31e8aa6750c931563c2b9fd68164ee7974c775f60b9db9123d2f4de8e8844cda991291b627233f24ac56dc56913e35b31e026fc4014cc0cecf48773aa09125176d32e176d2484e4ad022ebb2847374a446ac7f630c670bd4b460bebb614c21e2b8bada1fdfe9050ba23e6f9f0caade3e4e8bb88f5ccd6ae6cf3192bab19ecf63efd44c0aeaffd98a8a6618c585bd49d924823e9573834d98570b50d7d1b943f30d2b58ab4ead1648f9c9cecae24fc449f6ea2f8d3990de74d479328ffb29cd98d4bfb3cb180b3093fd022892a5a33d252eb09f0025879417b099793b29960b78b00c1fc8945a2cf98f65c3527e71255bfa4c32c5c44de840559433dc45e2853465106e9041d30ebda302f1a06147e8ae9e20ac60b56beb0a63577d3d8a76a6440ff7beb77efaec83e69980509b34b453652e51bfecc13495b3e0d1a8770650a5438a43dd0bf701dba68bf0f56f71e21798ffb8c1ec196c577d6d91b5d114090acc45083e03b6b41f3a6fb56ba6f01139a973fc6f7860e12dda0bb4a3e76ccffa002c916640d5e53739cd6a77f236e5d743f33ce41806214b2bc4dfc74815eb9f117e8eb4938fd19b74d5948959d05ec25bf475951cf2d936c4a0e3eac1bc4c08d82be38775e1edba70b6d4d9b47450ceb64b6ec1544286ec842e08e4149e74d143d7def8372ff5c84a8965032c41a8dbb7c604e45ecacda3b11804ed0bc9f4aa34887419625cac41e977fffaf2da7a3b59ed3a2aeb64e2740efb10e3295a42a78db239ce1dfd794dd834e6af13b0841739c40a7c14c7c1c99cad20daf953d1a949b6b3e01f6a720add3dc77ac47e0c67966ab51373eb7c6113e34199c72ac3399b9847e045dc7d472872f7df123ca7e00e30601b4f223aeaf459a05125b4f00c71ace73ce4acc8fad1eeadde1abb406c1a40a64275d7816603a49674b30875f35aeaabb7f52cd77b0860d9f3c078566a700b0dd9561ef7ab1faeef76e8cb2fbc7b385e0ca986fa3f133ad23007f7d14578e5315538a9cd0d43bf8c95336904171edd362ecc2b8ba2736aa3107c1ba0061216a20d89f6d5779154f0612bb6eb927390e36fa729f3fe0da1d53dfee8b3cc26a4f9fdd55e15d9803051d23987cd4410f840e98c871fa48cd3ca4ae4d1cd161608802e55743ab067e6c6a43095d17088583ef3307b735d055fc66b9953475200edf747ed237feaf3f9cfa18b97c5c8d666ce30d37e7edb80b6901e86ebc8d7411c9900b5c10f154ee0a5f0988644504a1eb1b63b6a3d395a48586f7e62b707bcaf0a7f1e1665165ca0895cab2fdecec88ee0b88612578730028dbfebba6d6dc4c7ca5dc496d51a6e402c8131688a4b6da1cb59762cef6a932611a70f20a168f2adf78460741f3ee787daeeb447006c335ec04f78d9828d92308e8619a3715d401f8b3e0bb357b90ade8fdf5087e54e6bff292ae5e2972d99fd27fa3cd6d6931bec97cdad9cd4e83c0a6b40a4993fcb8d6ce0f65fd1a95c44c87ade49212a2820077f7630a95d87c19f2bc04b88f37abc38819fa6ded6f4f319a97912ba64895de17114f2debfb27faece0e65aa8f302c57c33497da9d307e711e6f586408295749dafb55ee2006a0bddaaba7ec5fb5023114fab7d8b15c69d55ae31592c3efaec73d599d425e1c9bb20389f1db868991997feb10dcf3df3d1bae9805e52e1682c0228e4875a770543b090adfc050063eea6e100e6c278f7e5ce215e47d423a57e4c1ed3f61d34fb985118c635602ba2e277078378ef4930eb5493d7952481fd1bba46f8da129fde923025ba95ba70355c72a6e0159e8ebf99b713ac2a3e426b5877e304ccf27a520bde18719046855906e348462efc65af2e3a245bfd7c32daa06af8e89c5fad07b121f4bfc03ac4c99e4808836feb8a6221d288c460c7325c77f47f0fef88559cf7e4bcd6520460d59bd4b9bc71aab6f311242f75571b3a665493c7093f05960274a8d981cc9dab0e5288ea918b720b88373751f3a5e5fb5bf3a0c990df7fef378cb33a13f041d445fa9297b46b6be7d911b524461aa165015a80f1b5ae652d5b018779dfae509ae519d18b6a0f0f21e2eaf3c259afb7dc0aacb208cba8e1f0f147b9413e90f751e5298130151f36c7d6e9e0df970551cfd1289c0ce07096cdc16914d2297ec361e0d929d87f8c969090b259d33585e7d6e12766d27ecb3506443c3c070db63645386572285500dd529ef76ab73627c87cc64ea2eb4a5aecddea56271647f3d64c3eb3205ac5853e64a8c58cde365d480194cf26ffd06612120a428659ff3d7dfefe8a66dda82c860dcfe18638c808fa6a71f602de8cc188f89c321a9297683b1bc5c5a31be4d0c614151785d67658a1a434c3267413b4584669ba7994450f936c20eedf88e7debdd15c447edad17a5e1e57939c612d6a9c8bdcec9deee5c94d2b0fbed776d510751ef74e7105d5074437f33973d1c9d4631f1c3d7efeb1c6d3f9ce1e76c34494a5aad41107e0eecfc64f5ff92bee5e65e2feec185dd2ecde6c7b969a026e0362588dbd6baebcff6eab713392a4180158a8368a624ac7bafa3ddf3fc9acabadc82327e4d67386a78f708453fbaef497c7ee826ec56cbdb37c60f3eac28c97082748bc4f1ca5a360e47e8da5672c6aa80a09fb28df29bdcb1f6ae91f9c9311d6780d26ca342dc22c17e935450fab1c40c807ca1927c82473675db91b31a0d977f0b9f8fb5caa0963e20c585389d2a6533b538f9fb5998eda14737213eb23c5637323a1f67b51446384997f8d5125528c3a8be2842b7f457d07eeee35bcb620bffbf68f5f7ed7f4bcdc5704d7a4bf3c256285795d7a16cc5a3e454b0a077c11dbbc48d26cd4cb01da4fb0f33bd0c24873a18b4ab1250327b6f833c368888f557772dfccdfd7a2dccde523e50ce1cb306ebd55bcc222b45d73eee08c9fc3351bc49f22b579756fa16bcb8edb57992d9866cb5f7465893912ba290c382319592ead059c4ecd1835353be9dca012b70e7ef7482d6a5af9199267709d9840c642ef8d982510ee20f8b5f40f16b8e79f8e8e07cf85dfb751a191b4d7c0c2f489032667f37fe577dd296fd2a7e66a10f793f6971c8716ad79dc73e8fd0ef8b41205772c8c94aa0b54c1b2135513832c97911be58bfe6e432f544b46f10a2139d1529fec63fcfc56fedd02fe4e40d62d9437bb6628234bb16ec0a4f3435c7d3ba5b12c9e3076225373022ae95ec29beda959a264a8477b098c573914d252866496c35c2843fb8ea28f477d871aee214e491b83b2a0310482e3b597582a1fad412e14c7c3b31e85321e6bd5001fc064d6aff297aac1951b4c89759adcc34c031ba85fa6f4153afce5c4b3a3e529991795094f3b5afbf7d15d1be6b0078a20898b100c40f4415f342fdfac0850355dd2d3e1cf11b7d2a046e9bd18ce10a2494cc82fd8a022b8a5e809b305ac1af76addfd883160ece966aa15af5171b8dd5b56ec4a31ea0dd7b2815cde0838ff22a3e0c9e59e8b9e673d7255b7c6572f7cc80759be7cf2b3e7e8e6c14a85e7974aee9631f9bd2402bf3b9f5043ecbbca0d6c80f261153e7f21a1b02724d14f1abb277c85f53ac32711f3280fdae092ddb60f5ea0549e3544ca4b99f4daf9a8f4c71d6ed965ec6a3e38013e679db480c95e35d275446cc8b5695b8e4fb0de85acaa9e05b9b80515a2850ca66c482b6a4f730fdb82259de1bcf8860609e0baaed0e4d58e781248644f7e3da85bbb18dfeb8a6b05c66ab15fb43c7fd9ba9656e6565738ddca6c4144ef12578f701fad935c02f10e2ab18167168fd8143763f7ebc1662962d439fa8d303687016630017d29f1ee5aa6b99915994f7f6f67cf95ac425db5a37540aef4418e0b91953547545cd639931ba633f17374b580201e687642ba2499962b327744b273dfbd5004ee2164207b1f578a967fdd2703f014943c6aff0bc62daa7e062564beff786a1f0001f1dbb967668c1d3d7660ad3bbe7479833977b65cd372d8bd35f065e1d94c07ef79c4709075b8648e54f6f388594a7e039bda930888f113549928b4d51471cda665cab8e8564f998eb230f41ca33431bd86c010f042ca9fc36dcf35e5d992bd170c446cccffa9ab4507821d6b220577e48061ab14a7f694d4f82277295cdce221a12f9a473f53899109ef7dca41752dc4403d90ddb5fb291737b01741130544bb3c601dc506b9519c307a53eff89582579076bc040bd240f6e7cae13be821519a52ca3a36da2eb668d5f2768bdb3a7e1b342a5467b628a49041347fb2eebdef2be21e953b3afa9316d31e972c2fe1daeb87364482b63ce26b51c6b908936440f62f0ef326d07635f70b33660eb01bac309a1672810c535df72fd95ae130ea3dc4822fb6f0d2d557ce30b3fce589ce32f240f36ea33523f2d4a0d60b2503219b11aeff836313bbb5e5d8ecb47b037bb2d9d19ee7c9d510a68c9a1e99235bfafc5eb1592852ba4019d28c314198010dbd58c51065bde81ba5680760d32e19c5280dc02d95c3079c2d6a853df287ebb12b63eb12fb330218652a0a69953952e1517fe42f1f08541fba16c93190d216b086df9df2e26bfdeb5ee63cf856378d3e44c27032837afd9f9027aebbf68e730ab32b5c1d177b516464b65db35ca44c6ebc301f1771e50f39d0edc88119704f73adb45a5c36108c23cac0cc24ace5062c8cdee78becfb9f49036304c0bb1f7f138cdf69b368223073ed5694d2e4c915f2d873251bb1ae4593f060fbb19dfa98ca3b83053487989db4793817f176576ba79b4a9745796e8e6053bd3c9fa835a797c2c10e6d0b30d63e6bd431b7db51e2b010f0e47a3ee2026d2c54ba7cea45b4134cfe274fb9fd929f87cbefadd29f8c06422364341c2926232a51842f7ea979b8a8157105b882493001fbaa173656bee6369b47a93c64fd6207345a021284e5dc7471fd9d409c2f6b67c5f5206fe216ffbce6e9d7a0c2bb2bc53ef166b6a6ea7a5567f22764d8aafb07c927863f308128f127f1d878d161072b0993b2c5b5a42afa36ea8363d282102b25c6e3e734a24521db93f0049154e2679081132e548d440e9e0cff3e5d66b0a764afdfa7b1811b0db3615e685f1e076a70179f9c2c71a08066b04de581bd7e4bdb9f4bf3911731bc1920141bf36aea11600d970c2bee2b2cb277b1da441847cdfd04cd3291d5c2b394ca8d285b593ae479f63a40071a405936ad23d686f9a99e39da514b4c073f62bb1c9729bcd5500f29c2269f78cd2746764a9f4e3099e71baeb5d8a60e20e757488ba96940750271a6ed615a8512c7bb0d93e9037bb90671fb56b5b992a762d5d545a59b4da6b28e993903c05d444c328789eb554e8f2836a11befc773402ae86509eec2482019977ae1fbaeea1bf1e3bdd6098000bb33012472905fbd8e35a5d43d467cbd784763e2ee86cffb4a07148abe7674ca3ec6da6b541ab371e34d23f512c5cdca03d1c38a00346355a7fde30151ec2650bb9e863ec2613eb0f20ddb9137596da5aff6136038e60e2bcd29111262f5e1d127de560c97d19d3ae250cff5d909eb47c4e87dcd5eb9268ffa113fe4780b0b38a0b4911dde2e5564ad249cb38ce0d85cff1d16ceee876110df6a6757987f691c1a9e342c2cae44029d15b7fb0d5b88fa4a4ee045acf26b42e30639e3c676e0f9042a8f7ac92b381dcc4a3e4ac8eb4df8a34442ea76259b482fcd936ec4808d1d3f77d6cffc6e8340353bcb995a0cb9bf8af4f0ac4ef3c55781dcc359a87b299675a29b72c85f627702fa2ececc42357f45df990f32597140eb2a4e2b3ff78773996972ed87083ee757f3e1d274a2d49d1f0b632ee89d6f9149673ce8f15f10ae28c790d811fc399567fe5e1d6ecad4ff40692bd68f8df2384cecdba8b1cc1e3101a6dbe27604484802802d8bcf41342bab0ddd8787b3e8a0011a0a8d98a254b3c1f606cddce6788edf61a6129bdcbcb5b2184006aaa8ec12bc895bde173020963c13eba3ad018468c28da8b5bec89973366a4f5037e35af6a0589472bb3263ee89652d8d8be317b706ddfcc9bbdea69b2df838d97c5f2c5bc232866ccb2944ba769fc38988b0c12465fa3d359de02c9a08bb6bd12a8ce4f91a8c7a244b0dbffd3a395f2e86aa32489ed619aa8a11eeaa8a71695b927b30d4580f2cdf84d4a2af6147cdfeb6b92c148af78ed7eec5b497cb2f958fd449b315bea42e7ad322cc3ec1051dfaa31f54aa9aeaa561a52adca7b90d0a2613a14e8dd9e7192f4467b5cc6924504b645c889ddfc4c0052f1ee63e2810eb0246b3e9cb96ee2f34682fdb135820d77bac82340e8b87b60ca0c2c6edad01147a6c3e4ff9cd4b5280da2b8f21bcce38bfa39deafe5b4e7cea1dd5b33e9a5eea893372c209b0dcfb45f803e39952b5168388d7b8081527898b4428a815748017bd2234703be4a7ec5fa8a14d1ab0dd03cdd80759b98b04a8e018ef50491544c106465ebd473b7a3325b604531d069f307af19b1b73cff32822cf5be92bd0a12108e8045d3ccda1a1dcd18e416f932e6c6e5ec41e3db05bb94212eaf39c1b952e5ee99571fc9a47e71619eee796d3b7b20551a531d5ab96c2fee485d70025385f4c741b5a8faca8010f33de368201b63ccce1ec2636adc6a30fccea54a6247f7c0a355e45139d37f75dcd2ad4e3b110cb4d234af15de36ee40e883dc992bfc5b2b48f13989a4e9e1c6d55e980466e677ab0393c2efd9dac5d6ff77722d88e0f30b26477e8896891d194f306382f598bcaa485fda954b581aae02d3a13cc297c560f11c04c8fc5f83747dc1b65847f857c70dd1e9563d6e0cd596f1de2e4bdf3937aeb1dbfc13e63888445616179d29f84c91ac791868ebd3ff7f3fd5c3f72a0cf59d57d79e0d7813cfed646a003b7a9b84bc7b445aa572e7962c2de599b947c37aaa00df1df39f5aed63c5066f97f7ada8eb6371b80c6814c7cee8ded5ec9d381e22fff5dbb4f8bef84d6f1864daf4806b7906047216ce452afbcd8b6c6b6a383b303a8df0a5222d1c1fbd13e5b80111d583ace125539b38f99a3de8660baeaca5c2fad9d34aabf50ac5803334cb1aab6baaed44b98009345a531b91388f2bbb3f63d84a8d7543eb075b6a7917b9b78195018e16a76445331f7d7e557836c1d29248658578e7755c5d5a1832fa4314177e5777a11c93f9eb47621f6b9c0602f0128fadfc0e8a99573bd5bd37d615b0572d7153e5311b1efd46aa904a58c59c6f1dc491a60c0d5416262a8b2c9090aa921b99920459e124ace369a90729577cf2996344f5672671c1594474c8453ab6c88501bfa6003687e592a9b8ea96a4d55f9d751c3d179734824405606b7b8cbee9362396771b6c842fe7aef08885d18ba715864d1cf56a8815086a5510c5af28d74b10bcaa620104236b9ec10c45b5adbc3fab5141848f27bb45199131d7089deb1c6da1493afdc678c77222cfd2012bc18bb8af0d50318f5e8675bc959496215ddc26895b86b9d3311c0031b0a88b34a0755c01b7a70611a7c1f83eae4f2f87ff4adaec4d5a0689888d5672ceea75992a6cdcab14f2a83e20e75e1e172bb218c0717e94d47ef070b7b8c2e0dc1f03fc3fde76fd5277d9282d86eb5c80b8a97bb22db27ba36f5a8e3d3de413fadf019dd8887fd411730cba67f82389eac1587d2b160f250251f759af7bd0da4296531294b508212872cedeeeb3f70b990ea92a5fb11db819a4e676ed1506be499bdeb2a119948253035debe84a7bd8604c38e75ae9039aa84b670d20c5c343d4f1db7b68e17b8e3d8b85121ec43667f25e2a76d9405db77390769727d156a7e7913f05ba1155dafc1493cd04d8a7b794b8339f0fa88b537c39322d153d8e5fb599a0ff9d9243fba77f68f4a34dec4f1a6086869522a3e85070c4a2d867d0489291e25da0b04d8712505acb6cf285a8dc15a3c57ed07cf5cb559207656a97cb081056e37aa9f77bccc670651dcad3fb0b407991afff3eb97411af640a14fb49c51421dafebc32beb603fc220a5d4c9156429f60a48aac7d3777b1ca2bb91bade5fbfeffeb5c369fa8ffc34665bd69031aea651434fec977fcbd199ba694a1d3ac5e2d3c336c550ccd3496bbb78b1f63e77f24426d30c378bd12d284b9b097917d8ec8490ff8e3e9023c54b6d0fee85bb9e6e1b875e00640be9756ec4d5a15b806a3cbb7c40eca19bfbc3d71c5ea806a7ce800aaecf6fb65d9f0f239c2504c64850f213641455b574139126b11c9cd8b511ce0d80c2dd9f8b82ab850de6e65a7c0cdf74d09ebd72b6aadf0fd485ad7f8412444b1b8f8046e52dda303826d928fe6487121c736888421fb7bd17ac97eba7a351c5d8a27254fdfdfd76a44470b2a90433ee1fd6f3596ec445c08e186b5f15d637c1ef8d6601c1009f19c5f581f0773af3c17d3206b849392214b4bcac77bd376d75bfb184b72661d39c94660bfba0bea16b3adf032708a46dd7dd1aaaa5cad2234177215c7cfa2e1cf348fb2aeb7adc6604a3d3646ee03e1960343ce6befda608452aefafa0f609b02f7314f40fe44e426e73ff34692ba3876668e816c227cf729b24fb4bdde7fbe29e30e4f9cbc2823c2c20bb0abae7774a9e4e6895b69d17803e10c98252963addba40892a8b8a40a9b7d31539999e91ba75d4fc64d30f384abad748419ca06c584be6e41bf4d9ac15cc3f430e190cb9c8ac5850b26bd1ece9e92f0f5769196c980cac200463b74d27db7ee76099e79a08e34880002807290b0852bb2d4e02df846a528c298451e6b1e42942b330781f9d97750a7ddf7e7af13af02ee347f165592d8f371f717d1d3b6ac374d6a13c7eb6630f06ba2bb162c066aa309f1b0a3b73f0116d8c253fe7255fab8c07226b64940c15a60c1dfbd1b763d670a2c14f8f41b238806fb0abaa08cb8b0139466f6bbb69fd82fbd0670656d5b999a3264a27da5e9cf9027102b21250f205892a2c8dfd9f46a76f50babb97910d6f5dc8abf39d9250513f67b1cedd90493bb2c1a546843ba668f5de1d2b2ed6d7283872ef445ac32201215362e58b6a643c414f62081fa931c00cdf9f46b0b5702b8adeb3379b0128641c7c108b504ec87efc91d515e960c07c5e327008020ffbb540e95d0f22356aead18253c35e5fefb7e6d0a8f72741990081ca4f2b572d508ecea9446d59ae78201cdb5739b40865cd9bac452a0e843874255112ec2979aaeff3619fc118e56bbffe12ae34d48414e7505f7e3fcac997984554f3edb03c4302748fba6088867d0fee033ac4e4dfe441533ba172845f3afee0490624d3eb5656ce94b0919947d799c53874134dc8dd50a941970a8cf0d18ef33c57723d0648c0e3f09b10e6c33a066ef8eb3cce1b0951b09176cc4450a1b580040f9b036575b8d060da26aa7bd8f4d46744d50ecceda4ab190eefaf94602ebd9a3a3b42f8e2cc0f7bcb7b1fb7cb83f0828e55b770f3a64d430bbb272d8dccd18b4ad06a3c39c8d6db01019746621103d0f53dd8b05c1516004fc4dec9ae2446e44e635c23f51cf0dbcb17064c8a976b2647b845463db672bb6400604784ed5b47727e2fc6178e7c0bab60b5b9e5fcf9ff85bb3d6a7a9525c7c9a480892f0ffc78ee1103258a1612d53692ba3fd35bfe0e05727f5e317d90cf0905e2befa835384c3054e8eb3f28e4b51e94d0028a94200ec47e36e6f2616fafae27b768be37a9b160d6fede2cfe4f7d9e33c202b8e3db18b7b6ca3199b1b09ac470ca72dd992541dc7415c2af715b6a300051cf39915a2cf68498d20bca981650a676f72c58a6abb905cfc8653589d676ac296c471a2eefd31b88b3c7549b54b0576c77bf5f7fbc5362bcef303f48c2dfc7d55e5c96532870aa0389a46421d08ec4f12840bc7b1ca1735fe11d02da3c7d54e073169cd64dd0ace69b936c08938c52c5a58d0ff21a8f94f31e78a1e542c0d970debda52dea187b4eae81ddf7ddad7f34e50de168655c772bcca1e263c0797bca00d850ab7d2b986211e4e803ff705b5d4be28f613506ffb1f078cfb3cf85695634e8f32d6edd876833adf3c48f10817b73ca0488bfe9f4c7c74d41478b573fb8a796cc5e1197321de43b327e98fdb0bc3faeaff6654c383911dc036ff23257546a7b53a11345db8e484ff19e0ed33a60206925fd03d2b3ac3322292809a2db7f4fa0bcad71a3ec1ce8411158337835fde9839003aea6023f1c7b8c05959ab2d28f8fcf0c510ed40ae025f4f8ead57f4f8953567b9a38792aa07ffcd4d7c88ff372557e3ef4048530b7cdc3e0f57157e6bc5098dd9532c99e0337068abbb6d59c082d1bffadf2dfd35e7ec0bcbec7aa76004e850edbcc2c930ebdca926f8382c6fd94e4868c3e3aa64b9a1184e973e6e565bc6a12c4b24d53fdc0b2733fc898f9fbbabd438aff2eeb44cb681a51460babeb260c49a73936351eac879fd586114065eeb370e8112b5b156a80b63ed80ab08d28b0b8c4148a86239f297d1353e69273feb9d8f62ebed72c540f5c68dd75e9043fd82c9d4b6761014bdc54ef9284ab29a21ae1a403cc7f612c3563730cc454af0832513630d4ba11576bea2a005ac357294f01b55e28a37901867ca5c58c5f8df2bcc042ed036260b45ed0c0b0266375b2eef90f944dcf8860f878a1e1f05e201f04ef0ab2eadaf7e8273274f139d7e1e590d0fe637ee2293de714a92c8984dc5ee2957336a68aef67f2860fc8bc4326aeac83f1901c123af27eaab4fa0e25a96fbdfc5209899229f694e41585a6c69c5563f7851bf2e045ea3e474f373fa5087336619aff1c39ad56e9a7b69862cbfa441c45dc41d66d8e9471ae2fe9b00f45e7e28821c4e4f405c1e585f5afcca13594fca5a3bfd9858588dfa4149f4882563bab18d8d7bfa8fdc7f6ba7f4abd4a3d5b8bafd8fb1691de91bf6cf6d0c78d7825dd3847e82f6b8ed418d7437b1dfe03523d719639a0cf0cff540a0ca9c0e1b8114be380783c2e1db612e4de2ef8613415444f7df064a0927683ff9dc046de3686e62c86027c438ce1810f5ede08f21e3b18ea54bf205930620c9492e8ac62f822cb6d1deeb604a71cb5fd0a0d32e8da30babe91873aa7f5c8d09b677625b766eb683e3cbb02b2ebd7df1572edac1d5bd60dbb1f9fc6dbee3f22b6aed165370ce78e46ec9de67c2aa3ef015d7de5e1c01dd234da3a78f0ba070e1cf2b5acdc3d724778deaee302b28729047272f9c2ab2aa3d4666bcae9f6def37f2afe57e0c36e0f1552dfa2f5662dcfa9af21d996c0198f51db961d6c49534b663ea04c1acb7a8a021d820af2273b1192824d5b1a08293591ee914a2509240606a29775a90a0bb867a2e82eaec4b8b837129b86d6aafdda5f9b8760f0c313b7a22af43a29327ae582c784cf7b97490ad53b9c90ace7cec65fb0c73643c0e46a9982c667e6a3452ae4eba9c5797719c8c7384fb6e16e7a11ed58abafcb36bd28ac123780ebd6f2e310bcc68e68ca4788f771ac17c79d087dbf4b3994415e778075d790ff2a2d58cf19a81ea453b39ef015c3c7aa0c9ec50787067fb93bd166c7d78691f212f98f59a19084926b4c2a98517b8d19053966dd58332fe3cb00c63a491a1016e67c91f6ca43ea875a37572e99c14b157564a675ff77e3e80b6a2e4bacd0309e25bf14524c53d1313b74613674edd2fbc82180de532f368d26d1e67fa10ed10155b0a05d5b137a62c2951978f325aba9ffce92d2d8f0e6dea2ce31593435444d4a022bcf31abef62c7ce0c5f57ca7b20f42eefefa89036d7f9c12822dab507022cf1308ba3a99cae26b81ba5e500e379083ed2c25bfbc1a6727eeb3cc948688ca5aeb3f64574efbef3bb1fe0ecee7721207e30fe1e1de032c9cea0f829629fc74a0757cb654fe2398be569a25b1cc0e9f6064440ccff60595f6fbc2a32cab8aa2ef23198c116f3e0915258da65e0726a927edab05b842847c47b7275f34f3c83c38d7d125f9daac5d7ff0ef96584c92a0fd1cf203bdbbf248ef45e9194f21749a3aae496b407b1c7942623c385ec6d18771b0a8e50c1aee8455b7f3dc117f07542d5872f7afaf76ae7a277a645d8c2424d883d3827cecdc1797edbfed1d1e588778afb08e4a17304dec3089f0fbbfb8b47df3f89f181d5c8e187522aca8c8f1a93437af7fc392fe7e4046b8a87913410108b01694cef68f209f9cd4e3adefea5762b4d1283f0cddd98c60552861b9cdc92e85da71d06870387b1e8b811549c66c4cbffd5aef8c51d5a38afcf8fda1e8df75ca219f9228823f81ef0f41b15db050ecab8538e700a7b7504ccc33adc6fc42c55d2cdc449f587311cde7a4d84a34939244cd00f3762aa2bf6cc6c0dacd49d399efad260e68b40ed7d8ce5a10586b6f2be6acb8b4804c9789fe9774c98e9ce1f513eefacf10cf8b3c56679fd8c92d6927e868071bded9966ba0f8751acbfb8758289c19f5c77b364331509989d020fefe849fb431d617eddc7ef5679b32f43aed9e5b4ac16bc97849127394d6643b8a023cbc30c701b8db5f29f9fdd328aa13a12a1307329c2c16ae961e72fb284a4ef088faac73df723166be2dff9efe6215915efdb5da776d710ec4beb56f3865809fc8f0ed02f04a3b305ca19d14dca44362be7a6f26cd4b701cafb714b5cdd08e7be66de6261e82d7541f5ddc70bb76bba01d3a7e075c31893d128eec2e5a679465f924b5e075c18fe5c6884d2079a37c262d2a994b78c243519f2aa014f87a0b003cd5f177cc6efc5e84157f1ef9785959e698c9fe6546da4b30ac183f6346cbd1c7b9c2ee1132d20382c3db60e19305f2219a1a2867d6d1ebbeae7aa987a2f93aab929f594894063ad19a8cc60d1956747ae946b18b7d0f889091bd481e7f48192790672a584c2a80ce3b54a2deec41979e040767467b5efed353316390fa4c3ff99710087a477ba1a108a07171da977b956ef2c9d7e02ec29a93f71c8660f471a976ad766c0a213a225c23e52b28a6cd2ee79afb27c1375cdcda166589891227f76a05318fae62e07d35cdbfe1e14322dcc57dd3dad3942ff406cd785a50d633a07de10d7e7aa1ed741bc175a6858293804a18e7c1e09324cf4f2b4ae5c5e0600d52bd9750cc8a64a125efe5999cd9b33db763d43041a696341ceaa1d5c54e1359d154d19ff495c0068186b3a0eaf3fd6cbadd75cdc0fce765a230ef542effaf8c0cd0d8e51f6e280e6ba2dd5e0a724458e8e5aea26b9fb621a78b2d56e0583a049659f0abfad188411506597c75a040fb35764c1f9bbd445dfc165cf4bbe920607c5a622758f74416cff4a206ccf203c59d5fce624e4d2c61ce4013ddfc5618fd31c421b3e5a039faad91c38d2e59fbe74f3cc1e835410460ca55ff6fbc0409b0132e23a40dfce5629f07450aa23752f3fd44d780d2fbad7026dfaad142b8f69461155f5c0285da6efc603c1f66f5257b9aaa7eee92466b0bf00b7cbe97b0abba6dc3ee2ca472b6708c4dc39052a4281d196b93d45398ed2162af90e5a30626b182671a23d90524cfd4cff2c0a9d9b2913ee1c3f9830bda2c02203c5df16aacc1a64bc05a391ffccef0e3f8fb692ed84cdf21c8841857b3034615b22767408930d29820c57ae96e81737e5b4af1f061db1633995ffc0a2cf14772021ecad68fd09e95643761e7610c8fff41a650104ca41bcb6dad7210d054c6e87919745df4c7f5c38d06e88831c5afe0432118b0d64d4b9e1a11b0a3d33c47258f84d19e938ba93b348c935e059ec6277b5115ff9a40f96704177fa2914f0c5b8866e6203d0cfa44a66e2b1eb71e198e5598d8172dbb4094e80abea222feb39cbc9919105a80b33a7945703cdd0f95319c2d695ba47a535561dcead61dc63d00f55ca6f70abfadc5c1646954475987bb9806b029844d13d2bebd12607303b66dd480647699884102aed25753eb654ad8609dcdca503927fdf73b3ae53563aa2615e9798e39f980a137b48ee8a7d8c7184feec1f23d9b0eeffb19345bd06ae4501be2898dae3733d6e0bfa96403fcfa2466996f90af5e25e420e144d799ee16dedf92c19830af7462a538f45964f801a6df9ceeb8d6c59dd221be856ec6b8f383dbd2389094c63cae5a489818617768cb89bbaed95e1fd59f1da8ff740fd3b9ee13528e520cd00a7c122068f7718bf60c658567a901442fbf983523916bc34c854d720729bbac8ac19c33029ce477acdc14f444586f54196971a568d3e08512d2b51cdc70b627e36f0e3564f4f830fcd2d33aea6a6f680e15fd75d94ec66e5f1d92f222d6024ac3e785f407b13ad84d232a35d3dc0d643960a27ddf13c1d8496efd30f99ba6b0ccb86a13ba29fcc27e386acfcf5f969a9e7f2c90f159efac4f6d5e2383b2ca02d653ef55482f6b1b542e095f35ace6cb157f7432e286deeb1666f1c41744bd60a3486b9f7635c48dd62928cdeb7d850b83ee007b69742afa60bd04a04b6f2538ec37656f130fabdb7d40a29c068826b78635e2b5978db6bf18f5a379d050b0e397fdc3e17231d8a3b7a431d9dbe5b2f175fa3a81a4449d2f887d0770e11f690781a1df8a3d9c767c33e650069c05ed2dbaf65cec2dab9108fd2271add0090c658f06dbcbe9fb23b009f8926b0de16a2cca7da34f6d37b1358495646977776e90dd2ad48215481d2344c07c79022d6edac7dc25674faeceb406f0b8726c5a6305ff83704696085e69bbee672fce64874e71dff8ba9f0af3b99df287f9002bbaa103fdcc577b1334425e21946b46daade17c344d74c6b729dd609d8a10ec9ead0ff14fafe6a16c6647617b8aa71b4d6b07512966d200875b72adbb95c8c5154bf0d2cf858eabf689be41e31d3ed25b1267a9913e24b4fe4bdaf154fa81c29b321241c156e874b7dc52663e4ce120b6a151ea7ddbd594726f17c3567bedecef2393ac075209865f3b919ad95e290595671a7d13c88bd4a92193c400a760f681ee0817596d62fb16bb9da202dd87e52517766f9aaa6e6576fb7d3cca5a208afc2e622759be45c61e3281d451823b1241f3ef7e4006d673c2d32e4223070f32323517e72c631b2d714e6a04a7287d8a87e1d0fda1b349f8a127880f30bc1db51bc242731d60fb53a8fa2e119d6a45f7104b4c057442e36ecf3e16ac6adad170cd7dbfc6f0e639bf0ddf18b696d2937de64fd1aa31923b77d5351ea75342445e9bd3c4d58fa911d013146e8a3d7cea4f4c98dc0cad709535cdcd2b790eb6e76e267a1e7aef94473461c9babebebf0ba6a1231b992643d007b79fbfd92ae0ac1caa10d16e92f6183afc15101d23864f107416c17693ff7e3a2e827af2906ff89ec8528baeeeaf02197bc3acf1a3144ce17c901d783699b971ab3ca7e0af70c3201225da9c0b28ff6560f36032b00b50799262c7106cac4f014899f32fb4e86321b75344f3d7efb93a14f0d8d8db836234cbcfae09e9a2e48bf2130522fd807fa464e9d22693f545c6c8274836ec915e5d3baa966d59546d25df237eba141d6d89a4b64ef88d31a3c504468af244171f2388854e0a1c92de15cff82cbf3736ce7d76b9b8047cb28a26f6afdcd4c0f71c90cf0ba989bc9a0d8f1c0bb0abf6e4ac71731d588be816bfb4609d7b3b89502353306f473412eea7d0363875cb30e9ea76962083379520e0e2f566b6d475aa808379bf2422cd8cf88ccd650a9cc5cb8ab09c9d30e5f2c745f439cf6cbe49d10457c4006ed7e46d94d1d2e88c6bc2babe0cdb490779c15539268b3fafca781f5e5d0f56c23257d3d608013067810fbd56948265d98280917d3cfa016a0e916a551b85f657053e3d4ec791ff05eaec20cf55d74fe6e1e0c2cf751548fc7ecefd28202c67b1aeb4756044ae67eb8e200b3c326e618809bacc6c8384969cab8de30960c9cf92cf80832dd9c93068c4d43fba37b80d4a57582bc4f20b4a5e4968503377aa51c7f8f001766c7a339ab727c1b43dd71d6a0eaf3bea8861dba61297f0c25d7611d48aa8bd5bb7c299f7fba663a2f77869cbfedbd0304f60ae724b02e08bb0b2a6d786d3a2b21f37ccc273915980be71b1d73ac756973c9ce64405ce1f30d42f1defa09383ab4d20e5faa393e26f9f047d3b85aeb35144c49b9515306df67fa9b8480a7b2e5b645e8e87642666448443df465800c3ae2cfa8c3ce1d6eb22d4290b0c97ce7ceb29a3e41aa51365d230b11c911994d9659ac0c8f74e28f0efbd4bc8afeb00ad59aed237a6787014b373ade4e6f84994ff6c8bcf268706992a9b31e3765b6939be0cf9288cfbbed31a8e98e9faa42a33df9643e4a6dd4393589d888bb2126dfe94059708cc15955803504e9f72e5292ab1262076b3bbd67c669cbe1f2fb4767542f21356ebc30792015347fcd416a685dec7c69ea11179e036564078da5b3b88d1ef264a5e3e8a8119843c6a51245b7d154c74f3bcf3f99b6a0a2bcbed7257f697c64b1c58339cfc766f3d403a0f418e643daf2615fe8421fedd43c2b9c88ca911fe57d694bfd4e92db58de7838101990e8ba5e142c02f7796ebd6bc9c1674473ca05266d1ff20faa487d9ddf4c7af8bfde229abbada9b8c966b24f313306d2655f03145bd66daaecd6ae1b748ffb7ad660ef99cae505dd7b0e3da20ae87c3916f7cc1e21738896ea4a3d7b0f27b7d1d34c339a6d896db5bfd802cd6e7869a125b1d61e0c76fe2cbf316357259697cffccb3c62d682bf84979837ede63afbb82fc7cb673a98dfc8606c3f2301e2a002d5e19ba821dc69aa7f40a9a8a1e21df67fffe918d38e0a7e89797af183bda7ee8cc63613e662962f5667fd4f626b8a7b72862eae75af23f816bc7f0a91690de7eab6df4b4760ed77f72d4534465751ae7aee8d5cbcbd7f237e299da50b4eb0cfb588639edf2493dd43f89a3461a652112442e6df265d5bb60a256418d64b9e8ebf945435146c0a947d98758741140719ffacbd1bd8be1ba62a7831c69b4817e37dd892f9d4bc99ad7ee83d320ff356c35993dea16515b36d8b999ce9a7d77f26f0829fa6840e518e510108d170380937b97112e25a992460df7ab3cb54817a2beba73c5442044b1816829f62588edfdcec0c4748eb113772d3cb31a8200adf7b65d090f642657a98d616c2751d34e81a44e2095af736b1b5ca08f7f6fb30e2f1af44a0a0ef15722b0ccb420790da561f26cb8e795088987fbeba2f839ecba481a0cc393005402f9ee68294c0f6a72beca27612cd52f7728e3f416c6d1afbbc9b219bc3a80464693e7e9dc0bbbab1fadb4fc07272926fbdc0045590b64a55cc80d8a58425af105636fba91176b64c777f53bb0bfc356550a48b58c0f12073dd03af150f5de0368cd26bd99c0e2ee4f77fcd16383aab8458d3d3fcf2be42162007504d5e3b97d5b413b1f2b73348b1604736507ea82135cd32c4777972ffc2abe6e6e5e366b023aef7ba4e9c4f2a646de4637b1165fe712077afcdceb6e19aa47bc72e86f60c7557bddd747950810487954ec53f4c0f7635f8d5c0b004d620ea080119cb86f7b528d9db8cd1c1741e8f00b57f1f8c153c21c72cece9cdc466732085d0811dbd0d3ff2cfbe1eeebfec7997c82b92e9ec332ca72a8a3ac90463dd89192dbe7427b4abc6a2d0757226f854fb5e47aa6a6d7172e5e42487b8db30fafa02f70309ee499936d2a93b60dcbbaa256d1e5366e798c8b2870b6e749dae3b1135f92aa23522060c2845ac5647cb4a1998ea0eddf920d3ca0adfff7c49125eec5b1ae25bdecc57d2d0da3430a4489252abbbfbd0002a2924b9f89a49cee689bb8051fbbaea10ca653188b7e9671f9f11ebd8f76199c0bc7b20e51eb3e3d9d9aab84729ea9a3798d24a5b8a75bcd4f0f315869fde4bb23d2e3f67b37de647f6f8c013d1dd1e8e40bf28546229bd9f263f5599c3e26b51e405a9c0ea0ff435155b831e0a448a16a94d0e306d32ee22fa3cb2573bf788517b4e25a2e2efeeff26b4df422b5521c54ba86c5276a9d9a5f9f798889306a575da4c9094e8b6f23784b8a22b754ca56b2f77f0f9cb41aaadf10651a325264840deec85b6b24c73c0688dc047e3454d407aa5d0e9c02f0fe62f1d6e57274516f1d5b90c93372ea97a7f317e35b37728b9eb3db485b31065c5e115fc68831bcb33e1285d1a4d6a3b85991f50c882a02a652e5949ed22bd49cbc5ac3059dfb467714aada12b56f708eb58989f3dcb7a95f0f5a28aea2e7a387420234deb1645e3ad26a6d72f5e8add7e165c9f648e4e04529d79000aae79521faeb3e44e59265206ace12d1ba63bc63f654b674c1d6d7d752c5ff18d091005f2fe0bc2d8bd1f8f5c3c68ca21f6fe90debad0bd3faecd9500c578258c484d4f7ccc4ba39ee9ec27d88e073b52e5d30abbdfdbb7f70483ea898ee3a914429c5e4fcd9864244aa56fa3da1a983777d877e2d50bffd7f45ff2c2f40b34e07138811bc4388c6af03c354b772b58b4c76f8b695549b8bb50a9a393647955f88e56072e706d4be209a98211186609e54bfd6cfc3b161f964dbfbc756967e2a6d174c2867e0e13640fdd0a85fe538e27584675aeb3c23d457a38b48d437b05b40cf0195866c0923ca207475d0820d7cf906df040fcdb4206cc74aa139b2091d8452b7d326808180e0d59b044869e939155a6c207237822f794f3e5e3ddabc5fd108c36eb8dff797251a0d8ecf2ee11417a718062f119d3554e8e399c866ccbc0d289b589453cafee65f05cd64968707b26f1e0eeced74adb6b0dcd84da484cecfbfaa342ef8257ffdde7e80a853af663c37b6ce8d0a93516d31e4e1629d773c44e763f4ec78ec1f93384804703b4d48db27ca768b6e6f5effe04e251bff3e0287e3c0962458cc7a28b123b1826eae63eb17c0117d80d86a670739cba15f7da4467e545e65643fe73878bc2c21b06f989f980005894caaabdd6238f335c2b7b341ea9d27de717fb1ff58cfaac0b2c14e5db847ac0d67c754c96178a7b633f7e3e44f68163e85c9cbaf7701b9a43e24f611f61c424d8de86999685e4f1978e248b56cda6001d8a9366d696d234f299793b6e1e3ba7d4c133839a4010304f0437400618f4a5ba659e32aadf65eb5e0783da40518761aec313c053c984d0b603df4991873d0f2cd4294cf11009419631014f4c9b3b8736876017f24cfe6d59e3050d85148b6587e1ffc2333f06a19fb802fe3faf5c6ba5de77a8ca96972d055376944ac4ea0bceb647a3579cc59dca39dd53784b8c765f5c4214e3a2fd98a98dd179090d1b26dbe2f932b84054e49f09332c6f3164369c6c2da181b7835826eb6d71f38d084f17e3c991cd1b574d93cf98d48f9e272232c58c7cabddc313ba3a5ddd47af853a2e3cc3384219519f739a5da009f9e7e3dddc99f5787dc28e5a6116f63f892f826fc3c52e8bd9b0bf8263adccdb9db1c5a065b3cc064273a15a7b512d42f9b8d920b5b2cf172979d367c3eb7ddca621e975430d84db7c6de23769a051e0bf606f0c44f9fd3978581d5aece8ab8b868d69272bdebdfe32469cab53057a671f73cd5fb9dcc6424e137905df2dd0d1979f3eae6af0af0c4f6f16314337ac2f3d2b0a0cbbeb0357c0f8569bac819cd4c76ae0feea29bb2d3967061598c4d8ffab2d79dd6322f146222fbdec90f3ce97f0567e5fffeec5021281da86502684fd4536abb94b74532c45c224292f904f2decff8f4b5f8a19d70b22ac8c8b948434d2f9cbc0f3223c39d6d98fc5598b74da2b84fb72b2935582781951deeacecdcee5af439b4bcde3466e9022b6d5e5f7c21b8002f90d97da1ad74667cdffbcec56c354e6c443526e6979bb8efafbae1b90422d7441d1b15f7765268a7c10d15997e17891c607975ea3d43dfd731390140c0019ad2a462908d16cdb5459a1d3737e3c0348e4ae625d800a15bee5cfcdbe889f1e8ae3348b271f021daa08b4191396b0fe5ce8c95b4a30712ad1f30677ab67f576f053756d4365506ef40117e0d8431b4b56bafd4c08ee2a36e9c8a34a8f24ce4dc76a23a0e3a8fd4987c5f5c250da418174330bff87c01009f046bbf68c4060d4a9407d87d781868c898a4c444ff30b474fbe938fabd45d79105061d9de88588ac48445be4555535e146f9dd8b1107ee2f28b435c6b8d4ecd865f4e5b1fbfb6c455582bb02fc3520b7253ebb3a9f8ba36e2272546249f67e419c0c287493f9ec9e5e89a6f529004c0965661d97da23cd5741b0219e4fb41cc1720007624f46e0aefccc855ac16e692be5e9a3920f1060260445330a2193c9e4ffb6c349c1489e32657d01afdb47a712ed535c098edc07f56a978826654141bd98b591548b96cfbfe5e4c4c0bd368a62b4794f1ffabf2136cbd6b784e02e242d4e9ddb69bb515ac32788a601dfa829a8987861e9e53718c9df609935f8df18ce5e5d90fdc682ad968eae49ee2b760d244a48fe863a9449cf78a91b6c932e16c366f8b728ba01ee156188908540cc015a99c2a352f402b9b91419a045b9e30e1a0b0bcdc996ed88226497e77411422b81db75471805a6349c6a7939a96dce72462b2fd9430759b2eec257a4645b9b04e962f9fabed2179999ba7212fad1dc54c9e9fdd245def6cbe638ea4d28816dedff1e0d77504618b84219f55cfd71ce86d4acd4e36a25690ec8577061be99a57a10de8aaadfabd5c6360b0617b775a38e5ed1c92ebce1983a453ad7107377305e0ada7b3078d0f63bf4f3d4f481fe7b5eac5212b926799ab8cc85fac705dc383a653b7490ee065c22dd4976f124fe9b7d0539313b17ad1782fbfa55eeb3b5c766255bfed0f5dc78cef0eaf3607d8ddab1a0a2b9fe6fb03e58bb1b6d621c3113d0385f2d607fde87bae4fc998b4c5c642681097cc7eff92d42450ce5e3b3b0458fb402bfab0ec60953e29fa5f7ff2eab703788ec5938ad214bdff8a6c65eba9f9b8dfd7beefa79e11867ef0807781c7aecc18f48c9c256373eb5c61c15ae063fa06249b627a43f5f9a691d2639c7ccd7d6f2204488b988a1312e7990e59c3295748e7afb4cef0e0012026501dc83d5ae7cd8428fdb3aa9395c07946b01709bcd6f5647b4431ed5d1d0179badb65e9e6a94625dc16902523116fb561cc021efb47065a40fcafb29c7d034df6febb9ee72f63f6b75ab0575a98c8055249d0ec5789d3e6c3f05418899e83a0121baac234a55a66fcb6f9b853191ee440adf3d29bdc6e5bcf5a7b7becea7009ee0998d9cb8e5559843bc85a11308a232dff7c797080319d2629ba014fd27f573fc400884efe5e53a84693ca65fc7a21c522284a8ef00153c80d176f4b2df1f81e64ff3420b58e1f54013178d0627f4fdbca38973a352dc4ce4500caad8281f493878e4ba4e7fdabab159d5aa39856c03106bf654ee560ef0a7126ef239d0dc9e4048ee41194a31a408a4aaf3a3bf698d30ada2eb3524eff248a995083f86e9d23c65bbf0a1e0591389f86e93b17e909b136139181da85c1cf28e890e3cdcf8028b2f66f85a509cb19ca8c214e2402c0107870febf05bf5c7cd72da5ce6919580c40b25fea02e2f1c0638c88c4603e5f6604d8fd91307dd3db3c519b30c967d33b1246d103dad48213fd4968840c185e1882f9ea757916ea67852189710c7dbb86ddf4f070d02e165452fe33f593e0b8050dca018dbc5ac7a8569752a9341a6efff0810613a3167c1a1273762eaa3d1b5650f46de18f97726076be147c4c4003bc9dc707272743c3a20ea46a1fbee3a3acef82ad1a9110388cc7fc2b7abb9e9ef1c4e3ad75fd5bedc2fb5d6d3f11bc1ea3523a15ef19c231858f522fd5b15eb7497c770fc83a45854a2899bb9418de0e4dd67771900fea01c4ea7791802898c5a4cd1cfd8634f235b789eae0cdb59c2392f59c1719e73509886e2750a98772387317310c2e89b7e85e93031869ec7e9a68754daec807045f7d57dab90e763c69f1d2e51ecd451f89503cc3729eef94b8a9f5b4a9355e6623c06c0254746452544c7527a8a4a667268e780bafbf829c6ed2b8ac1ba63adf4d0c2e5e46b818c480c7c4e4f389ce5361689d24c8db95289095eb206690d4d6588818fceab82eeda359cecd6008033bb79537fc6e6cf4948ac28ba3f76a1e8ee881de5ca695e164719c8fb76b2f1f6599908dd53661717394c3dc53ae7448b723350d2daa70f09e8c3f46972904e4e1799a3123dc8ce839c75ec88c4017072ee4a3b0a27d46d0f53e055ca8e2af86dd56788b93c662f8523761a877986934306c206dddbee0c593f546028e88ef679845e81b37c2583ff9edd684f24d2774f5f707d54018c3706ec9bfd56378874464bda32e72d615844b7b789e92e3a7156365b0a370c5711a5da95f982db85d68a8269e39523f18d37c18287abac9ebe283c332b9e7a6a483d17376a87c46bda8c60f17bdb00e221f3875fce3bc6e90b285610eca0e5a2343917cdfe67f4eb27452a9d9d2b3d36f09a579ab2eaa7121bec4ca053812dcefe1881cc800bc2bb5a5b8971506081c611169799ec297d4252d8ebcee572909cd45637151f53a31431a3c14cb3859557e8f56ce2a90e391a4a3952a68f8a446b8d3165736856fcdef20aa53ecf2fd7d6ce6821ce324bab6ab401212c43b56054e0e5abb2b5b2da5620fbd65efacad7520c2b7d0ac6abb718786057eb99050ab9a79df2fcd81167b6764eec4ff064ef3e8436646aed971d07c9df4865a8e1ccb79ce77164597e54f198e7abe96b02d249c0f51c0eeeb66443d953a8ba36f64337f481a092241cfe95527e99fc0fdde631acb485f30942366b640de94e6d5b5a0185ed0d09a713d159026153c1adeac9c38451a8f0da77e0edb871dc874029357dc5ca9c901fb27023cf53733603535bc2b675eb5d8e7562e0e093882d72bb213d7eb20deadbee0609a9eecbfb6df49af264404d3b8ae41942c576f21f3c28633d70b73e9236d0484bd33793a9218aa092c8fb3f0b69da24eeabcd50f4008531e7168edd7cd8331cdd027d1bd4df00c017e94503a065c0839b9a858fd152dd2da800ab46452b73a5e784049a5318a86d40835adb21f5d89c5e0cb7e0f3fd060bdb42a4473e7efbdc0a5154bb446732b8b91033bac8aaeea80fe19ab51c8e234cbcbc2d55e5f9a5ed2dfd1ab0bec1073ab4991c012b088f15ec887b28d895fc4df83a45faba05b15da23372cab6a045f8f26e042e3db2d42930a58d4eb0014dfb1539fbdbd77a33f8879d6f82dff5c406beee0c8510108f1894b6d6270450b566988e6ed474a0c24d4a8a24e54e0a4a74b88a4ac74f0e98054d281c084f2b6058105e81d68be1546ec65741b026ec8663ae5e4f1fb91f7923b7397f61353525ea009d4b22e948116772ffb0c2159579bebab531eed09813f8636629c866d7bb58ab54d29340e60c56b90f88423a3cfbac0a13ac7919a81d005a6ea1f42d5f41c8f520915d909b3be0b7cd59d9e197080e23219d2ff62e4e2b902a6b10a37ebd221160617d369a46e7facc2779ff2d720e7f36743dc736ffc5834b8382407f7221a8b69fefd3cf190388b662572bc92d17e96b1d80955a278c767d932166adec7a3f1e8bb4cfa6ec0d36fb6ee14d45782efc4bc65659750f88fefd0662d458cdd3ae7c84835f59581bd0ee25177d56d19ac95cfac5ad533b9d06674d246f99b34732909bf3d3299e51a991c4a823be70c38c2a8a8af368b54dbe73e5ef549326fc07cf3564576d41a2d94102a4977c957f055933a09e38b179d20c8430d7721ad826bcec00824ae37b366f9d613c38afc51e9262e67cb0efea5a95ca79d0b30a9dd587e87afd93d106ea47a3ab1a7ca7f8b8ecf19ef98ac88a24b0ea6289a85d36021a1faac161c8b344b65efc85a54c4d787dbac27663e63e6cf8759269675d37a47362e96dc778ce7d19a9449735cc2185ac67f8296b9bc94c42f4b63d32ffd2108704b7593ec828e59c780ddbe2c3cb409639d2731f812a636e5464fa6f6947106b5d3dda42877f0f8b6e0e55854c611ba8a2ec071734473310f35d5b264e2812f2f1cbe6246aefb168000aa2a33b909c8bfdd2e549dad93bfcc81197ec0ece1b95303aeba8d76b3553936358d924569e39c716f2e9db15409992060112429546b918526a7066f19495b3379ad83fc35d17977e1f1a33f67c4c37829940449cab65e6e07dcc1fcd7a9beecbaab6d7d7dad3b404483636bb79f9d515a44e5216d3f1b8b729f8c7204b36416c9dbb1df50a2edd5e8034e9db0176a0c6d026a8856c6bf5a52a5b3ee976f775efe76523ea3f4e1c05892f0921e409189acd57fe6de2f4375c51979215ade8c274a8e5ceee4936075ae3472a82e258efda3d4a8973ab54ab2b1f85fb08519e4b9222baa3c877cc16657ad08e35604bfd37920407c4e44cc718d6ca72b0e85314db47c20396c7d8207941fb53572cd986d40a0eb60f4b514acbf9acb9ed2712e86d2ab1e63f0d0ff5d9afd49c41159b82ac4bcfd228d43bf8d18aa874e529a8686a633d5134bab145ea63dba565918cc115d9901ceb077a8143562896596483e455ab0562b3bbd07241e4b422d7c8810f41c42c3f8aea520b5703e7a4caf5e5ce5757c3b571f924621a6929b4c22b5ae059b353838a4184b108ff9d31254a2899e47de4ca9f58f6c9482bef35f7900d8a08c120dd648da54584a3b76c047dbe23a3df4641433ff884311195a802a9fdc25d9c2ee1334b10e882346452eb1f960ef844cd099869eef92ab4d6c22dac8e89d86d124161ed2bc67cdcdd3e6f10e6b95b3886348e8eaf8b8a0a9743bae50af06fa3dff6d902030e98f8f6a1f724a17350452d175839535adf357b64a28d7d2bbd09409b129f1170dbc029b5ed83d34492c79eab307a8df9ac4e96cff63ec662e32238952c1bfe900cd60a6c64e90a61b5be27879089ef875bc47aabfc5b84c3a85ec75d33ddc31570988a7744bbeea0de93d0fd9cb17a7305fb5254eb2fdf008254149e513a14e9a7ae606e23ca4a57ef4546cb1952796a8ec95131a72804d347f040ba64e87a097b5dd5db039883f6a25f329e955558b9f3a371e72d62e97628ad5909b6b2cd3f5f7193362e0a2fbe4f857defcb66478cd9c090f14e19b100447f8c3907d77ca48390501cf1dabf388613ea527bf95a394bccf6d0ceab133f5e27f6e973d6cac56e85d4c055fab3790953dc1cfa7218ccd4458a6b061dd5e25859c198f3b8cedc2455ce22a69840f428de52f1e9a0e752ec473b46065a837b3fdab193e4b93b797992cebcac33819a854ef6e88dc2604f07a27ac564e0093f83d6c4fec9f51d192eb70fa58dabe97f4f9bc6355bdf16cea05606169ec7399dcea811059335e0baf00038fd059098dccacf6ce0236ebaa61e24674468d90e2008b8405c981625dc9f39c7424070dea2947249ae4b7c14946dcd76abc15ef4dd4c3d005256c2ec288c830ffd674223ecb70cff6fa886490f2355945c7d5a7724bb856868d4398cb6bc7c7437bc4162a0c9cc481a9731b7dc33d2edff2dcf54739cc16ff2dd4ffca4dee129a48a39bd6ccf865e9e07073103f5ec75aab380696ac6480ccc7e447afab300aefb0743a93f845af7284f4f204dce91319a68a5a1611016c27bef906fb79e4eaedf8f24c012d8f9e8c231cf0dea713f8b21c79196a88291235de078f223cc8c7a543d39a7c920b27b155ee057a0d997f99f0439316667c3d9ec10a56880bd2d034cbc963ee8a2d4263cbf350c3ccb7cf823e085b23bb7365595df39177d6cc4384ccc6369a783e78f59f6ebb9b63acda75e6bbcca63a6061be2b12a2ecf0ad2a6c7c8cc0713b961ad2e849eb621ee4380fb1b39e758c96e107a2ae9bed889b5f8ca575559484c712a4aaa84e6b35ef3cd35f5f1d666f6d39524c9407ef8a86459f40f01729fd668903063d93e12d261161f0029ce38057f13f53c5a6f259be3c8ce8e47b10e527606fac0f234374332ad5bfd2610b546585c281b30cfb53adec6eb2da38f91414845bb49ba5c1eff1f8772c5cb0e849e436cdc148d2498cb68f7aa4acab0fab7d62e927d6905071c521962148a3816eecab5ae73b86866d4ab3c9bf177deadd59fa607d6af1204056500e2beb513b357531144f57f9badf4897ba44e443600a49b9f0acb00959c2d811e48d68a3f3782a843f63da20fdb4b17c128c11f3d3ef9399ea56773a7cf422c0b2350630e846683e22a1d356c4544b457f1fd8b08a0ba25575a60eda2b84e6894a7d573b64ffce91eba9966fa093fe34cdc3681d3fab373b22a38347d307c33901b5da14a2471bec0a6f86272ac183c1989f6e3954c832e9bf6967cdfb2a50c1f2ea9abd177da86ceacbe17e1c2acda90e9da474f115aff3ebb60983ddfd85a97a0778b0e11e45fd334a83d1f2dafe7d78153e8b6c1e838227e2efda462ef9f54184781016f192b8415036294e95eaa66d989da465b3c4596c16da11461af115d7976ffca88fe6710caa3e4ea7e1dafdced736f7c0454b7696fb2b8426056543ac6e5c8e4a53eaecbf04d2a24af65ddc9659570facd627ae6cdc12bf5557c66ab8187be11d0026536cf29e91c834863033cac5e36d7c0fcbc6938098802df09992e3e002f3999e725e92035f6abfcf32754c25625dc449ff1bff3e1cc1989f4065de7c9a53e01680a65cfacdaaabb7574a7c9c53d27e191e26517627ded056c05bc933d922981f86877618a856e6e7930492c7888024a80dc2b8a036a200ced5f70a6deeba30ad18fd12667751373844695fcafc152bf39115e0bdc7162dee23364e146434be5ac4531b85599202951ac27025b6fb11e9e81349cc3903cc928e80da7fc39075884827f86bc74769fab9854c46e173e76284a3c3bb916e89c0ed9631bbcf546c58f2a13e401ea0e3119f2499887f98dbec1d111cff1a3b922786a8c25462526f97c217ca7cbd3c7398604e34ee3aa6452d3680f12787437ed83a7ffffdb9fb19d804ebf2feada1c428dec1f7c8a096e7e9fb212495c60a2ce3ee5214f53bb148cd4b1c30331994a8b8547da76af7228b4d85a728dbab8b47e62e0d30896c9f4b000250d61c8672b9acc95ad2fb67b92a613c3e0588c06ea11ba014fd4b4f574acfc29ff310ed106b980be607e34313cb11d5967b653bb42d190f8d634dea8be6047a9ae45c74acfe4fa76576eaa2fa7bbf7f956ade698f9212f475ae9409b4b6e2ee890431664630b0d2a8b79999957b95e0b56e9bbdf5a6fb2f7a6b3cf025e4a9ab93efb9abf5362ded9cc66cae9bc999edb0f3bb733eee13d7a93f2c95e5ed4853b18bcf5922f9d6924751dce34352d87c7ea28fd37c24e3655be29afdc8e5f65752d975dc52ab9d6adaabed9961b7faf740d756a662abd42c1dd8308a586ba68cb6f1d58dc6bc604438fd3361914a810c2ef98ed8429e968cca797f37e373659ec21982a3e32aa85a08229a4ee9326e13401860328f4b0f4260f0908723513179feaddf3bb0743fad230f346bb0534b33ce2d601dc788850255d9499e864b9ebf408af42e77fee682c0d6735c971f8c3f95a08b529a22006c5e8b6b5ba9c8a61168e53cd9d2c6e50bca96a9752be33e766cc5843869e981d7e87cfce636c97515d55e1152721c7ff580d789e7ede815f7224e4a933bc3729f84a12bed29986787384b538b080e0e6284d359d434acea5451e44e9ed49880db26b3400af4ddb16b9449a6daf04c3a66902f165d54d65d8d9f095686ca6728fdc2d8765415936e1192c93443f138c886a4a1734f86a432df08991652cc62619ace2ffc932792033201e91afbb0de916d66be2eafab976601306d2100cdee54381b1d55a12f700ac3c6c57fe6306121f9e228dab7fa5767e6c538a3c2030996a63757cbcfbde38ebef6f7caa57f93575726597808862251188a4bac40133be3c292f9deccbb150382eba265c5acd4856800cccc3092c7ece1091050425d6b8895df4d0bdea29651e65e3f0e2da18abeb1366921849ae13f2e87f5f87aed8603a4d9ca9f2a8c655a9027d6be60b1ac896a19a7a7a5e5738a9534ec0abf1e9158af5a7c87ad49d6b8d133d7f4af7e485801c4f892e890955e8cd1a33db3901ecf6cb815ae098d6673846090e6b8d70cde44e0acc7dad12ac344c6df3e7bf22d3531f3b51481640ed02c2fab61f2a96a0fd9ab9926c1eddd05439c56ac5fc3a72f9e207c5f254564f525d993db2b4ca24210c9185d3a9d76eb5d6a7d51927fbb14f996b4d8aa6f56f9a706ed0b0b7df1ecd1a611b18993079e3e0892707ef3de74b489088b49b8b923a98751ece0f0dafe5ded949c3fb864cefc772654942ce06429adf8bcb8e050105236ffc0fc992c021426f0092a3cff37c9a6c27bb02e7287d5da59b19c20b6b2b4cb8bc3b593ed044e3ab4c3d1e06d90ff72ebcb7d7aaacfb2cdb75358e32cbb030c3d679bdd49db43b6ffe164d2103476c69e016438fb441f55fcd03c82ea38e284bfb0060603eb9eb7c0ff04acf8942aaeed1964a29c9c37f2beffaeb9398d4ab8e9c14e81b072118b8d137eaede74dcf96eca38201e35001061372f02e2110d7b2b60529b9f1efa832eef23b7e2c13a1b375565de63b5cdb06fc2750f383c09bbf7615e0537e85d9790e2ab839f400e6f75bd9e25c4377920cf7df8812dc9bbce31c0faa73141e69fc2ca1d42d43468114eda5578705ead6ddbc03ad92acb4eb8a1029a8c7f692f074bf573cefa3fa3c021086f7efd2d31ab95845f1fad6c942dd87b2f5c92ed66179f21cb4492e0f285a60708ad976dcee98330d1199a7330e289ff3ef755b7a88fcbe4d17e38d3764166d0f8b5146d97011cfbb381f5bd11d139a2a70b4e552b1d71199f6bb9878ab4188a41297cd9a24a02b3d1e79b37da3083b644aac895488e30ba434b534be80e59173909a57e1afcc6e078ee4916b4c6330121985bb70974d3bbe70b885d26b5e5a5fa14e6b0dbf508a1f80427db8e5cc568e564518ba31aac889aaee83aaf8879aeb7ae16495c644368c59345f751640f158e62788deaa21a47fc07399aec050e5d8dc0264358320e6332db70c326688511befbad13ee765f911587f309725847d81099499ee2779bf420e357e1d28c5a21398d2b60b9740abb86cd225190b7f965a365a8e51cb53b5fd68c80791f3e01077fbcd4696da6457503349b7fc9b39d6d6bce1b5ce4b80ce9d0be02abfe4365118f8db3bf5b5c47947782db1a1a6481007a94126c2296d0460dd7c9ba9327b151e3b55308b25f6546ba052eb88f3ec2a1e7b79a2d2143795ff770aaa1dcc46515c977504b40ddde0f3afca45295c3f65f1a652892eee3199b954424ce91489057b896947184e623f0591d9644093105f916ed0596bbec3ab42b27b2acedf308ec8b621cbbf0a7dfc8c46b11f7542948dd10a9526b5be68e9e6c5e046d5800f6464564b0c9bc078021bc80815ee4104c5cf332c54a2305bbc675ff650bdfaf028996f4e55efdc8777c443e1977eb1ddf8f88a1439bdcbaaa68d7d5e91edd7f7e1a3ae04b80690dbc54dd81a92014d6dd547ad6fc3fe65409bbd168b1ad9f633141e65e2a69243d41a82d7b43d2bfa0f1759c14db4c44a2cf1ed98ccd813b8ee5475a8d47fca8634dd9ca8e249068783c9fafe707244aa259dcca61fb4a1b2c2acfdf234ceb3c38f4affbaf9a2cce5ade0c55d94f699e9523149241b0c8a453dd96dc1e0bc1fdf1a1a363dc4d655ca623ed83bfcb5cf090214257eb1dd52d34aa4c80fd5e84850665480fc93f6727fd1ab9e9e173ec64c2881503ff8538eb660a145da9f6a3266211ad05ab5b5a7c15b4dcabecc10a670ad6cc51057e79dab3100a1bdca238b92943c8c3397b475b78db7d21478554a6ce52f7d4d9c9aaf3142aad60fd5b917e42489b7866c747414e8073633bb84a828226d04f467dde9c1e31e318f3d678a525a9134f03e5c7213d2100eceefe1eda60ac49e6fe12b472339f19165b468449f920abefc35363c403ef79524da0011cd0586e979890d1d406b9fa605e5ffe6df0dc25691a2c16f1e932fdc0e5110d0cae264802192da283f1f502a34f02f9c8fa21a50eeec948382f52f14df158cd1d506d08dd587c941ba534c0543506b3f927ec34c190340c19da70c5e64c516b51979ae81b55224bcc8099447b8df2ecc938729b9db0c7bf8579e0c370fd51bf2b369df433a17e56fe732ed37c5d2931881081b5dfd16ed2d36551c9b072dcdc03bd846dd8ae9766cad599cea0943722f4e69a13272c906f943dcfe39c8bf5ceb582f30f90fdde77db99c99e9a908ce60595863767fcf43f56af5acdd361909abea577fefafbfc78144b124fcd024d19cd96bb0e2b9ff47db3697e03f465adb4e32fe982cd32df032973396b1c60660e20facb225543d0e19d04fda3502b40404a0275b89bc9950456877db7b738511e974b27c7ab742849697eaa8c6428dc308371c1255670c43754edd3c5cc4591b08c872979c92425fdbfed793ad1b605db3d561ecd2d60c4d11e653e08a0e196f22e7aa01619bd1441b8a7168ac40802237092c71985107dd39ec561a167600c902ae2378d8d5c5262b719ebb93bc1d3989993dba3c6fcbbcf2672b34059e71f9f14b26112530084beedecb8d711d8126a6cf9edb53e6b4ef492b3afc275ff513099d8d299f7e36e02b8aa92d4c700607e6491665ca683f07facdb39bfa0bed7c9a55cabd4a6fb729eaefbbcecc97960ac8b8200910dcac5688ee2067427886a3dfe033e2c2ba495cf8003456c0944af6f22ac94340c1203467ff50bc0a7706219f167fad839c3aea6d3abd55ae66f943af6fcf1172a0054f687e3d7d1c08552a6cc317804332f09b3300a3ca27a7c3b2599cdecf669194d3f091e16e1f7677ab2b4953dce14fe4347a7016e84a92459240e718a194fbf8265e7af2f2a94fa6758f12a5fe0cae730c4dc659e3afd0bb46c98a008afbe2348bfd312f2fe11ef55f63866124a125b22f4d58137e2e46ec8fed94275050a90d422abb59b750fade3ef8e89a57dd220b28600eeadf6a5389a6126110c3b6686bebc7371062101df91906f3e652f372bb27bb2edf316ad751fbbf271cca524ed3319c1cdda82f446b4fb518ca46a74da121624a225f89aa1fcf22e717fabd7fd20d8d8305500466ce73d163a44697aaa60883f19d2e90c9a9b4dc9a6358fea5a9053751d9f8ade9e02ea4283a26212fb5e9107ca629743affceca1ea3e3cadaff97e43a43eb58651152bb9ac15d7948cbaf0bc46e8cdc7ff65a21c073548af7a56bd190a6d117fd8d34f655f8cf306b52f518025e678d5ebf27dd22cb8ac9dbeef1c6c8cf3b5216368675dafabc78f4a15e3758ec12441d2dc423a8d80f382b302895740f1bc698d90a5e5721b93f1e862eb791b58fcf7fea87c83fee1db1ddf14f8b18516c25a1d2f8faff2e0061bc86d2d871b9f6dc009255ef1d7b3f9e59f581822e402835f81f5aa0d077bd8ba0851a58281fbe2d9a372d6e669352f8fdcd1aebb92b5598fe5a22739ed163ddfaf2aa6acbc95671e2d2ff9eb117222810487360bc6b9b0cf804186348809c9f60d570e52fc26f15ae1a1bae1d83953e388eec8641756a546d4ff8c8e134ea16d6c86af809a6ca4313abf81ab585e42349e52c9ac85f7f207b6ad146143e6c869409a901997921f4691d56dda5f12d7c6506d9a9714bc229738d34e93f04154922c289535b67b689151ba93261c6c0ac2821bc491336864c6ffdeeeb8e9ab767652467cbd6f4a631670aaa38dff85cb8d79e8f904ac209e9d7e58a94a286bcd52ba079281eecf93f8b586f414f4a9aff0808f6cf7817e93a41deb8d7d514c637b4c227c7d85a8e4be483f26f309fef1b2c4e50b9d82d37cbe8f3315f1428469d60ea016740b552a3d23d9386c0a58c207b4159ca77edf46a3887af75e2f1178874e064ced0ba0514b507a7ed0dfa309fbd971ba7d8e3c2efd4d51f53dd377a73a6adf3eeaa1cf5fc1b42a502924d673114898bc17f92e524c867c161f339a8afd90441d4421597e240db00a070f4b78aa3712e5f07e9e6a307d2139a61c5938d01af96e61acbe97a0b7ed91e440b7c8d09c63684156d3537f34e67828e685685e155cf249b2e284763910168b45e311bbff0eeaa628b20786a611aa585fd2547797a71a48bb62c358850eff6638cedbc7064f495cfc8c2f7dc0a9aaba64a62fc76e6545258fdab66c877d1c781dc5192ea89352417b6d35f759a1b456b6aea7ec7f5f7727c9912c2a9eaccf02c72a57047f4bd0773441afd4db2561312dab8a279b6e8b64ffbfbabd2f390c784c3de1fcf62c1df031234643adbc199ca5aee3e6808667743c6cc6eb038a0cd495ea9e2c9432f0587d8b9678a6df575b62ce3b0fd14796c128bf2accb21e050f029e70af379e8f4b9d13db8168aa36c2b174ede22dca5efce02e06563244b1f6e5ae0bb84104dd7a1aafb801bf1d5975f0af10104f21b29f03c6b9c02ca9269bcd6f68d8b2b53c74a2d759f69814ab192f2462767222d2bafe205821473b2028065449e2308a0c79383af222ec0a31db221c1e182bfc58d8ec57d11ab2ddf59f111de4313e5197a96da2d22ca662db1c7e604de3949d5dc38f67d49ce3f02e6b15b874947fd252fa96325a37dc29db53b2e8b0b030ccc0c8d9c2f4e6fae9a894165b884d50ce8db3ed7566574aed9fe56915ef18684ab5c4dbbd8aa36b2b5095b8e1e303ab7bbdd948adf3521dce0f367237119ec4795b73a6cfd857fab76cebb8a845081904cca91eb804b3660e73eced753d437b77299186d237d7d0527b34bf54b657a732299fa25d456296cf831611472b68af78cff982ecad6fc70bb9ba03ce6a5a216c3186d665b454e1ceaa3e610b35870267bd80cc46c976e7bb13bece7b0314b6f0fb402483a29304d850beba9024689585913fd8872f9900f0af4499e1d84fc05aee5d43efab2fe12d001260c242ccfb448d5b777eb73b3712d0d200b987c8d62755129d8071768561296e1cc5e869a96a06510eac4dd5b4332e307b45bac16932ab123d525d9e0804809176500767a9c499f7e8e5567994ed44e2e1e01d6ccbd515314aace1a1a1bbcb8827fbfab4a26a86c21f5b4b77cf38a63100ae5fdb04a3888494ef75ff5eb79c1b3bcc86fcbd72a62f28217bec9b341485c4f7feabb83e1cfb78162ae11ce213c43e0082121377632de03fa2e7c930b44a231b646482071e037d3205222aba901fbc51eb90da5b1eb05b61033e412e70cd336e2b3990b61920f427f4d8117af79c62e16a8e8f1caaf952d2212ff78542aa1a00b4ab456fd1cca815ced7927429d2fe8d8d469c49f14bd83be69e199dcf8854bcc74edd6b919328c375f80e9e662426c8d4ae680ae89a7d0375bd7ae80ba0859690427962900c5cfff2331c1ff9db3ec76d7a493679bcf1c44e4d032bcd9e20cbccf87921d6974f6762456c708b219e90861afda64bdd9be6c1618d6269f42684c9e5448ae033e68690bb2cfb12769c5a3456598b1d751570c615a201e03ee9d302f0762cc64f7a7dcc972e57f3b5f67f6328b60bdf2f3df5cb5afcc358864d45ba39f98aeedc8b063608c688986bcf21d6c0ad2bcb5f6cc1d62dd3f27b8114d6c9a8241031e114d68663ed8437654c3ce5280e292b8d189744c369f386b5adeac24ba50ebaf8e4dc4667d02b1ec7e87128538c9b71b9db115d265b024c2262362470879f014e1b03b97ce221087b5be51695ddbe5b1d7bdda7c48e32a4a6b21894a60952e19ca60ba9805e609dafa33aaa1bda164b04df763d227603cd233a3af2f636a0548b78728a3aa8a2e3ef969ce64a06d121088b8329ed91a3912616bbb027bf6749bdd92af1cd63b61a2c9f43c0a0f59d1d24a8fbf35178ffdc02a44e116e2d2078bc7c2b95af180d767f4b498ba510e1e1f87dc2087e9be7d34016310c0e7e2be31c9d5b909ce575ac07456eaa4d2a8cb9d81b5add3945b030a3a5b3cb7e3cdb4eece729f03a026bc49754aa1531e028c8cc673a32c8ea75fec10161d1989a8e6034c8428cc76c930f4fac2442bdedeb0f3bd29685f3fbad9b0d236d7b4271abb161a26dcd3989e3a9ecda02aaddd296990512620759885b06976bee81ba16b0028c4ebe02a24d8ecf370fa37fc619e6c79453e3793c97d41b7f016d9a6ec2c77e40e2a35f265637abc911bdb5cce354d8cfce6872960262bd1b1103403f55647a26f692f836ea9ed4806ef276482f41e0d2cff1c10f2b065a262231cb01a8ab5178de567839e44a20cb876980c93419da1e1e9aafd4c172904700ebaf6c470b3f8cb974e9e7dd7f24995f3855310be8ebd4db7d8a2e4b9e5563324f58c9211cf585fcd15cbf9b36dd2d6a8e287625ad1b2c1580804a5b1e375cb42bef9f57bfd94998ba0a81cc5d584776143d97e93ebbc18ab59be3c6aba8b678aaf67bf901746b29939019a04402ab5cd51fec785f7af60bceb4bd593ff42d72198d15b82628ac40f3c23164aa33988152be1733c272f59e064c44fdc1bc4258257cc66464fac8e8a2459e692099b1b2fc54c0a7b89915986fb7b0fcd28c316d65170116a44d88b2875f1fbf62d3d969cfdfc4f72238f7a8d32f5b5e3afcc4911f2b30e281858d1ee3eeee5d710a3ee15195c94706f136e039f8096e7cf83944610ffbc3bf79dcc3e43b25b01f8a2e84cc9e23da452bead5a9c78080020bff3f44563541ba3b855854c1cf38525570637f309ec50fd4ead90ee8730b5374b0ca21214d7e27e40be71959ebba6c6e74118aaac14b42a287265d6db148deca37ecc48a96e4b8382cae19db706c64bea8df71a829699893e5a7009e18b5d653cc5f8479ae3922569026870e893f4a4c47d32cb5f84c73aab742d06a551743758fec399e994d7ad0a5f111356ddb688448b42a35b107105d636fd9230928bc54b56a1656f4a3a894ed71471bd45642e5723128543387d754e3a6872eb1a17cf002c4536e9e026ccb07b43b27ecc8ff265f72c8116be2db26526fe64dabfe6951375cdd6f6b94f0ba3f6c4e510bbe2cf81f6308a54eaf6543f359843f4a7cda9d686b7679792904ad6e5e3f711003b6fff17d7d63a095d20204c51fe32db187c81e774469fbc5404e396c627b25ee70fac2a6ea1e560f350cf50403f889812e10fbade0c2dc6402efc785ea9d81b0390e9a553ee67178f9db469eb3bf1aa37a3c501667dde4479e3a71c50e6da774489b21972b6e4b9af4e6941c09cb06ccafa51aa73dec7b14c5a16c8761597c816cbc738cd628402a6848bb0d13825b3a375950b52b09aba171c93bd40b54d7ed04bdc580cb53c2a977b095b28108f25c84a84122af0d4ba3c7b5917bae94ce78ab17f076761a3ff7ceb4ce13f16dd02a984257452f79ed2aa58ce448ae9fbc16613988bc6d36fe86f8a2af1a4c1868cded8a38dbb78ae371a021da35f64d74e1e656c8d7898c12ccd5dfe941e2964f04ecfb507d0f24baa56878804506336f118fd9eb316a669258496db7cb4f2a35dc598080c13e689a9313bfa621b2f0de2b8f7cd855b9543794c57c9082efaaa2c0e3fc877283caafd5b89a9debd57f2a9d861c65e92b78ad3f293cd16e4f9d853aa616646b878858f83ebaf30f1ab4f7ca84cd8c14925b49a880e7a1162b4afd580e06659bc54f09a197715f68795327391be3dd461a54fbe5cac673d8a6b8c23ab424f59679c519dcad87bd0a72348b5d7ecc8202a388575eb87a6a50ab70c60ef9f33631dbc229851fa0999ae3580d8f821aed723cddf6c0d54cc9ab03bb6546bf4c46d7ef75e16728432dfd653a7c919a6e6f3dcd3936680e9b067054d8c1027f263bfaf4670b0f5d1b48867a67ce76e8a227b21ee71a130ca232da8acf428763266226e41a8044b02ff199b53329e3419e074c95428a6520192ee0b0be3b9e440e8d85546cf4903d5e78ef9696dc361f8ae27a5950dd47804657b46724191838a3baef9208bffd656182d808b91e4659514e5a2ccf24e630b4455bb1fe0d9153df61dc0a90b6977ca0db71fde333e8a4b5626e008d67631928f65c65fa7c38aacce26b6ed94fbc25162c2d427e0a140cfb526db4de799e964911e399d6ee8cd520d3c89a3939f767aa036fb10de311a297236e18a9dd1198aec8227965cdd6fde0a16bdbd127da703a3752f9f13061651ac85444e958486b740e4006ac8bc5f3547d0931e2a208b066150b8cdc04ae160a7dede67d762a8e765d9b959ecdf717b95c4e30f7848268e80b24abb8c06f6b2696ac0779deb1db5cfc0a0a4ad3054ed5b7c2f778c1689bea45ad07be395b45a13a06c78b8af37bbf00f5ce22d970d213df8401287bd9c05df501c549f1a55db69ce6c327f9d08da30f84da606e242930e34d9b638c99e607b82ca09e9994c28bab39b66d804daa895d475454e7ae5d5ebb9b5a8d25ea5329b13b3e0f372d89da4d4b0b19abfeb35e9455618b1e0163614f9345c0604d0e0788c9417d0bc2c5a2222314dbdb2c59787bb83f3395c54deebbc63166ae738f4f3317f3528db81322b2a78932503dfc1cf03c9ae19ceaecaf8bcc4270a72eebcb7f9d9b92b7346bea5f2254e59d67a4b02923b1d19f8830441731b9cec96e9d3f9a60db9250b69515dce86b83b4b8b59542ecb6cb492c6667627b0ab89d1d21a0e085cf35180f04e7eaf1e8461ac5c1d4aaad6b89f61a78019b13b0fbdd3cab97e6ab4e6b070694e284ca0c68dc50bb349c731480bcc616a724631388c62c0d034b5942805c20d1c161fb0346871408c2529a1482081acf41693dfeac3e237e41b137d50bc7e6691d51baac79357fe98a1488c70c00f43714ebe2115200edae1b1226b8ed0faff9041b45a6aa888f4d2aea574d387afecf4aae40e876af193f5f7808880be803093c8f907c31ef53fd5bd90f4bfedb9c4d65a65d20eddb8414c2ae131de82af6e97fa16102ab5fcc040691696371b3058e0caf6b19251a04fd8751f316147662e46e26a3d2648d825b7a0a1f31a1c92f64addda0a9296b296ef37cfdbc41c82ab27924363d90a30fd9cfe1e9a2b7d06b67eb9106e0736fe079eb32573a7d6e6e7622e1a3f58a2b88dea352adb23975d4eed4c0811ca7f47d39da736e93981155e177489ddb06b652a7ffec6a9bd887aac05671563ce727ec6c608c61d2fd76bcf4780456fb7b645a7fe9a420615d098d3b0981a7c13629db953906857df669389dca865157d26f4d09063ca4f7c43fa3e36d0913ed3f068ff893e596701564cbf6d9c2eaaf1d03d8f5f7c6641816f032693c468835f218b413aad5e961e28c3e6451b9f6009fe20fca867df45944303c38b0478efab6e0cecf069656a5d1bc5961094ba410c199071a3a18bf200c4815c5c666c9bae1bf01ac2d9364e6ec37faafcc268d60e382b5a54f2d75e1084d082ad5a9eada49321f1c6dd6c5d9fa15dfeb613918d87fa96fde2d022511ffdab318c0d36ab49293534b14f1ab58738760e773e2ae0d1733f9e802ab96a65b6c41ff15e3db9c7995af5bbf179341dbd3912984c7e8e4d453dfaccd9d3171c050d6d19f0340a4e122da077e20324cf634c26bab12da0fd36d6c69dd158860771ee53bff4d769c44f48e30cf9c17f3763ad89e727cc2e8c750da19d3f1a282a49105dc80198c55cdddcdfab44eb88f28491cf5064c68402cedb2664c72b3566bc7efa896c7d65142a5ef51004a3c1aaace6ff4ad7ef8c1563a0e7435f7c8b109f1c2d5921a28af712cbd08de44e339f935540a7e7055504967b4bdc2fdc34a6f2bab0518ac0ab81baeb14968d13f78467cf9f16a0a982cb74f6367d96e5dc21715857c45b56a34bc5cd1f08d4a7339c62af566d3b918b3da3573dfcefda98fbfba9e46ed78e9ed855b88d28f450f9a7faeee229c7fc5bbbd32769ae65b113e9938ca382d99e1144f5c13fb3052c088a24101c78f0f781523ed2f4953dcccd6c6b5c2c22bf8d1866b489c4e18de010d0c16871caf5b213053c3b306b155b5ce1ba83ebe4992fcfdee32b7543f99c1c1e201aaa5bb3590a0709f6e625a0f62a83bf7a4790bad9a35ed33563241102ea3187a4ffee8bb9356ee43508ae165f15b75a2c582e7bbd43106ab78a70c3675f2462f5c8c34f0a8148a68be8a2fdb783b5000c755ca8b215e751101f155c0e12e2cf50998f3cde5e1dcfc9d33efa544f39e265f3d2b6efa1d72ee3f14bc1421c085f7ed07f80ed03a34a805f3192ba480cb5d318cde46c2e81990e8f8627152b2782c43130b2f179b85fe0f58fc53586b1c92ec9282ca31f7ecdb584f46154fbfc51f735dd2b754b55f5c222e8df297d420c245248a83a92ed7adc63aa7ffa50425678e86abcdfcf3795b4707897ddb57cc09353347059c23e2607d6cb3ce88777a7d07ba6ec964510f9ae627b2775f900581fbab8429255765677662bbd231e762dcc947bc554929cb3204bb950a48ac8c7003bcf8af45fca6fae43277ee41a0272393c595a0bf27d69d8d3dc2737ddc61b067bea2b3e9db956f87a28fdb0f4c7b36e71876487cbbf4bb5c963c66aee7f6d1bc2841b036d34e73d56ae23f880ff3d8b79228c4e5e18276cfe02c05197c90a0654a03f42a680ede0c9aad6b99b5b8cc00ba327a176ded4353c4108cf6a8ef03cc38d423e3749822edc4bb032b97ac49508607ac005c67607ab51db9b7cf55b9bf8b5bd9fff06e32292786dfa95bc7dd3f6f29f7f731c81df951c09cd887ab105e4b910f6e401e01a39991fa3f76dfba951f83248b6583e002c7dead61d74e857094e8a65ea3303786b4ae9d73f360e0b95bef0e333178b3d43bdd8e80b274bde1ce99d3cddb9aaa3986008670bfd7edd52c5ab9c53c07be2dc44058b90b3c9052431d8ab776a32be38360f63c9ba5b59adc1ebddf93de915d0000847d7b6d3b589cbea079d340aa4d8d63714c48a5850c8da1922cd24f51e0ac198f3b5f5f45f6521745b1cab7eb3769227bef95890529ef85e12ba7f58ebb378eeab70a48f5621c4fb6c2b6974e5afc99d138995528bdb777ce72e67325c7a36faee6b14efeab9493927fa33e2ca3c0cb15ffdf252dd726774e6c6e234246cac6ebc3d075d0994a4c6c7b33923b41b9c573a5048a944ebaf652bc1d324880e2d3582b61c97f926452ce23736961f5c70acb671b8fcc5575ee78e4b5dd338efc9b5e9535501a4f8f60b228e8e2e8edae74920802496517f54f6758f48936105db1a3fb8c20d4d6430c6bd1a55e0e72ce7ece7bec1ec340a4baa810572c9585cac64585545ceea99d3c49bee5c6184fc9524a5efdc6de27ffc420fe5aec469a7943081d7df5a45cc812b85fb4c92430488750dde1005d871911eeb15e5460d8aca000e5f50ffd09e7f6fbabf202f0653e37be319b42a0b5dc18b800a78a1859331245152d23e6276e180a39d0d08e22cf24bcd62d091e1c01e541c3bd29e8e754a578f5430a61ab90bcf15271ad321c539cc5551a593b0a866824fca9ba5a5136022b579a341a20b9833f47a3b93b86a7163981f6fdffc1094b40c1cd934b67370f57fc7a056178dc013a2d0940bd2564dd8e63a48ec0cdad072b8a36e9ff150bfa824939cde3cb84b74f046871b2309c3c34f83a0296edcea2e19a176b484d3fc1e2b224ac381ec72efc35573c3a1de089682eb21c7acadc99c72e12659f0d3b18e54e958aed8cd34874d96e4bbd3e5c4105ad8c18d48991247f916e6d45c12f5115bfec890d394a85697ade665514bb48a353d2aa0612c34b491f264301f8ba49912624ad1db37f15bcc9b615de07292621679884cf2a3fb08064e1df65d783b5825b83ca3d2016de55635aaf9bb1a16157c04c000647afbdfc8e0fd5c9cc652baa4b951579cfa26e266d489c7c48006569d5535c1abf47fbff56a9da319350044624bc4967c6ce3ff6a8fd1d8fc25c5b84efafd7d9e1393aaacd447d901c8c2d4cb4a296b256fd9322d748bfe4782c9636e313ce9fa2a3f88cada6b8c79c157e97927e33e41af6ead5ca6fefe1fbba1c801e1877361343a17e374b8719229a97e2d27573b55c258241c07654e94b5ae95928901b4a32d3b381eb38c1f37e7859448d393f7be203af7cca01385b7e7e6272c71a0bf531e75c2f8db70746eda28f098dce8472aa6f1f37b4f58fce56e0d3b41ab46a1515228e343b32d29b88468a4406de817444ee9908bf4b30cf57ad8d816b5b7629f67d86e439db96888714ae4bcc797d6406ff26e56e04b00a2f97d24073f4de215cde8b2be428b7c74eac190aa7dd392e3d29d29822be486236964ed786ff4e1882cc08fb578fdd2d9efe22df6d49b7adfc4627ba3e8e3f5f8dfe2619479d7ec90a61a8c975d66c762e0401638c7cce8649e24c3982b8dfbe74efefacb668ba0eadb07f5c6d22cb3340300092c855a39a1b76962ef3629f99e617acc74ab40581a71b8100af167f5a6915a2f3c65981353d4afe2efa45605ac7080bd94693b031c63d7489232ffbc51eb8b9a51f92ebac712480e311c0b11c319be2dbdd4735a200e9cfeabfe3b0eef7650c882c95c3fb1bfc881e21056b73ecbb7e04b3b4d36ae3f674e3fe55da2cf62ce899f173e4a46133f5d1864450cdf17e56c35b93af55e8257941b49583da4356999d37259efe236a639bccc2833180b1a193c4b260242222bb344f39b0029b6172a474cb659ff932ba869e5074bdd694fdd96fff7482a73340059c3d7fc6089cbe4be1321be390d565d346bd02443ea53b5f84bf0a4d2cfcfe5f7e05896759f4195e879f461b9340f1366b89036585ec13c5bc11ad385e921eb61f76d4c671672900f10e1f9bd3be650734c171725fc4b5fa12d64519bcfd4c00ea8dd36121bcb865172d3291953dfd75bb6c6e9fe2e0e762c74891e5a76b66b073352e6c4c035ae3cf7f6157620a9cf5fad589a7040e0417e6efc861d5132674f654998f6db8eb71fdf7ed0d99b507aacb3bb35c510e60b48ace3b2b149cb0b795eee2dee6ffeac1b8c945b6fba2eb94fed6f28b336841005083bd5f121a308f6d4e415b3ae4d938edf8ca0f7c0c46795fdb42bddaf0ffe5f38dc1758eccc4c08dd7247c972aa5e932fdd48b7cd627a5c96dbba97df6deb5fc11216b90cee987576b91ea4f38e5a05de08f3856d3ba3cc5a4000d08cfd8732cdad0d34512c8da07fca5a5cf8adaa7d4bc98a7f8ea6d9b134fdcf8d82d6a3cd88bca8aa083469a348a4d2b57b6b9360c5d669a130acc7b3fa83d28858c9acf7386d09ad93725c39118a1b12613f8a751fb45abd8aad69e2aeb3aae032012408b617171f680cfcad952b7ace60ec5fef95d4462baf3dbd3d68374d14d11dc562e024c57045f6743fc76653c05290c451dd987807eff8369a1202b9802dffc69fc6707ee59a6a2755d433b5e66f922a4aefd20f1d3bdc95154f807d7f8b82014417e153c9ad19d7a6bf872999f81d9ca43e5356faec216a8d7d9a08afcc3a023ce6c3edb1e71b1674ac6bc988c637984ba8e2aa0c59652fc84e83f658fedb3fb899c79ce2ebe01a470bc411009af69ac5378c7d7b2fd194217a0e0f6ab122b246e6ecf8ede8b95bec2b4611b25a7625dde4463d3a8429cb2b37b0f8d93cab4637ee5da9416c0f9cd5af2ebedc57024b65d002ddb7623dad1454a157c94b713303e0bc5243b705e2528d6fcbd04e82756d15dc4122eb91968cfbc947be55e3bca8dac21c70fcde053627410ada12baa218b80086604db66a12911e1078025a4673f647be44c0f24ac17e12f8b3a452ffb4665fc1e62f08f67f2d91cb961a08d97dbb506e290163a4a72416ed226a1b89e04072ccadae645da62d625d750dd52abdfbef1086dd23426712a4dccc1f7063f0826f6f034343d833692aedf985ec971ed7a5c1edbeed4e1793c6c619e93c5ef0db60f549952dacbf48209872b002d7327d3209ead44a21b528fbca29c52e437c13decb061a8e234b721d06fdf8b0e428b10f47836d86bf25920dcac44d93097d6c48e602010b1a520401e848cce66443578cf62d7460ae70a23edefa19d58e17df65b9b38dd0b09eabee1e5e138379a06c428c3d2e1bdc4c1a51020d63212a9ec07350dd778ea0327ff8fac21c2f191153b50355eb967b2d78583383457f2857673f871dfc706b59b0a93d910708f7648fe2e4cc5322218200695661f8bd35b24574e4ed6ecee614a6d311a0b57bb5dc0e1f9dfd7416a60888e22f6665b57643c8bcc3ba0c71935b78d9f39738516bc64fca032d4a926b02ff600517eaeacd057a9422968edac849d771a2c6ec810b9bcd65e20d24e2ae4b89efd63ef6eaa16628c99ef149b27587cbd2fcde4c5a2ff69936e247dd3fdde73ce4c2843472139a4631777756d71f67f6a2d5f94d175b23998e958d3844a45190f8932f97d830c95af7fe8bd42298ee1842b0d6c14a2de2fc2e2b8346ee24a17f6411837510c121c8fc5ee157e681fe3ff4e3b64092924686a6d0663ec3b6a9c1ba0401662f498a83385c9e60dec3e8e27bf267fe7bec86933743032fd18ca11f7325b388898f64564d991c7f7bf93dffa6ca5e9fcc0d1024937bdd485918b358399226b9f8d277310d1bb5064c0ccb8fdf5150b5194a32021f70ee5f58f6039e560eda5a578107c7dfc637e9e5b2e8516f6d4ec942235b56a340542a6f8fb176f0e510c02d17539253c16068113b36389d5a8ee840c22d309010fc3d6110e5268ee2f0084b681599086b3e99b222fc98a2df156abb71b953328721560dd289676e14b156fa2c8749fce53c1a96b8a6c89e1df7285771e7508a6973e3e0f3b90adfa7f031743632428a1c63f97c3e67fa25454be111bf45112dd814a73e7394ba35f21c8dcabdc3deacb0774805c7cd6853f8e253aa7f33b68b2d00bb7b016a56ec8a379c8ef6b034cdccc2454a1675298decdc9d139da6cab3016f9ebcefbaaca4a8102cbd82b89405307e9856fc36209fb2c998082c5e9f652fe136bb540c094cc1ad3022cbdb139a67f65823853448a2c10f71a9f1c31d2c5e21ea1fbdb543a9882e2850ea032743fd40121ca36e8ba917424891ee8fda9255dde3dc6dda5793af30d78a11a006bea094c99ce9a4de154632a204d86f6fa62e10a85f6a2fd2560584df41f8dc790c35e6411042176d6296e6c419591e83e4e0ae4bce3aaa9f66f0c3810be877bd9a4d511da6a7f0e1827721a1919a1b38ad2bd5c03bffcd74b398e1ab44ba9cc62c855d3c247871238f32beeb9772acd8bbc95812b9bec8752e9248e8ff227446c7dacef86d54bdad6e21914b8b77da661228a703a2d57cabffb87bfab5ce4682410964f6679b36881b15fc5436ba39143f0e1fbd073536931b295c12d18ef3dfcd7bbbd4ab01bda14bce7268aa1db47be13e5293d6d7297be01e50703963e745fc1deee6f7f156a48d0aa76b7fc8ef5e856df21d982175bfa287ecb2ad5e61b9e5b9f489ae8e0da4cc068383907760e7befd8b75f0865aa2c80c7ec64b0b8957476584cd7007aa169c2d44751af47352e04f811f678d0ac49d3e9faad66c918a55d6a3f5ae5be9ad6151ab716909ef223b78cfbfc2714748074bd8eb981747e0da904ca3738f6c8350363e54036aa22c5f2e459ea340e634b0d8e7f4404686318ce8e2b58d9271f7b9b03361928f9646c8936a9b152633b80584a74ee961dc59223946faefd4aefb1569287d85030ebd0468e75117c8a3207b59beaff9010ebd536e8e2c6eb8a6a88659ca1e6fa9ab84d3c7fc36b0f470e3997b0a0f30c5d65ee3c5e2906c8db90cdddc4bfc721e1b0b792963018f48af6cebdd9f340b483cf9b31b996fbc4fe1a32b0fb32ec1f5ef6c7f7039d54ef1a964c256c0c0975442ed2444fb74da91fdbbca6a92bf8ff96d2fa808dbd39ed918ae45abda7c53f1ea4e2081e3a4bb17529cb96534c6622a37a9c060225aa1261187b44fb5b88ca343b208f22487eba18f2b011c7994e6cd4cf2fd489563a5863d361ee73ceccef1efa7571b9cb45fdf34c0c9c3dc9621e38d36773ac5ae4e6210f1e1e5c7e9c486f28e6da9ff33bca1a9ceddca74e397a9e14a08e695ad35cd998f4674c143213eea59405828d66cb43eff5bb6e5a49abee26375cbc60feb3d730b77b69e06262838f3b06e7f2309788d4bd1078a891716784c3ce9ab571f31b2e401c77cf7343b5462dbaa6aebc1c13feac92dbc0e06e3c70685954b4177199300a3951e98f90f12763486a2b2c8ec8bb926ad37970f38ce87e41b4a6fd0ab9bcd1e5a764937a4cce0036a61a080dd0bb25dd0dbe456fa8f03ca571fd964fce4fb991bdc1abdafcdb24ff1dea7e6a2ee7a52f64a4078032e192be49bceeea605ea7e7c30113c9c05a080112577bf78c22cfa2f5e757e7742bcf108133dc3f52f405063d3dbe3e17a4231099d31bdce0daa94426ce3d45f8ec5763334c1d2fed9671a20028ff17cce58de0a59a69586e5cd415a15e6984448076d3c33723a0fc8f7a8f4f92072d8b29b954e1a8eb2dc643ff960e88f4a93be60ca409714689d96575d873ec2f260e22023d27eb04fccee244ac1dcd5f0cdd165884664af070e1062a9f3067618fd68054ed63f79dcdffedc4f5fb7841f1f537b24d7c90a25fafcca6e63f98689f877544dcb5e3b97c4b3f7db1a3aa4376f5c7b3bc65987970c62a3ec36e3ce25a38f6591fef8c012e1e496ef9924f21948732eaa4bdd650a4dbe61e2ff2cbc45c6ae86659a39689539785d03a757d8c48895c4d2dfa2f440b5aac68fb06fd82ddd9a590d973a7c8adcc9d5f4d2b45473d8983c6109ac95ec19c6fbfa85525d7e64a9141f3c991743d2c20e73d796808ad6cf9376b646bd3bc138f9f7ac7931f966fc826d9290b19d9d7cf6bce8757cb9025407d8ec4c535d154428693259fef1dd298d936f3d60b21b2b6cb8ab452280c1f92df65cfd0cff1358d6957e574689d1a867d9d80510292b49b7167e8148564ccaa5b6c37c62ff694346e1a5f550faa323712e6748c6c058fe28bb33157ba5d166588359fe7195ade485107e698aad1c530a9dc881646b0f5c47415c472b25418ca8b668a12e29778579e2e6eb119b4cdf91465e9321e1c1031a805ca382ae41f38ff025270d4fc94de1c6b65ad46a2bb15bae7b8ff9a3caced98b8c08f187147948484704cb0b8acfbd1a8985a73d77623a3c291e286d466d387195035129dd9b66fcfab5ed4a1cff397997ed8e30ad2b4c1dc04fbb9225e780a63a73dbe9deb2da9c90e9f9daa22529b3c6d493e9984d2b6e0e3da215b320d4f9a8acb5c24122fd8ddb65a92351a07ab9e9b53394e336c89c1228495a200762ca35c83288fac1c64ec0ba7c50f053725889e69888d151853e3822ffe9f8a99c13e3cef4d9c8176a094f6c42be96b4a092fbea7769857160e60fa9fb58700ac8c33cfa192c76fb7b0678a9c9a634af61a01dd21bd66d6580d7b34725e52659c3bbe6c500933e965b1966f48bf9a55955ec798c9e5c9c9f4d674d079fb51dcb1c2fb3274eddcf1d6db92cd0f012472a4fbd4e5f07f66e125fa1d9f57a7ca630156578ce90ef94becdd2ddefd3b3ad5ac19e7900952f9d5f6afa55bb071d16e8f456dd5a84d39dab77cba95e7468f3d3c6df4abe7d05f56b78e29624be798cd5c658ca9d06b999148bac890dddc127133be3530109c9ad156a1c51882a1e42f7b54bd50cc7988b22922b568e5223c2d2cbb0fb8c5aa4b9e02d12ea8e2100fb3f04bc15a1b2599094d261656a713f865a03a39a8f5325474db55bb81e4eba2ecb1505eb35a7d6a41eca3d9c2672a5df007ea2e187b096dd0b06a9d6e9ed60935d3b394b19313e3b353ee60fafd6f866dd4e1e329f3b4bac3f736edc2ca5269b26414a321dab3cb101d130bf5469557191c113d90e4f182f7f6ffba786019561b1303cd888117d33f8bcc93dd2ebbc6117de9df1c2fbc9e54c946b71122b13d9317ed32f0d5aa540ea49756f7b4ba4b04ff899bd690ee10c22a9c6f2083e8fac7a788df39b173430edc798bc5d879fc253c4660edd2071f07d48773b2085e27aa4683d6b19f0ffce7c4d5213ee761a9689e4776c07cff3fb44973a4477abb6f45e98908290498d4eb6bc17a1d2af757452ad1610f5ef0423058299b882bbd09b110e57790083f1bacdda6136075f2bf558440e0e383d693facfb15cc41baa7fa3e1ef63ab54b646416e8c791ce1546f53185a900c81302b7d988840850c5a53d8ea2f048b501957547e0bd235b909df22ed355799c31d0eef84b32ccd2882a87c9402fffdae9676df6f69b31c1816e28af21eb4f905de705cdd52eddfa5cb6390bc3d7341aeb4ce2e1e2e207be26411674005f9ae3254a6fed10c181917ee48618d4494e7c536651eeeb43f0f73dd4cf905fe035b12372b64163480406b52ae3fb8ef66e1ad0b50b4a0e10e21939b5543630bf2239db5d414cbc777314aaa3eded702e989fc53a3a5a6abd3dfac07bc7d45fdefa2eedfc6e9a2b5c3f59398a8699e5db2c85745db83650bdce18635cfbbed265bd2ca16090698d79f390f55756d28046a73302a5ea98f63d5164bd42b7768336eaf8ae0fe4e0dc72d2402b238a9fcab1b7ceb93497f8322ca5311e208ea9957ca39caef2fdca2636dbb61cbf45bafd5554746a02e1dd027855720e8b177aea50bf5c9b2fcc3a77bbda275e2c5c6a04cb85ffc3cef50f76648e1598e124ad7f397716bb193124327b98a061e3beb67f7d5dae4fbbe88152912028f3913a5b825c2f1469e6698de1daae189635d2e6b2889aa78b6b976f1aa476ec89001266afef5b72e1f6ac6344c1211940c6dd961ab732b135036cc913910be82aefd44951ac143e8569dbf69f4f0ab4f0bb20d72f8596780e7bed05c785b8fb198bc2d66b79d5c6bcf2d1c1a599f83d68d8118c864a9de7aca8fc24af874572ee9728bed205614ce69366fde87829d8ad4d11897e6cd0644a9e9888114808d5665469e9d5b81eceb6c0f34337550c0fda327286fbfd5744089b270497ec56cc78419694780a3e7a113bde06e6bc4ba111f81665e53803d01bc6da9ba73660d02bfea76e030ed1934dd8cb241dc139b3191415a525cd934bc3a2aa4018b0b7e8eeb386c8a90a3e15144fdfcca506806953817be3267cad0233ae84a4b33a2ada7b0dcfb491a3b71df4a92943eb4caf8b4415d73782040579fd1b4e661292b45f6e3bbb4e0a48a19f00da5368f319deceab57ac7ee0dce3c15d95002634ee219b63d83d2397db4445c1806223283bae33d3691bc6b36171dd2ff1dc228976aa8342d68e91c48442614593a6423a5f63997b34eb681978537a1dbf58cc6357005651168eaa4fe0e2679dec06e5cad3c4032e1429da7736657dd128797dce989c86d72f09eb8f94925de40ec8a1126a45550cb84a84f3e9b5924c859c00ad52a3b14149abf9c910f358e7ade54bd33e436c6b04c2fdd351c38b590b8587e1c98f15d2e236d31e0c9c3969d2f00bca54e193b05a26510fae45f194c2401e8f16dcc30f5058df725223bce7f3ca382baf48d4a2491f9e2278249c1df16c231acd14bbf8b410867a3b105776223974b5f5d551d47702166835b676bbc4ddb7dc5612b33a966b552e270eafbd4dbc199eeb0ae779dee9bf1db4933b6dd57a71098fc319640df0362c0f8fc7c004d56c80e613377ad9796424f361db29dd8d36f351901b1aec1718c51c5441da8510d84fd163c9e42ebedb97918d81e7799c78b21bce3ff13e743f5ba7ce3cb3c69357d080d3497919d0d98810e2d63137f2fb7e63b72855de7d09134fe4bf9dee011d234634db4de1a8a75009900eb9bc54fa70bca29319d5f67d23d9e8438829ea5527db0b46547c502a19a3ff61d7ab3a069ffcbc812c2ec921a348cc356bbc6f6ca379d46bb6850e5a514b199065932a682de1eb3cc9e10fa7010c3f384960db94b886163b36940c458be008dc550e1b5765589b7eee1a4a67259e0bd87977c3ec51ed7a3fe23c4f2e13e9ba04a96d9acbba8667338763e5224af50c5ac0fa4bd8448fff70714de574f8dd0721242add6a7c3a7f66882a968d7384ab0015b055ae861eb09dd8619fa33ae48e183b4b04cde3de647d2b887d11414576e3b5930e7db4682729e1c005c21a8fc04fbb52cec83d1cd9f265e46dc3d5de9f9978293c378642e041db7222509d30134b37b41292d91d91a37d04d5ef79ac6be5b3668e43de595470b5debf09aace8126cb02234272b25209eb4610a1a9c784d3a400a02c65861318227d0edb11fda42b6f2654712b3e8d87fd8fb1ffde61bb6290bd4094b322e2c8b1a6fa8c009c75aea86b206c8d7cf90f5117e19dbf0a6a7c38d557c2ec0e889b72c951d53150ca8102d006598f23f7e44e77d0e2df28f41693d08d6ce97f72da7dcd5420ffd18018d0147e5dbea84a274895cba926aa6426817d452c7a797b9cf84272c35c440c57aa700e95dc680d04ff1f28a04a14dbe06e3a8829a2497c3d1469c04d35b2bf7cd521d2b2578d4977fdd83e4707f3007758284b11e8071cf44eea8b87f5ecadffc388a90cc16705a51aff24756420f22045ac1dd63c0f6e4d70650d0204e6c374f15be3901d17db9d7f24fab7d9cbd3cd6432af4de92b9e90702d3ccd61ea0e867653aa4205d37e5cc7c6dd7fab4d7cc17520eaf6abd5bd044302d7931c1d29c9f492d4ddae2738e8236a9ff7cb9cda94fb0596f812dba24b44eaeaaeb711e25664730f3cb0c3072634d39606027c255854c57c3c29b5e18ac18551dbb4ad815290d41b40a5c0b4bc5d46a6f340e210f8a3697c3d003ca99cc748a334450dfb717215c06ec1dc80044337f962dd738fe6cf3a5623d44a2d53e54530c54dde60ea6411d1dcf22243511304108f7e47b4f4ab42b9ea49b99f898227ada315ca0d542a9c5e89e5bc65cb2c1a17f1b090bd708e5fb617863a085ea65317079c6b516b5e3e5174ac73b7ee047845a26e4f133bb215bf718c1fdea95c6ec05b76d8ec53004b6f3ed99e1a650e3be49124319a1ead9e6b142cf16adcad3652ed4869d776e329b4cec6c37b559bdfecdafd3d8afc0b6903307ff8422aeab09fa6557102f1156d3f78455c9bdb424af174f7baf6c92fcb70f532f932ea1303a51531a503e678d8352e2fa3f2d112766d9bc7e01511ceda0486e1a716a5bf72fe9c4f8ee2cab304996e2f6246b30f83431f707f3fc682576f02724342d6f13b0d5d9784e9cfdf8ba952040bddef1942959f58b9747d12cea1576cb9f857761313dcb37c5fa6eadbc6defe3feb762b3b61354be79fd08189b54319a6c4e6aa43f4487605ab47b4b2404dc1429af8d9df01988639467db13150c1156918adadbdaa4e4932aa8f4702eb497c735d994f2bb45f77823669096d4a29664d10dbbd578b66e72daabaf6d839c8af290f90395270f9cc9250e12270ca66299776a6808fe10e9c10e678fec68a19c30d8ccbf23af7d44586c0599d8500f7eb60950f1a99fce6fd8b7adbfd461bde8bfebc257574c57cb21f0d759279b02f8156d66064f4c6c1caab5ca189decb9e11bb0f09d6ead32b8f2a9007b2cff3d9c20de84a31dadee3a28eb5669eb9182afcb3bce19bf43de92527216b6f99d028b69c6e1568c505025a0838a5d0499efae4e00e64bf3d7f4ced57fb1922b9dedfb440d2cbaae6e79e854cc4ab98daafab9a93fe53819284ea7c3df8bbcb354d90721fc0e783fe85e568be6e96a7f2a3f73aa1abe4a85d6617d65da4d3dfec5dce4ddb3bf23d8434b0d20a5d257ccb2d88ab018099d679e06c671a4497a277d64be7ae01637a6d67407d7dafa1533a7e51049f1d060563bec7bdf7fa77929d2aea7fd21b8593287dd06d4362173cfae9b3b9f47b37cd7a20498a05d57e28de40fb11c1b1250abe24b314875cef38a0691bf548d09284acde09cac444c084d95e6cbbe99f12a9ba2f7acbb0cbac6a8f52b4c3b15b58f19313a2c2b7a02bbcd0783e94350791495de58eda49dd1133cea961f0d1b29ccbbdfb4c6465965565284be8195ac427e10496a3a8438975bf18a6556bc8fd36db87eed03ba8a9c6ded5e1dcc4412f9e2f60b6a758d2c97195872e0ac3c9d80cb3dd62161d15155e7f700bd094497a881e4c13c229ad77b26c545e33ef578ef0477e44773ce6d3713ad37c6a3ec9f728371d83531d9602657850efb6b25a69f278e7d1e0910060dc0dd218a02206ce20868069ea8afad1555d366f450efeb0db24b75405ee6ae9cae151efe3ebf6e2a78d277e3c9a0e35a3f27afb250d34cb303a64701ef51089d9dd15d6c6f7258a575695bdfdd50a8f053b58a686f5ddd25f442c0ba115dc45365f1c4b3b6aefc353f6b36170f0e26fbadf67e476dd724590c3161de87dbeb64316bb51def770cf688f122ce08e308f48f86be7c6336acce46a269773a1c576022d802e71217e307a78056722180cddf919760128398e21d711759169c29fb2f65d3046be6e2a5d5730c8e15ed995f0b099a391b674ebaf5abea6d68bd930dea34294f82ab7b0eb8b218ffe9f7173c2912533248fd809815700d50f43d1416b3eef5b72382a7110cca29c2ab8ca44f290a33bce529d746088e2daf999ba053d22e2e3a239af699a1710f941d038d6708f1079558de540dc20fdb6e7b8d54aa33c2621ec32265f47fe40c65969461d58b9edf6fce70f831e32f7dd195735cdb98fd62175f27a32ab1f9e0c4aaad966ce5f1dfa2804ff172cead00d4069398afa0c391babc38a627f0a6681561f51f7a5b38af1a05960deab4bd7312e7f9d24a29aa5299e9da17c1b83b37ceb7f6c045bb7bf5078b5d879a9421bb9f10c89f47d0bdaf631bb954b097285ce1517e8840bfbd907ca3d9ab5e56037bb99394d6abc509234bfa9b2b4cad729d4718f9f4833dde25f5567d224bb4b383ebcdab9635dacfeac382606878b43b1b42099c8bf1698aec3a0e4569ec03fa88fd7d7f184777d65d896d09fa1f75a20726bf10efd14d0d32c88c0e3acebb7d77acac5cb954fbd446384e975727efc8b03f8d55bce70dfd32d80cf46b50449054b332a187fc556d27b86f240e7049e8eb5be3eccef59214dc7f846789a5bf75743326ef85ead6b618882d590c56708a9873ad7a87b71ec40159c0dddc679ed6c4c694493e3d6b99b40324f4c6330e3094f23a5f2ca5e947dd9310819a640a271657250a13cd155cb7833c6a5676944ce22f3f4a5513e179b1d124c993428c25e8e96376b4b9a41cdd6a442dad082822d93d66889caed1379d6e95ca3070b523cc496a64b21b1b7421a5ddaa05a42109a0d04c3504dcecb91196226f699a62b196bf091372921efc468f145b2b3e9c6e048e08eb1783943fa46e7bd2fe1201d665591e5f64fde27e08716b94a53bff3788b92b678b251141bd806d25ce119e4a0a947696a3902e0365fbc46dfc5adc17a4ae7df2e085a0c5cc4590c5debb173b2afa43c91c4efdfa90d704166ac7a928003da9ca38bfcbb7351993048c2ced3f1df817c1209eac2577573aec652b1f0eed789af8e78251bf2344fee69339d772e1b86b1fb134b1321b71da83a358196036a76727d276ef41d8813d5744f9c5db4137f6a73967a9a33b972c5e31b970a24496c7af9862a4942c115dff1aba3b828af96c1dbd2c67810a2a23b625ab354a190f53522280e82fefbf46bb96f9c21dd2ac07cd6eba3b51896cf98b0ea895ce09d942c27389d320781820686384482937eb84e2fff739abdc68c27a0a7436e81d6f0fe1912c89c4a61e4815169d1b7df51f6cd9d932701b50d93f372cc02e753dada0bb20d9511bc8ca119d0563883042ec227e8c77aa0b31a64f251cbee986e95ef73e3a38efcf25cf20ae26f4c43cea2c7707a4c8f32a313a288eb620dd80a103e2a8cf69999543e5d03c7e2d42e15121122e964a7f6b1685b79865502ee355a7b37782690921d57849d368fcf357de9fbf98c376e26a02ff7070d6925d19d85a671fb1c9cfdcef295fa9ab55cc975f27edc2261eb7a54dbcd6d9886c9af6095eee3944700eebf641aef924fc56b5f89caa98891fdafd66afe19ecefad42c3a2d5eddc7789bca81e157cea791239d806f6f616baf31b08fc4335beb909244517d10bd80a815cbe203187b3181e3d27045b0ad1dfe60d6faf9b9cd95a74742f6bcc33c185a7fd0ef2bd1bec064f405b4b7e7ac15f9c44b85494b06e04ae08cae1178ea44ede7a5b8daec8752bbd5bf8342040c56169d14b753f82d90b44f3a65ce7037ce2e5a968d87554efd8ef607e721aa7af8f00e126dfcc5c9bc81821f03f58185cc73c60f102afba89d04ebc7a7df08511e40f2814565ddb6d4708d7f5ac494d77d1d5afe79411489f49ad3a0efd4cba37c220b69bcaca82b8558989d96b758a07002486ffd59a9821dca1c214f965404000ef98c25cee32ef14e636abb070bf00f7038cc7a8b6ee3f9c0f3b35bc82f0f8f225d153c26ed1467ccedac0404dac656ad06633ad145e0f7d28afcc3f3bf69462a124e10c2bad7ffb67a81eafe9e94c8f90876b99981cd11535ed10e145c767c74692d53d6ef47656b836c1074a6afb024ae8a77fb28e81e9e9c369d3f47f740c5906ff5b3956e5e358ce1c1f100ddf6765513ffc6b3a833ac81834e76cd59ac9e1078344ca3fe6c28094e8201af0280e30acf2b34b55ec97be41ab9298f827a8dcc26804f899d43c3be844f7a413156a9e52858d4e97575daab1ae77fd711dbf349c1540676102b0801ebe1d22891c17612995a5942d79b40fa317df672488227e1d8ed813c4641c9da8c1f3ec4c6a882ef9a7d791ad3ef642d6f1bde83c124fe450cd6314ab13a91ac9671d9c4732d1f526525a1f7ad7be9bfc256bdafea80cc3d2e239d17d32651fc5db2376a7b2cc773effbcca8f1cc52a315d83eb115cc48e74739ec786113cde756d991d7d67c734ff69bb18b01d9154304a18702a2aa4e2f02510c27752aa4b127acc2adb1215852c69c3531ea775471f12470dbbd57d7d208e2c23802bf0474e5d282ba26e0765a19797a9a6c4b7b57c6a6335ec5aa132355f8e06a0f69e0577f0b6d70a0eb6a02da82cb74408d4cf01f61385450cb0757cff81bdeeeb2b8c6b8e9731464ca3f270f8ac1ab611faedae37c45c396dc33c288359a631a271874fdfcbcd5869cb98cb050f4fdf63f7486aed54c13414fa2729e09364143ba58e76fb30b729af917db11ffee8a9a8d7ea9d6ca94235b8b56346262448e8dc79399d36ee8e58bcb98d9de607844e7bac589b5f41d48c362be7d1ec6a6c478010bbdf740be229f043336179265dd190d6003ef5aab051ddd9a3cc46de618aefa217696010b8c3c8bdc35dac1ed5290c5432b5029acd81ef948d1fa0fc67b6ecca1de7ea29820187a00c53705fb7f806044ac23db0306c8877e86153a4a43fdec2627165461a887c457a470dd997e0299c9021c115d82a65d0e3a0fc809548d1712a5621530101af0a5a7479d062e80856c5ddca8f95da9485ecc5fe484fa2af84a99d5e25ed1bf3fc56999f293c2f36bd1f740eb02dd3638f94cab4531fcc02c1d86410fc29145d2ca91e023c294d9ada3dceab9aaf39e50361f0e683f8c77592fe6102aa20443aa0c7b818e182f23bf35dc766d9078dce0de9c36ca7c74c54cd41ea2b006d5d879a0befde54222a4bf59cde865ff737f2ba6508a949be4a3e97acc6236ff8459e322188f0aac4472d3bee1eac0b3b4f48aef80bd8e8e37fe4880c542f1eef63dd9726d9b44332c21e10f14742f293b5d3b35be6887826ba8ef3c8ae1431a0f9686b1667ac4e7f59a1b72155380019fdd13640beb78a973d64d1c28e2908ed64a34546726d30e46e021134ef46ae9037f841a38398674965c4e0a036021f38533c6d04c630ea772b7989c2c9dff323ef141eae6b49fe95a7a38966ba7ffced7d1f95f4d92d98e33cf4213d97330186342cc5dc229fd3698cd8f20db5072295f2b82b62deac0daf6cee0f158268d1cff095b647e4b4d0b900f37d7759dc2c0db49fd61b783be747256d277ddb86b114bdddb51c7ac905220a274375506cb6901cad5a202f4b35b5439ffec166f94d7cbc53681bac2d4511e419eae466b090042e62e18532579a4b9a953e413a892a2b6f5530e980f976fe724ffb89b78fc4fb3db275f38f711869ee58674778fec8a06bb7f21b629def733254b8416874e6194212f44f72e6cace94b517a69fea76b0cc7c7eabcad5e871a7658cae7bf2e563cbbe8632944d2dca609837fafda3d1fd308ef5f108df7b6d9ca80cd6a9252035f621983a5eb9aec726f933c34133ed586b879386183a2ec02b8685609d26994dde76f13d24258038deced5c82c09f095adcd005fd8e75668efee42bd339019cb52062eadc0b1aa29a4659366daf1abdb691ac8b1db10b2126964e56290a3a99d9fb8305c2913f7835b32a40f39984c9378f3c9d6c523b9f60f8870561316dbd1d9dddfc3d16ff8be896f948a8bea276e71ad94667f93abbb286187f2054ba2a71750bebf8d70dfb79e9ad13f5437641488d2c56c677b119f15d34b9c0c1bff732f891d78c7887800997860b04ee630fbbca19bdf026e08324808d0896352bb809176d1422bc4cfe8ec71102dd4f81bf1adf9420499e43f1e17d2d48c8382813cef7ec76ef0f785316e43df88f3350cdcd601f75789544a33aa74079456d7cdff9a0bc25bfd28be9282b9e1035564314e6c8d9bcf7e73d44b914828443d2b272be957a05af025095dcf002865157b0736df0128a9a9de9005e0d3cd3b561cb1f37e4ee0f6653cfb6313db14ef74b66c59b8f99f67c2f07ff9c5a969554176980bbd8172fa0823dd39ef8ea4d9e325986d2e7935402f6f35f7382eac5e0b140d448eff8606625e98041612775713c167df16c85f2c59fa42221af2fccaf95375f721c01ab9e139178f9154a9b1ccf644f8604e153475117d1f708bc1624c95510616ad0bc473c3157aef09ba0f630da5bebfdb0198f7bb9feff474bfd466e73458dec7aabef05857f4735ee83c6ccc44601980d6007046021cce07cd19dc25ee781a6caa015d9f186fdd2dbe026ac96f14abfbdfaa7b20a2d1c815dc48ed8009a08300df1b581159516249e292f52e9ea61b581ed9b144a176f458fdf26281b248760ad765e09c5889558a550efaf335764dcc7b721734e68f9ca3b7eeeb52d61bc2441150ebfc1cc988b9e5caf71633cc24c93789f23f9fd7f3ad9af381bc9db3b46b83378e10c08a26b7691e5924a0b6e4202d5dff6b77533fd6f8e7d453b97f4e981db3d10540dfb1d9b4aa7d57f836b53a5108209d08c9ce7d2c4714acb78fd965a880cbda1102db0787c2c562a8450138467e01fac43e3688a0337ecc7ecc9dfa95e554ab3d5a2685e2541527832d42e0c40df3cd209a85ecc9b7e51d57b423fe5e8a602fd13806a16d7db402324e937f305fcad377a8114c1facd35ef0175883c5edb34106b1eb0b91cc8d270157242131788d43cfeece9e40aa67f2130062bce840e66fb8983c2131892c343a4c02fc6b5409139</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">文章被主人加密了, 小窝要核验主人给的『通行证』.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 做题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 《解忧杂货铺》</title>
      <link href="/2023/07/30/%E8%A7%A3%E5%BF%A7%E6%9D%82%E8%B4%A7%E5%BA%97/"/>
      <url>/2023/07/30/%E8%A7%A3%E5%BF%A7%E6%9D%82%E8%B4%A7%E5%BA%97/</url>
      
        <content type="html"><![CDATA[<p>解忧杂货店</p><p>[日]东野圭吾</p><p>2023.07.30 记</p><hr><p>最意味深长的一句话，莫过于作者在小说结尾处写下的，一份对『无名氏朋友』的寄语：</p><blockquote><p>地图是一张白纸，这当然很伤脑筋。任何人都会不知所措。</p><p>可是换个角度来看，正因为是一张白纸，才可以随心所欲地描绘地图。一切全在你自己。对你来说，一切都是自由的，在你面前是无限的可能。这可是很棒的事啊。<strong>我由衷祈祷你可以相信自己，无悔地燃烧自己的人生。</strong></p></blockquote><p>回顾整本书，情节错综，人物也有很多。但是越往后读越能感受到不同人的情节间的交叉、错综，甚至是对人生有着相互的影响。</p><p>整本书主要讲述浪矢雄治先生开的『解忧杂货店』的形形色色的小故事，其中暗线是杂货店和各位人物与孤儿院『丸光园』之间的联系。通过办理解忧业务，浪矢先生曾在儿子面前一再坚持，而最终因病去世。</p><p>但这间杂货店仿佛有魔法一般。杂货店仿佛能沟通今昔，相互来信。情节部分就不过多赘述了，总而言之写得非常圆润，给人一种即在情理之中，又在意料之外的感觉。</p><p>要说起能从书中读到什么，还要从那个寄语说起。</p><p>最近心烦意乱，总觉得有种莫名的压力，抑或是恐慌，故找到这本书，想让杂货店也为我“解解忧”。</p><p>在爱情和梦想之间徘徊不定、漂泊远方只为实现音乐梦想、面临家庭巨变无所适从……</p><p>这都是故事里的人们提出的烦恼。而他们的相遇、坚持、激励、奉献、不离不弃的陪伴，终究是他们都在某种意义上意识到了生而为人的价值，不论之前的选择是否是最优的。</p><p>人物之间的互相照应，是本只有一颗弱小脆弱心灵的丸光园孤儿，逐步迈向成长的阶梯，明白人世间的道理，最后懂得感恩，长大后终于明白了命运的抉择。</p><p>信任，在文中表现得尤为重要。不仅要相信自己，更要相信身边的每一个人，相信每一个可能为你好的建议（或许这些当时觉得并不正确）。只有团结和信任，才能使人在团体中得到发展。</p><p>若对于个体，重要的是永不言弃。坚信自己认为的正确道路，在他人的共同助理下，方可实现梦想。只有历经挫败、坎坷之后，风雨初晴时，放得见彩虹。</p><p>其实读完之后回看现实，等风雨过后回望过去时，也许会发出感慨：“原来不就是这么点事情嘛！”所以，杂货店真正解忧的是内心对过去和未来的幻想。我们真正留在当下：对未来，不恐惧；对过去，不怨恨。这时，才真正“解忧”了。</p><p>放弃天地间的幻想，留在现在，或许明天更美好呢~</p><p>不论是为自己，还是为你。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 - 目录总览</title>
      <link href="/2023/07/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="卷首语"><a href="#卷首语" class="headerlink" title="卷首语"></a>卷首语</h2><p>岁月沧桑。生命难测。</p><p>未来的路，是曲折还是平坦？是泥泞还是山坡？是一种难解的迷。</p><p>别去猜想，别去思考。今天的事情已经够多了。不必去为明天而忧虑。愁绪会让红颜苍老。开心才是生活的最佳选择。坎坎坷坷风雨之行。曲曲折折红尘之路。都是人生中必须要历经的。</p><p>如果人生都是阳光灿烂，没有风雨。就失去了意义。只有在荆棘之中才会懂得活着的不易。</p><hr><h2 id="书目索引"><a href="#书目索引" class="headerlink" title="书目索引"></a>书目索引</h2><ol><li><p>《解忧杂货店》[日]东野圭吾（2023-07-30）</p><p><a href="https://aiopr-2378.github.io/2023/07/30/%E8%A7%A3%E5%BF%A7%E6%9D%82%E8%B4%A7%E5%BA%97/">读书笔记《解忧杂货店》</a></p></li><li><p>《活着》余华（2023-10-01）</p><p><a href="https://aiopr-2378.github.io/2023/10/01/%E6%B4%BB%E7%9D%80/">读书笔记《活着》</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好题摘录&lt;01&gt;</title>
      <link href="/2023/04/09/%E5%A5%BD%E9%A2%98%E6%91%98%E5%BD%95/"/>
      <url>/2023/04/09/%E5%A5%BD%E9%A2%98%E6%91%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem-1-等比数列求和"><a href="#Problem-1-等比数列求和" class="headerlink" title="Problem.1 等比数列求和"></a>Problem.1 等比数列求和</h1><p>题目标签：分治、数学</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>对于有 $x+1$ 项的等比数列 $A=a^0+a^1+\cdots+a^x$，求</p><script type="math/tex; mode=display">(\sum\limits_{i-1}^xa^i)\bmod p</script><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1\leq a_i,x\leq 10^{18},1\leq p\leq 10^9$。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>考虑分治。</p><p>对于指数区间 $[0,m]$，令 $m’=\dfrac{m+1}{2}-1$。考虑对 $[0,m’]$ 和 $[m’+1,m]$ 分治进行处理。</p><p>对于区间 $[0,m’]$，求得 $U=\sum\limits_{i=0}^{m’}a^i$。</p><p>对于区间 $[m’+1,m]$，可以同时通过分治计算 $V=a^{m’+1}$，然后进行分类讨论：</p><ul><li>若 $m$ 为奇数，则有偶数项，此时区间和为</li></ul><script type="math/tex; mode=display">U+UV</script><ul><li>若 $m$ 为偶数，则有奇数项，考虑先处理前 $m-1$ 项，最后加上第 $m$ 项，则区间和为</li></ul><script type="math/tex; mode=display">U+UV+V^2</script><p>中间运算时加上取模运算即可。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll x,a,p;</span><br><span class="line">ll v;</span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">(ll m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m)&#123;</span><br><span class="line">        v=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid=(m+<span class="number">1</span>)/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">    ll u=<span class="built_in">work</span>(mid);</span><br><span class="line">    ll lv=v;</span><br><span class="line">    v=v*a%p;</span><br><span class="line">    <span class="keyword">if</span>(m&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        ll ans=(u+u*v%p)%p;</span><br><span class="line">        v=lv*lv%p*a%p;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll ans=(u+u*v%p+v*v%p)%p;</span><br><span class="line">        v=v*v%p;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;x&gt;&gt;p;</span><br><span class="line">        a%=p;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">work</span>(x)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-2-LIS-Number"><a href="#Problem-2-LIS-Number" class="headerlink" title="Problem.2 LIS Number"></a>Problem.2 LIS Number</h1><p>题目标签：组合数学、动态规划</p><p>题目来源：Topcoder SRM 585</p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>设 $A$ 是一个整数序列，<code>LIS Number</code> 是把 $A$ 切成几个数列，每个数列内的数都单调增，能分出来的最小数列数。</p><p>例如，$A=\{1,4,4,2,6,3\}$ 的 <code>LIS Number</code> 是 $4$，因为我们可以用 $\{1,4\} + \{4\} + \{2,6\} + \{3\}$ 得到 $A$，并且没有办法创造一个连接 $3$（或更少）个单调增序列。</p><p>特殊地，一个单调增序列的 <code>LIS Number</code> 是 $1$。</p><p>你有 $n$ 种类型的卡片。每一个 $i$，对于 $0\leq i&lt;n$，你有 $cnt_i$ 张 $i$ 型卡。每张第 $i$ 型卡上的数是 $i$。</p><p>给你 $cnt$ 数组和整数 $k$。你要排所有的卡成排，使所得到的整数序列的 <code>LIS Number</code> 是 $k$ 。 注意，你必须使用所有的卡，你只能选择它们的顺序。</p><p>计算 $x$ 为你能产生的不同满足上述条件的序列数。计算并输出数 $x$ 模 $1000000007(10^9+7)$。</p><h2 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1 \leq n \leq 36,1\leq cnt_i \leq 36,1 \leq k \leq 1296$</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>考虑由小到大插入每种数字，进行动态规划。</p><p>我们设状态 $f_{i,j}$ 为：插入完前 $i$ 种数字，共生成了 $j$ 个上升序列的方案数。</p><p>我们把安排好的数字看做一个序列，设当前序列里有 $sum$ 个数字，我们要新安排进去的这种数字一共有 $cnt$ 个。</p><p>此时我们新加入一种新的数字。如果我们把一些数字安排到原来的每个上升序列的末尾，则这个大序列的 <code>LIS Number</code> 不变，而插入到其他位置，必然会导致 <code>LIS Number</code> 个数增加。</p><p>考虑枚举放 $t$ 个数字到共有 $j$ 个上升序列的大序列末尾（即不会改变序列答案），则序列答案会增加 $cnt-t$。</p><p>我们要把 $u=cnt-t$ 个数放在 $v=sum+1-j+t$ 个位置里（因为在总共的 $sum+1$ 个空格中，有 $j-t$ 个位置已经被“放置在序列末尾”的策略占据），就可以把问题抽象成：把排成一列的 $u$ 个球，分成 $v$ 个抽屉里，允许有抽屉空着不放，求所有分法的方案数——这就可以用组合数处理，方案数为 $C_{u+v-1}^u$。</p><p>所以递推式为</p><script type="math/tex; mode=display">f_{i,j+u}=f_{i-1,j}\cdot C_j^t \cdot C_{u+v-1}^u</script><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1305</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,cnt[MAXN],k;</span><br><span class="line">ll f[MAXN][MAXN],C[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;LISNumber.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;LISNumber.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;cnt[i];</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1296</span>;i++)&#123;</span><br><span class="line">        C[i][<span class="number">0</span>]=C[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            C[i][j]=C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            C[i][j]%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>][cnt[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum=cnt[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++) <span class="keyword">if</span>(f[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=<span class="built_in">min</span>(j,cnt[i]);t++)&#123;</span><br><span class="line">                <span class="type">int</span> x=sum+<span class="number">1</span>-j+t;</span><br><span class="line">                <span class="type">int</span> y=cnt[i]-t;</span><br><span class="line">                f[i][j+y]+=f[i<span class="number">-1</span>][j]*C[j][t]%mod*C[x+y<span class="number">-1</span>][y]%mod;</span><br><span class="line">                f[i][j+y]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][k];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-3-小蓝的旅行计划"><a href="#Problem-3-小蓝的旅行计划" class="headerlink" title="Problem.3 小蓝的旅行计划"></a>Problem.3 小蓝的旅行计划</h1><p>题目标签：贪心、线段树</p><p>题目来源：第十四届蓝桥杯大赛软件赛省赛</p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>小蓝正计划进行一次漫长的旅行。小蓝计划开车完成这次旅行。显然他在途中需要加油，否则可能无法完成这次旅行。</p><p>小蓝要依次经过 $n$ 个地点，其中从第 $i-1$ 个地点到达第 $i$ 个地点需要消耗 $Dis_i$ 升油。小蓝经过的每个地点都有一个加油站，但每个加油站的规定也不同。在第 $i$ 个加油站加 $1$ 升油需要 $Cost_i$ 的费用，且在这个加油站最多只能加 $Lim_i$ 升油。</p><p>小蓝的车的油箱也有容量限制，他的车上最多只能装载 $m$ 升油。</p><p>一开始小蓝的油箱是满的，请问小蓝需要准备多少钱才能顺利完成他的旅行计划。如果小蓝按给定条件无论准备多少钱都不能完成他的旅行计划，请输出 $-1$ 。</p><h2 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1 \leq n \leq 2\times 10^5\;,\;1 \leq Dis_i\;,\;Lim_i\;,\;m \leq 10^9$。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>考虑从第 $1$ 个点到第 $n$ 个点，逐个贪心考虑。</p><p>从开头开始旅行，每走到一个点，尽可能少地加油，使得可以到达这个点，一定比加好多油到这里划算。</p><p>所以只考虑到达该点时，剩余的油量 $oil&lt;0$ 的情况时，在前面的加油站进行加油操作。</p><p>但是在哪里加油可以保证加油之后，一直走到这个当前的节点，一路上任何时刻油量小于油箱容量 $m$，并且花费最少呢？</p><p>考虑贪心处理，利用优先队列记录前面每一个加油站能加的油量和单价。注意，在到达位置 $i$ 时，在位置 $j$ 加油，需要保证加 $k$ 升油之后，使得对于在 $[j,i]$ 中任意时刻，油箱里的油量需要小于等于 $m$。而在这里加完 $k$ 升油之后，会对后面旅途的油量产生影响，需要对 $[j,i]$ 区间中的油量加上 $k$。</p><p>考虑用线段树记录每个节点时的油量，进行区间查询、区间修改、单点修改。</p><p>当没有油可以加，并且到不了节点 $i$ 时（即 $oil&lt;0$ 且优先队列为空），判断无解。</p><h2 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((tree[p].l+tree[p].r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (p&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (p&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">K</span>&#123;</span><br><span class="line">    <span class="type">int</span> cost,lim,id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(K x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cost&gt;x.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;K&gt; q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,maxx,tag;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].l=l,tree[p].r=r;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].l==tree[p].r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,ls);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].tag)&#123;</span><br><span class="line">        <span class="type">int</span> k=tree[p].tag;</span><br><span class="line">        tree[ls].maxx+=k;</span><br><span class="line">        tree[ls].tag+=k;</span><br><span class="line">        tree[rs].maxx+=k;</span><br><span class="line">        tree[rs].tag+=k;</span><br><span class="line">        tree[p].tag=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].maxx=<span class="built_in">max</span>(tree[ls].maxx,tree[rs].maxx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r)&#123;</span><br><span class="line">        tree[p].maxx+=k;</span><br><span class="line">        tree[p].tag+=k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(l,r,k,ls);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(l,r,k,rs);</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r) <span class="keyword">return</span> tree[p].maxx;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(l,r,ls));</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(l,r,rs));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> oil=m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> dist,cost,lim,i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;dist&gt;&gt;cost&gt;&gt;lim;</span><br><span class="line">        oil-=dist;</span><br><span class="line">        <span class="built_in">modify</span>(i,i,oil,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(oil&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;cost,lim,i&#125;);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;oil&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            K now=q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> cost=now.cost,lim=now.lim,id=now.id;</span><br><span class="line">            <span class="type">int</span> maxx=<span class="built_in">query</span>(id,i<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            lim=<span class="built_in">min</span>(lim,m-maxx);</span><br><span class="line">            <span class="type">int</span> add=<span class="built_in">min</span>(lim,-oil);</span><br><span class="line">            lim-=add;</span><br><span class="line">            ans+=add*cost;</span><br><span class="line">            oil+=add;</span><br><span class="line">            <span class="keyword">if</span>(lim) q.<span class="built_in">push</span>(&#123;cost,lim,id&#125;);</span><br><span class="line">            <span class="built_in">modify</span>(id,i,add,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(oil&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;cost,lim,i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-4-Distinct-Numbers"><a href="#Problem-4-Distinct-Numbers" class="headerlink" title="Problem.4 Distinct Numbers"></a>Problem.4 Distinct Numbers</h1><p>题目标签：博弈论</p><p>题目来源：ARC137C</p><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定长为 $N$ 的非负整数列 $A:a_1,a_2,\cdots a_n$，保证元素互不相同。</p><p>Alice 和 Bob 在玩游戏。Alice 为先手，两人轮流操作。每次操作选手可以如下进行：</p><ul><li>选择当前 $A$ 中最大的元素，将其替换为一个更小的非负整数。要求替换后 $A$ 中元素仍然互不相同。</li></ul><p>首先无法操作的一方失败。当两人都采取最优策略时，求谁有必胜策略。</p><h2 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h2><p>$2\leq N \leq 3\times 10^5,0\leq a_i\leq 10^9$。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>考虑每次都会将一个数减小，会有如下最优策略，记 $x$ 为最大元素， $y$ 为次大元素：</p><ol><li>若 $y+1&lt;x$，即 $x,y$ 之间有空位。操作者可以将 $x$ 改变至大于 $y$ 或小于 $y$，从而将局面交给对方。如果其中某个操作会失败，可以选择另一个操作。因为两种操作最后交给对方的局面是对立的。</li><li>若 $y+1=x$，即 $x,y$ 之间没有空位。因为每次都会减少至少 $1$，每次会填补一个空，答案就会和 $\text{mex}$ 有关系。如果有奇数个空，那么前者胜，否则前者必败。</li></ol><h2 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 300005</span></span><br><span class="line"><span class="type">int</span> t,n,a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>) num+=a[i];</span><br><span class="line">        <span class="keyword">else</span> num+=a[i]-a[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((a[n]==a[n<span class="number">-1</span>]+<span class="number">1</span>&amp;&amp;(num&amp;<span class="number">1</span>))||a[n]!=a[n<span class="number">-1</span>]+<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;Alice&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Bob&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-5-Present"><a href="#Problem-5-Present" class="headerlink" title="Problem.5 Present"></a>Problem.5 Present</h1><p>题目标签：数学、思维</p><p>题目来源：CF1322B</p><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一个长度为 $n$ 的数列 $a$。其中第 $i$ 项为 $a_i$。</p><p>求</p><script type="math/tex; mode=display">\bigoplus\limits_{i=1}^n\bigoplus\limits_{j=i+1}^n(a_i+a_j)</script><p>其中 $\oplus$ 表示按位异或操作。</p><h2 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1\leq n\leq 4\times 10^5,1\leq a_i\leq 10^7$。</p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先可以得到 $O(n^2)$ 的暴力算法。我们换个思路考虑问题。</p><p>我们直接求解答案的每一个二进制位，可以从低位向高位处理每个位。对于答案的第 $k$ 个二进制位，考虑其为 $1$ 的条件：$\forall a_i+a_j(1\leq i&lt;j\leq n)$，统计其和的第 $k$ 位为 $1$ 的个数 $num$，只有 $num$ 位奇数时，这一位才可能位 $1$，只与比其小的位有关。</p><p>从此我们得到了这个重要的性质，那我们就要考虑怎样统计 $num$。</p><p>对于第 $k$ 位（最低位为第 $0$ 位），我们只考虑一个数 $b$ 的前 $k$ 低位，这个操作可以简单地通过 $b\&amp;(2^{k+1}-1)$ 得到，得到的数的取值范围为 $[0,2^{k+1}-1]$。</p><p>这一位为 $1$ 有如下两种可能：</p><ul><li>没有进位，那么和在 $[2^{k},2^{k+1}-1]$ 的范围内；</li><li>若有进位，那么和在 $[2^{k+1}+2^k,(2^{k+1}-1)\times 2]$，等价于 $[2^i\times 3,2^{k+2}-2]$。</li></ul><p>这样我们得到了两个连续的区间。我们只需要找和在这两个区间范围内的 $a_i+a_j$ 即可（这里的 $a_i,a_j$ 只保留前 $k$ 小位）。</p><p>我们可以通过双指针求出这个个数。具体地，令 $b_i=a_i\&amp;(2^{k+1}-1)$。因为顺序不影响结果，不妨先对 $b$ 升序排序。那么对于每一个 $b_i$，每个满足 $b_i+b_j$ 在合法范围内的 $j$ 是连续的，而且具有单调性。我们从大到小枚举 $i$ 的时候（因为排过序，所以 $b_i$ 也是从大到小的），合法的 $j$ 的区间是单调不降的。这样可以 $O(n)$ 的时间内求出低 $k$ 位为 $1$ 的加和的个数 $num$，进而判断答案的第 $k$ 位是否为 $1$。</p><p>因为需要枚举每个二进制位 $k$，所以算法的总时间复杂度为 $O(n\log N)$，其中 $N$ 为值域。</p><h2 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 400005</span></span><br><span class="line"><span class="type">int</span> n,a[MAXN],b[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">count</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>,i=n;i;i--)&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=n&amp;&amp;b[i]+b[l]&lt;x) l++;</span><br><span class="line"><span class="keyword">while</span>(r&lt;=n&amp;&amp;b[i]+b[r]&lt;=y) r++;</span><br><span class="line">cnt+=r-l;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=l&amp;&amp;i&lt;r) cnt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (cnt&gt;&gt;<span class="number">1</span>)&amp;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;=<span class="number">24</span>;p++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">b[i]=a[i]&amp;((<span class="number">1</span>&lt;&lt;(p+<span class="number">1</span>))<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line"><span class="type">bool</span> k1=<span class="built_in">count</span>(<span class="number">1</span>&lt;&lt;p,(<span class="number">1</span>&lt;&lt;(p+<span class="number">1</span>))<span class="number">-1</span>);</span><br><span class="line"><span class="type">bool</span> k2=<span class="built_in">count</span>(<span class="number">3</span>&lt;&lt;p,(<span class="number">1</span>&lt;&lt;(p+<span class="number">2</span>))<span class="number">-2</span>);</span><br><span class="line">ans|=((<span class="number">1</span>&amp;(k1^k2))&lt;&lt;p);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-6-签到题"><a href="#Problem-6-签到题" class="headerlink" title="Problem.6 签到题"></a>Problem.6 签到题</h1><p>题目标签：图论、异或操作</p><p>题目来源：校内联考 [SO Round 1] T2</p><h2 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一张 $n$ 个点，$m$ 条边的无向图，边有边权 $w$，定义一条路径的价值为它所经过的边的边权的异或和。</p><p>求从节点 $1$ 到节点 $n$ 的价值最大的路径的价值。</p><h2 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1 \le n,m \le 3 \times 10^5,0 \le w \le 2^{30}$。</p><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>很巧妙的想法。</p><p>我们可能走很长的路径，每个路径的转移不符合三角形不等式，所以不能用求解最短路的方法求解。换个思路，因为是异或和，我们无需考虑具体怎样走的，只用考虑要走哪个边：考虑如果图上有一个环，我们可以任意地走这个简单环。如果我们从一个节点进，又从环的这个节点出去，这样只对对答案有影响。</p><p>那我们就可以找到图上的每个简单环，最后找到从 $1$ 到 $n$ 的路径即可。</p><p>或许我们实现的可以更加简单一些：我们构造出一个 $\text{dfs}$ 生成树，对于不在树上的边，只可能是返祖边，从而构成一个环。我们记 $dis_i$ 为从 $1$ 到 $i$ 在生成树上面的路径价值。我们把这样每一个环放到线性基里面，最后只需要在线性基里面求出关于 $dis_n$ 的最大异或和即可。（这意味着我们在一条从 $1$ 走到 $n$ 的路径上随意地走简单环）</p><p>时间复杂度为 $O(n\log w)$。</p><h2 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 300005</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">int</span> n,m,dis[MAXN],t[<span class="number">50</span>];</span><br><span class="line">vector&lt;pii&gt; g[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]) x^=t[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                t[i]=x;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> nd:g[u])&#123;</span><br><span class="line">        <span class="type">int</span> v=nd.first,c=nd.second;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">            <span class="built_in">insert</span>(dis[u]^dis[v]^c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dis[v]=dis[u]^c;</span><br><span class="line">            <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!((x&gt;&gt;i)&amp;<span class="number">1</span>)) x^=t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x,y,c,i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;c;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(&#123;y,c&#125;);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(&#123;x,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">query</span>(dis[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-7-树"><a href="#Problem-7-树" class="headerlink" title="Problem.7 树"></a>Problem.7 树</h1><p>题目标签：思维，树论</p><p>题目来源：清华集训 2012-2013 day 4</p><h2 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h2><p>有一颗 $n$ 个节点的二叉树，编号1至n。你将这些节点依次删除，并规定你只能删除没有父亲的节点（即删除一个节点前，必须将其祖先全部删除）。这棵树可能有三种形态：</p><ol><li>一个链，准确地说，每个点最多只有一个儿子；</li><li>满二叉树；</li><li>普通的二叉树。</li></ol><p>你并不知道这棵树的形态，只能通过以下方式询问：</p><ul><li><code>size()</code>：返回这棵树的节点数量 $n$；　</li><li><code>type()</code>：返回这棵树的类型；</li><li><code>question(p,q)</code> ：返回 $p$ 号点和 $q$ 号点的关系。若返回值为 $1$，表示 $p$ 是 $q$ 的祖先，若返回值为 $-1$，表示 $q$ 是 $p$ 的祖先，否则返回值为 $0$。你用这个询问的次数将关系到你的分数；</li><li><code>void submit(x)</code>：完成回答，表示删除 $x$ 号节点。</li></ul><p>你需要做的，就是通过<strong>尽可能少的 <code>question</code> 询问</strong>将所有点全部删除。你的答案得到满分，调用 <code>question</code> 函数从次数必须为 $O(n\log n)$ 级别。</p><h2 id="数据范围-6"><a href="#数据范围-6" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1 \le n \le 300000$。</p><h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于部分分，我们有 $O(n^2)$ 的暴力算法，下面直接讲能得到满分的正解。</p><p>考虑选择一个点，则我们删除这个节点与根之间最短路径的每一个节点才能删除这一个节点。</p><p>那我们就若干次随机化，每次随机选择一个节点，目的是删除这个节点到根的所有节点（构成一条链）后删除这个节点。我们每一次对于这个节点向全局进行 <code>question</code> 询问，了解哪些节点是它的祖先，单次复杂度 $O(n)$。我们依次删除祖先节点。因为我们删除这条链之后，会分割成若干棵子树，我们有需要在这些子树中分别进行删点操作。因为我们使用随机化算法，每次的链长期望为 $O(\log n)$。</p><p>我们需要记录这条链上所有的节点，从而继续进行操作。考虑到我们还需要对节点到根（或所在子树的顶）的这条链按照祖先顺序排序，我们需要使用<strong>归并排序</strong>算法。为什么不使用快速排序呢，考虑到归并排序的复杂度是严格 $O(n\log n)$ 的，最坏复杂度比快速排序更加优一些（或许因为这道题卡常）。我们只需要使用 C++ 自带的 <code>stable_sort</code> 函数进行排序，并重定义 <code>cmp</code> 函数即可。</p><p>对于 <code>type</code> 为 $1$ 的树，即一条链，我们只需要选择链底的节点，进行一次操作即可，详见参考代码。</p><p>时间复杂度 $O(n\log n)$。</p><h2 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">question</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">submit</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 300005</span></span><br><span class="line"><span class="type">int</span> dep[MAXN],n,a[MAXN];</span><br><span class="line"><span class="type">bool</span> ins[MAXN];</span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">question</span>(x,y)==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt; p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> n=p.<span class="built_in">size</span>(),now=p[<span class="built_in">rnd</span>()%n];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; fa;</span><br><span class="line">    fa.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v!=now&amp;&amp;<span class="built_in">question</span>(v,now)==<span class="number">1</span>) fa.<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    fa.<span class="built_in">push_back</span>(now);</span><br><span class="line">    <span class="built_in">stable_sort</span>(fa.<span class="built_in">begin</span>(),fa.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> m=fa.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; son;</span><br><span class="line">    son.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:fa) ins[v]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ins[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">question</span>(fa[mid],v)) l=mid;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        son[l].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">submit</span>(fa[i]);</span><br><span class="line">        <span class="built_in">solve</span>(son[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=i;</span><br><span class="line">        <span class="built_in">stable_sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">submit</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">solve</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-8-Stack-Exterminable-Arrays"><a href="#Problem-8-Stack-Exterminable-Arrays" class="headerlink" title="Problem.8 Stack Exterminable Arrays"></a>Problem.8 Stack Exterminable Arrays</h1><p>题目标签：思维，字符串，哈希</p><p>题目来源：CF1223F</p><h2 id="题目大意-7"><a href="#题目大意-7" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个长度为 $n$ 的数列，对于其中一段子序列称为可被删除的，当且仅当按照下表顺序，按照如下要求进栈和出栈后栈为空：</p><ul><li><p>如果当前元素等于栈顶元素，则弹出栈顶元素；</p></li><li><p>否则将当前元素压入栈中。</p></li></ul><p>求有多少个子序列为可被删除的。</p><h2 id="数据范围-7"><a href="#数据范围-7" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1\le \sum n,\sum q\le 3\times 10^5$。</p><h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>CSP-S 2023 T2 的原题，可惜考场并没有想出正确的思路。</p><p>理解题意后我们发现，我们可以枚举每一个可被删除的子序列（下面简称为“合法子序列”）的起始位置，进行栈模拟，就可以找到以这个位置开始的所有合法子序列。这是一个时间复杂度为 $O(n^2)$ 的算法。</p><p>我们考虑进行简化。如果只从第一个位置进行栈模拟，发现所有合法的子序列都有如下性质：</p><ul><li>设 $p_i$ 表示栈在第 $i$ 个位置的状态，如果子序列 $l\dots r$ 是合法的子序列，则有 $p_{l-1}=p_r$，即经过合法子序列后栈的状态和未经过时一样。</li></ul><p>考虑怎么证明这个东西。</p><p>如果 $l\dots r$ 内的数会和栈里面的数抵消。形式化地，记栈为 $S=YX$，当前合法的子序列形如 $XYYX$，两个 $X$ 或抵消，同时子序列内部重复的 $Y$ 也会抵消，最后剩下 $X$，入栈，这样栈内元素又一样了。</p><blockquote><p>例子 $\quad$ 对于序列 <code>2 2 3 3 2</code>，子序列取区间 $[2,5]$ 时，$p_1=\{2\}$，$p_5=\{2\}$，二者相等，说明子序列 <code>2 3 3 2</code> 是合法的子序列。</p></blockquote><p>那么我们就可以只进行一个堆栈模拟，记录到每个位置的 $p_i$，可以对其进行字符串哈希，再用一个哈希表记录当前以前的所有栈状态，统计每个位置与其相等的栈状态即可。复杂度 $O(n)$。</p><p>对于 <code>unordered_map</code> 类型的变量，可以使用 <code>&lt;name&gt;.reserve(_size)</code> 进行预制大小。</p><h2 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 300005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 5323</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> p 233</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">int</span> Q,n,s[MAXN],top,a[MAXN],num[MAXN];</span><br><span class="line">ull hs[MAXN],table[MAXN],lable[MAXN];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx=<span class="number">300000</span>;</span><br><span class="line">unordered_map&lt;ull,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;Q;</span><br><span class="line">    table[<span class="number">0</span>]=lable[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxx;i++) table[i]=table[i<span class="number">-1</span>]*mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxx;i++) lable[i]=lable[i<span class="number">-1</span>]*p;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">        top=ans=<span class="number">0</span>;</span><br><span class="line">        mp.<span class="built_in">clear</span>();</span><br><span class="line">        mp.<span class="built_in">reserve</span>(n+<span class="number">5</span>);</span><br><span class="line">        mp[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==a[s[top]])&#123;</span><br><span class="line">                hs[i]=hs[i<span class="number">-1</span>]-table[top]*lable[a[i]];</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s[++top]=i;</span><br><span class="line">                hs[i]=hs[i<span class="number">-1</span>]+table[top]*lable[a[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(hs[i])!=mp.<span class="built_in">end</span>()) ans+=mp[hs[i]];</span><br><span class="line">            mp[hs[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-9-Cow-Tennis-Tournament"><a href="#Problem-9-Cow-Tennis-Tournament" class="headerlink" title="Problem.9 Cow Tennis Tournament"></a>Problem.9 Cow Tennis Tournament</h1><p>题目标签：组合计数、思维、线段树</p><p>题目来源：CF283E</p><h2 id="题目大意-8"><a href="#题目大意-8" class="headerlink" title="题目大意"></a>题目大意</h2><p>有 $n$ 个点，每个点有一个点权 $s_i$，一开始，每个点向比其点权小的点连边。接下来 $k$ 个操作，每个操作给定 $l,r$，将 $s_x,s_y\in [l,r]$ 的点对 $(x,y)$ 的边翻转方向。</p><p>问最后有多少对三元组 $(x,y,z)$ 满足 $x\rightarrow y,y\rightarrow z,z\rightarrow x$​。（箭头表示连边方向）两个三元组不同当且仅当有一个点在其中一个三元组中而不在另一个三元组中。</p><h2 id="数据范围-8"><a href="#数据范围-8" class="headerlink" title="数据范围"></a>数据范围</h2><p>$3\le n\le 10^5,0\le k\le 10^5,1\le s_i\le 10^9,1 \le a_i &lt; b_i \le 10^9$。</p><h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>考虑到正面思考好像很难，正难则反，考虑有多少组三元组不符合这个条件。</p><p>不难发现，对于不满足条件的三元组 $(x,y,z)$，其中肯定有一个点的出度（在这三个点构成的图中）为 $2$。我们就考虑能否求出每个点在最后有多少个出度，进而求出答案。</p><p>因为一段区间翻转，只会对这个区间内的点对 $(x,y)$ 产生变化，不妨按照扫描线的思路，按照点权大小排序后，对离散化的点权建立线段树，表示每个点是否对当前点 $x$ 的连边有翻转（即区间翻转操作是奇数次还是偶数次）。我们把每个操作拆分为两个：</p><ul><li>左端标记在区间 $[l,r]$ 翻转；</li><li>右端标记在区间 $[l,r]$ 撤销翻转，即再进行一次翻转即可。</li></ul><p>我们按照离散化的点集，按照权值从小到大扫描。再每一个点记录当前点的出度：</p><ul><li>对于比当前点 $x$ 点权小的点 $y$，当前点连向这个点，当且仅当区间 $[y,x)$ 的翻转次数为偶数次；</li><li>对于比当前点 $x$ 点权大的点 $y$，当前点连向这个点，当且仅当区间 $(x,y]$ 的翻转次数为奇数次。</li></ul><p>这样，我们进行区间修改，区间查询，就可以在 $O(\log n)$ 的时间内求出一个点的出度。根据组合公式，可以得到不合法的种类数为 $C_{num}^2$，其中 $num$ 为出度。</p><p>所以最后答案就是</p><script type="math/tex; mode=display">C_n^3-\sum\limits_{i=1}^nC_{num_i}^2</script><h2 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((tree[p].l+tree[p].r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (p&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (p&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,k,s[MAXN];</span><br><span class="line">ll ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; add[MAXN],del[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,sum[<span class="number">2</span>];</span><br><span class="line">    <span class="type">bool</span> tag;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].sum[<span class="number">0</span>]=tree[ls].sum[<span class="number">0</span>]+tree[rs].sum[<span class="number">0</span>];</span><br><span class="line">    tree[p].sum[<span class="number">1</span>]=tree[ls].sum[<span class="number">1</span>]+tree[rs].sum[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].l=l,tree[p].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[p].sum[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,ls);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tree[p].tag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">swap</span>(tree[ls].sum[<span class="number">0</span>],tree[ls].sum[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">swap</span>(tree[rs].sum[<span class="number">0</span>],tree[rs].sum[<span class="number">1</span>]);</span><br><span class="line">    tree[ls].tag^=<span class="number">1</span>;</span><br><span class="line">    tree[rs].tag^=<span class="number">1</span>;</span><br><span class="line">    tree[p].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(tree[p].sum[<span class="number">0</span>],tree[p].sum[<span class="number">1</span>]);</span><br><span class="line">        tree[p].tag^=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(l,r,ls);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(l,r,rs);</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> op,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r) <span class="keyword">return</span> tree[p].sum[op];</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) sum+=<span class="built_in">query</span>(l,r,op,ls);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) sum+=<span class="built_in">query</span>(l,r,op,rs);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;s[i];</span><br><span class="line">    <span class="built_in">sort</span>(s+<span class="number">1</span>,s+<span class="number">1</span>+n);<span class="comment">//按照点权排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x,y,i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        x=<span class="built_in">lower_bound</span>(s+<span class="number">1</span>,s+<span class="number">1</span>+n,x)-s;<span class="comment">//求出离散化后的操作范围</span></span><br><span class="line">        y=<span class="built_in">upper_bound</span>(s+<span class="number">1</span>,s+<span class="number">1</span>+n,y)-s<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y&lt;x) y=x;</span><br><span class="line">        add[x].<span class="built_in">push_back</span>(y);<span class="comment">//建立类扫描线</span></span><br><span class="line">        del[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:add[i]) <span class="built_in">modify</span>(i,v,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> cnt1=<span class="built_in">query</span>(<span class="number">1</span>,i<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//比当前点点权小的点所带来的出度</span></span><br><span class="line">        <span class="type">int</span> cnt2=<span class="built_in">query</span>(i+<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//比当前点点权大的点所带来的出度</span></span><br><span class="line">        <span class="keyword">if</span>(cnt1+cnt2&gt;=<span class="number">2</span>) ans+=<span class="number">1ll</span>*(cnt1+cnt2)*(cnt1+cnt2<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">//组合答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:del[i]) <span class="built_in">modify</span>(v,i,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="number">1ll</span>*n*(n<span class="number">-1</span>)*(n<span class="number">-2</span>)/<span class="number">6</span>-ans;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-10-作业-Homework"><a href="#Problem-10-作业-Homework" class="headerlink" title="Problem.10 作业 Homework"></a>Problem.10 作业 Homework</h1><p>题目标签：根号分治</p><p>题目来源：2006上海省选 (SHOI2006)</p><h2 id="题目大意-9"><a href="#题目大意-9" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个集合为 $S$，初始为空，你需要执行以下两个操作共 $N$ 次。</p><ol><li>在集合 $S$ 中加入一个新元素，其代号为 $X$，保证 $X$ 在当前集合中不存在。</li><li>在当前的集合 $S$ 中询问所有元素 $\bmod\ Y$ 最小的值。</li></ol><h2 id="数据范围-9"><a href="#数据范围-9" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1\le N\le 10^5,1\le X,Y\le 3\times 10^5$。</p><h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>看到维护操作中有取模操作，且难以维护区间信息，考虑根号分治。</p><p>记 $T=\sqrt{3\times 10^5}$。具体地，将询问的 $Y$ 划分为两个种类：</p><ul><li>若 $Y\le T$，则这样的<strong>模数</strong>最多有 $T$ 种，对每一种值在添加数据时暴力维护（添加并取最小值）；</li><li>若 $Y&gt;T$，考虑到<strong>商数</strong>最多有 $T$ 种，即对于 $Y/x=p\dots\dots q$ 的 $p$ 最多有 $T$ 种。变化式子为 $x-pY=q$，枚举每一个 $p$，则可以算出该商数情况下的最小 $q$ 值。具体地，利用 <code>set</code> 维护 $S$ 中的数，对于每一个模数 $p$，找到第一个大于等于 $pY$，减一下即可得到该模数下的最小 $q$ 值。</li></ul><p>令 $\omega$ 为值域，则插入一次复杂度 $O(\sqrt{\omega})$，查询一次复杂度为 $O(1)$ 或 $O(\sqrt{\omega} \log n)$，总复杂度 $O(n\sqrt{\omega}\log n)$，可通过此题。</p><h2 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSQRTN 555</span></span><br><span class="line"><span class="type">int</span> lim=<span class="number">550</span>,n,p[MAXSQRTN];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++) p[i]=<span class="built_in">min</span>(p[i],x%i);</span><br><span class="line">    s.<span class="built_in">insert</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=lim) <span class="keyword">return</span> p[x];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;<span class="number">1ll</span>*k*x&lt;=<span class="number">300000</span>;k++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> t=s.<span class="built_in">lower_bound</span>(k*x);</span><br><span class="line">        <span class="keyword">if</span>(t==s.<span class="built_in">end</span>()) <span class="keyword">break</span>;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,*t-k*x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(p));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">char</span> ch;<span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;ch&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;A&#x27;</span>) <span class="built_in">add</span>(x);</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="built_in">query</span>(x)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 好题摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 好题摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数基础</title>
      <link href="/2022/11/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/11/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>线性代数基础</p><p>线性代数是OI中常用的一部分数学知识。本篇主要记录高斯消元法和基础矩阵变换。</p><h1 id="一、矩阵"><a href="#一、矩阵" class="headerlink" title="一、矩阵"></a>一、矩阵</h1><p>矩阵是数学中常用的代数工具。当然，信息代数中的重点也许与数学不同，但大体思路相仿。</p><h2 id="1-1-quad-矩阵的定义"><a href="#1-1-quad-矩阵的定义" class="headerlink" title="1.1$\quad$ 矩阵的定义"></a>1.1$\quad$ 矩阵的定义</h2><p><strong>矩阵</strong>$\quad$对于一个由 $n\times m$ 个数根据某些性质、关系组成的向量表</p><script type="math/tex; mode=display">\begin{bmatrix}a_{1,1}&a_{1,2}&\cdots&a_{1,m}\\a_{2,1}&a_{2,2}&\cdots&a_{2,m}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\cdots&a_{n,m}\\\end{bmatrix}</script><p>称为 $n\times m$ 的矩阵，记作矩阵 $\mathbf{A}$。</p><p>若矩阵 $\mathbf{A}$ 和矩阵 $\mathbf{B}$ 都是 $n\times m$ 的矩阵，则称 $\mathbf{A}$ 与 $\mathbf{B}$ 为 <strong>同形矩阵</strong>。</p><p>若矩阵 $\mathbf{A}$ 和矩阵 $\mathbf{B}$ 为同形矩阵，并且 $\forall i\in [1,n],j\in [1,m]$，都有 $a_{i,j}=b_{i,j}$，则称  $\mathbf{A}=\mathbf{B}$ 。</p><h2 id="1-2-quad-​-特殊矩阵"><a href="#1-2-quad-​-特殊矩阵" class="headerlink" title="1.2$\quad$​ 特殊矩阵"></a>1.2$\quad$​ 特殊矩阵</h2><p><strong>方阵</strong>：有 $n$ 行 $n$ 列的矩阵。</p><p><strong>零矩阵</strong>：每个元素都是 $0$ 的矩阵，记为 $\mathbf{0}$。</p><p><strong>行向量</strong>：只有一行的矩阵称为行矩阵。</p><p><strong>列向量</strong>：只有一列的矩阵称为列举阵。</p><p><strong>单位矩阵</strong>：主对角线元素均为 $1$，其余元素全为 $0$ 的 $n$ 阶方阵。</p><p><strong>数量矩阵</strong>：主对角线元素均为 $k$，其余元素全为 $0$ 的 $n$ 阶方阵。</p><h2 id="1-3-quad-矩阵的基本运算"><a href="#1-3-quad-矩阵的基本运算" class="headerlink" title="1.3$\quad$ 矩阵的基本运算"></a>1.3$\quad$ 矩阵的基本运算</h2><h3 id="矩阵加法"><a href="#矩阵加法" class="headerlink" title="矩阵加法"></a>矩阵加法</h3><p>只有同形矩阵才能进行矩阵加法。</p><p>矩阵加法即同位置的数相加。设 $\mathbf{A}$、$\mathbf{B}$为 $n\times m$ 的矩阵，$\mathbf{C}=\mathbf{A}+\mathbf{B}$，则 $\forall i\in[1,n],j\in[1,m]$：</p><script type="math/tex; mode=display">C_{i,j}=A_{i,j}+B_{i,j}</script><h3 id="数乘运算"><a href="#数乘运算" class="headerlink" title="数乘运算"></a>数乘运算</h3><p>数乘运算即矩阵中每一个数都乘这个数。设 $\mathbf{A}$为 $n\times m$ 的矩阵，$\mathbf{C}=\lambda\mathbf{A}$，则 $\forall i\in[1,n],j\in[1,m]$：</p><script type="math/tex; mode=display">C_{i,j}=\lambda A_{i,j}</script><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>两个矩阵能够相乘，当且仅当其中一个矩阵的第二维等于另一个矩阵的第一维。</p><p>设 $\mathbf{A}$ 为 $n\times m$ 的矩阵，$\mathbf{B}$ 为 $m\times w$ 的矩阵，设 $\mathbf{C}=\mathbf{A}\times \mathbf{B}$，则：</p><script type="math/tex; mode=display">C_{i,j}=\sum^m_{k=1}A_{i,k}+B_{k,j}</script><p>特殊地，如果 $\mathbf{A}$ 为 $n\times n$ 的矩阵，$\mathbf{B}$ 为 $1\times n$ 的列矩阵，那么 $\mathbf{B}$ 可省略一维，记 $\mathbf{C}=\mathbf{A}\times \mathbf{B}$，则 $\mathbf{C}$ 为与 $\mathbf{B}$ 同型的矩阵，$\forall i\in [1,n]$​：</p><script type="math/tex; mode=display">C_{i}=\sum^n_{k=1}A_{i,k}+B_{k}</script><p>矩阵乘法满足<strong>结合律</strong>，即：</p><script type="math/tex; mode=display">(\mathbf{A}\times\mathbf{B})\times\mathbf{C}=\mathbf{A}\times(\mathbf{B}\times\mathbf{C})</script><p>满足<strong>分配律</strong>，即：</p><script type="math/tex; mode=display">(\mathbf{A}+\mathbf{B})\times\mathbf{C}=\mathbf{A}\times\mathbf{C}+\mathbf{B}\times\mathbf{C}</script><h3 id="转置运算"><a href="#转置运算" class="headerlink" title="转置运算"></a>转置运算</h3><p>矩阵转置就是将矩阵行列调换位置。</p><p>设 $\mathbf{A}$ 为 $n\times m$ 的矩阵，设 $\mathbf{A^T}$ 为矩阵 $\mathbf{A}$ 的转置，则 $\forall i\in[1,n],j\in[1,m]$：</p><script type="math/tex; mode=display">A^T_{i,j}=A_{j,i}</script><h1 id="二、高斯消元"><a href="#二、高斯消元" class="headerlink" title="二、高斯消元"></a>二、高斯消元</h1><p>高斯消元是求解线性方程组的一个方法。</p><p>如，对于下面这个 $n$ 个未知数的线性方程组，求解每个未知数的值。</p><script type="math/tex; mode=display">\begin{cases}x_1&+2x_2&-x_3&=-6\\2x_1&+x_2&-3x_3&=-9\\-x_1&-x_2&+2x_3&=7\end{cases}</script><p>我们可以由此构造一个 $N$ 行 $N$ 列的增广矩阵 $\mathbf{A}$，其内容为各未知项系数及常数项，如下：</p><script type="math/tex; mode=display">\mathbf{A}=\begin{bmatrix}1&2&-1\\2&1&-3\\-1&-1&2\end{bmatrix}</script><p>同理，我们也可以构造一个列向量 $\mathbf{X}$ 和列向量 $\mathbf{B}$，分别包含各各未知数与常数，如下：</p><script type="math/tex; mode=display">\mathbf{X}=\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}\qquad\mathbf{B}=\begin{bmatrix}-6\\-9\\7\end{bmatrix}</script><p>我们就可以由此转换为矩阵方程：</p><script type="math/tex; mode=display">\begin{bmatrix}1&2&-1\\2&1&-3\\-1&-1&2\end{bmatrix}\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}=\begin{bmatrix}-6\\-9\\7\end{bmatrix}</script><p>我们的目标是求出矩阵 $\mathbf{X}$。根据矩阵乘法具有结合律，我们可以设法让等号两边同时乘以若干矩阵，使得矩阵 $\mathbf{A}$ 成为单位矩阵，即可求出矩阵 $\mathbf{X}$。也就是说，在主对角线上的数，通过变换，使其成为 $1$，其他数成为 $0$。</p><p>考虑在保证数量关系的前提下消元，使用如下方法：</p><ol><li><p>对这一行消元，使得该行对角线上的数为 $1$。也就是除以这一行对角线上的数即可。</p></li><li><p>对其他行消元，利用对角线上的数和其他行的数的关系，使得其他行不在对角线上的数为 $0$。</p></li></ol><p>如此重复处理，直至形成单位矩阵。</p><p>注意，等号左右两边需要同时处理，才能保证等号成立。所以我们可以直接合并两个矩阵，更方便地直接对一个矩阵进行变换，如下：</p><script type="math/tex; mode=display">\left[\begin{array}{ccc|c}1&2&-1&-6\\2&1&-3&-9\\-1&-1&2&7\end{array}\right]</script><p>使左部分矩阵成为单位矩阵后，右边的列向量就是答案。</p><p>我们可以进行如下操作，即 <strong>初等行变换</strong>：</p><ol><li>用一个非零的数乘到某一行；</li><li>把其中一行的若干倍加到零一行上；</li><li>交换两行的位置。</li></ol><p>进行如下操作：</p><script type="math/tex; mode=display">\left[\begin{array}{ccc|c}1&2&-1&-6\\2&1&-3&-9\\-1&-1&2&7\end{array}\right]\Longrightarrow\left[\begin{array}{ccc|c}1&2&-1&-6\\0&-3&-1&3\\-1&-1&2&7\end{array}\right]\Longrightarrow\left[\begin{array}{ccc|c}1&2&-1&-6\\0&-3&-1&3\\0&1&1&1\end{array}\right]</script><script type="math/tex; mode=display">\Longrightarrow\left[\begin{array}{ccc|c}1&2&-1&-6\\0&1&1&1\\0&-3&-1&3\end{array}\right]\Longrightarrow\left[\begin{array}{ccc|c}1&2&-1&-6\\0&1&1&1\\0&0&2&6\end{array}\right]\Longrightarrow\left[\begin{array}{ccc|c}1&2&-1&-6\\0&1&1&1\\0&0&1&3\end{array}\right]</script><p>然后消去右上角：</p><script type="math/tex; mode=display">\left[\begin{array}{ccc|c}1&2&-1&-6\\0&1&1&1\\0&0&1&3\end{array}\right]\Longrightarrow\left[\begin{array}{ccc|c}1&2&0&-3\\0&1&0&-2\\0&0&1&3\end{array}\right]\Longrightarrow\left[\begin{array}{ccc|c}1&0&0&1\\0&1&0&-2\\0&0&1&3\end{array}\right]</script><p>此时，右边的矩阵就是 $\mathbf{X}$ 矩阵，即，解得：</p><script type="math/tex; mode=display">\begin{cases}x_1=1\\x_2=-2\\x_3=3\end{cases}</script><p>为了更格式化、更方便地处理问题，下面给出高斯消元的标准方法。</p><p><strong>高斯消元法</strong> $\quad$ 对于任意一个存在 $n$ 个数、$n$ 个方程的线性方程组：</p><script type="math/tex; mode=display">\begin{cases}a_{1,1}x_1+a_{1,2}x_2+\cdots+a_{1,n}x_n=b_1\\a_{2,1}x_1+a_{2,2}x_2+\cdots+a_{2,n}x_n=b_2\\\vdots\\a_{n,1}x_1+a_{n,2}x_2+\cdots+a_{n,n}x_n=b_n\\\end{cases}</script><p>构造一个 $N$ 行 $N+1$ 列的矩阵：</p><script type="math/tex; mode=display">\left[\begin{array}{cccc|c}a_{1,1}&a_{1,2}&\cdots&a_{1,n}&b_1\\a_{2,1}&a_{2,2}&\cdots&a_{2,n}&b_2\\\vdots&\vdots&\ddots&\vdots&\vdots\\a_{n,1}&a_{n,2}&\cdots&a_{n,n}&b_n\\\end{array}\right]</script><p>对于每个未知量 $x_i$，找到一个 $x_i$ 的系数非零，但 $x_1\sim x_{i-1}$ 的系数都被消成了 $0$ 的方程，利用初等行变换把其他方程的 $x_i$ 的系数全部消成 $0$。</p><p>需要注意的是，如果有任意一个 $x_i$，找不到非零的方程，则无解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 105</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++) cin&gt;&gt;a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> nowi=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="keyword">for</span>(t=nowi;t&lt;=n;t++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[t][j])&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t==n+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=j;i&lt;=n+<span class="number">1</span>;i++) <span class="built_in">swap</span>(a[nowi][i],a[t][i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>;i&gt;=j;i--) a[nowi][i]/=a[nowi][j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==nowi) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=n+<span class="number">1</span>;k&gt;=j;k--)&#123;</span><br><span class="line">                a[i][k]-=a[i][j]*a[nowi][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nowi++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nowi&lt;=n)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,a[i][n+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、矩阵求逆"><a href="#三、矩阵求逆" class="headerlink" title="三、矩阵求逆"></a>三、矩阵求逆</h1><p><strong>逆矩阵</strong>$\quad$ 对于一个矩阵 $\mathbf{A}$，若存在一个矩阵 $\mathbf{A’}$，有 $\mathbf{AA’=E(单位矩阵)}$，则称 $\mathbf{A’}$ 为 $\mathbf{A}$ 的逆矩阵。</p><p>现在给定一个矩阵 $\mathbf{A}$，求他的逆矩阵  $\mathbf{A’}$。</p><p>我们可以考虑如下的思路。我们可以通过构造多个矩阵，考虑将矩阵 $\mathbf{A}$ 消成单位矩阵，也对 $\mathbf{E}$ 做相同操作，这样一来，就可以得出 $\mathbf{A’}$。</p><p>进而，我们通过矩阵乘法，构造多个矩阵，有：</p><script type="math/tex; mode=display">\mathbf{A_1A_2\cdots A_k A=EA_1A_2\cdots A_k}</script><p>得出答案</p><script type="math/tex; mode=display">\mathbf{A'=A_1A_2\cdots A_k}</script><p>简化考虑，我们的目标是将 $\mathbf{A}$ 消成 $\mathbf{E}$。因为矩阵乘法具有结合律所以我们可以同时在 $\mathbf{A}$ 和原单位矩阵 $\mathbf{E}$ 同时进行高斯消元，目标是使 $\mathbf{A}$ 成为单位矩阵。即对于两部分的矩阵 $\left[\begin{array}{c|c}\mathbf{A}&amp;\mathbf{E}\end{array}\right]$，对左半部分消元即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 405</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n,a[MAXN][MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) w=w*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) cin&gt;&gt;a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i][i+n]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> r=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j][i])&#123;</span><br><span class="line">                r=j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r!=i) <span class="built_in">swap</span>(a[i],a[r]);</span><br><span class="line">        <span class="keyword">if</span>(!a[i][i]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>),<span class="number">0</span>;</span><br><span class="line">        ll x=<span class="built_in">qpow</span>(a[i][i],mod<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k==i) <span class="keyword">continue</span>;</span><br><span class="line">            ll t=a[k][i]*x%mod;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=(n&lt;&lt;<span class="number">1</span>);j++)&#123;</span><br><span class="line">                a[k][j]=((a[k][j]-t*a[i][j])%mod+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=(n&lt;&lt;<span class="number">1</span>);j++) a[i][j]=a[i][j]*x%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            cout&lt;&lt;a[i][j+n]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、行列式及求值"><a href="#四、行列式及求值" class="headerlink" title="四、行列式及求值"></a>四、行列式及求值</h1><p>行列式和矩阵相似，都是用来解决线性问题的工具。</p><h2 id="4-1-quad-行列式的定义"><a href="#4-1-quad-行列式的定义" class="headerlink" title="4.1$\quad$ 行列式的定义"></a>4.1$\quad$ 行列式的定义</h2><p><strong>行列式</strong>$\quad$ 对于一个 $n$ 阶的方阵，它的行列式记作 $|A|$，其值为：</p><script type="math/tex; mode=display">|A|=\sum_p\prod_{i=1}^n a_{i,p_i}(-1)^{\tau(p)}</script><p>其中，$p$ 为 $1..n$ 的排列，$\tau(p)$ 为排列 $p$ 中的逆序对数。</p><h2 id="4-2-quad-行列式的部分性质"><a href="#4-2-quad-行列式的部分性质" class="headerlink" title="4.2$\quad$ 行列式的部分性质"></a>4.2$\quad$ 行列式的部分性质</h2><h3 id="三角行列式的值"><a href="#三角行列式的值" class="headerlink" title="三角行列式的值"></a>三角行列式的值</h3><p>对于上三角行列式，其值为主对角线的乘积，即：</p><script type="math/tex; mode=display">\begin{vmatrix}a_{1,1}&a_{1,2}&a_{1,3}&\cdots&a_{1,n}\\0&a_{2,2}&a_{2,3}&\cdots&a_{2,n}\\0&0&a_{3,3}&\cdots&a_{3,n}\\\vdots&\vdots&\vdots&\ddots&\vdots\\0&0&0&\cdots&a_{n,n}\\\end{vmatrix}=\prod_{i=1}^n a_{i,i}</script><p>由定义即可推出，证明略。</p><h3 id="某行乘系数-c-，等于整体乘-c"><a href="#某行乘系数-c-，等于整体乘-c" class="headerlink" title="某行乘系数 $c$，等于整体乘 $c$"></a>某行乘系数 $c$，等于整体乘 $c$</h3><p>即：</p><script type="math/tex; mode=display">\begin{vmatrix}a_{1,1}&a_{1,2}&\cdots&a_{1,n}\\a_{2,1}&a_{2,2}&\cdots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\ca_{i,1}&ca_{i,2}&\cdots&ca_{i,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\\end{vmatrix}=c\begin{vmatrix}a_{1,1}&a_{1,2}&\cdots&a_{1,n}\\a_{2,1}&a_{2,2}&\cdots&a_{2,n}\\\vdots&\vdots&\ddots&\vdots\\a_{i,1}&a_{i,2}&\cdots&a_{i,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\\end{vmatrix}</script><p>由定义即可推出，证明略。</p><h3 id="交换两行，符号取反"><a href="#交换两行，符号取反" class="headerlink" title="交换两行，符号取反"></a>交换两行，符号取反</h3><p>即：</p><script type="math/tex; mode=display">\begin{vmatrix}a_{1,1}&a_{1,2}&\cdots&a_{1,n}\\\vdots&\vdots&\ddots&\vdots\\a_{i,1}&a_{i,2}&\cdots&a_{i,n}\\\vdots&\vdots&\ddots&\vdots\\a_{j,1}&a_{j,2}&\cdots&a_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\\end{vmatrix}=-\begin{vmatrix}a_{1,1}&a_{1,2}&\cdots&a_{1,n}\\\vdots&\vdots&\ddots&\vdots\\a_{j,1}&a_{j,2}&\cdots&a_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{i,1}&a_{i,2}&\cdots&a_{i,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\\end{vmatrix}</script><p><strong>证明</strong>$\quad$ 不妨设原行列式为 $|A|$，变换后的矩阵为 $|A’|$，有：</p><script type="math/tex; mode=display">\begin{aligned}|A|=\sum_p (-1)^{\tau(p)}a_{1,p_1}a_{2,p_2}\cdots a_{i,p_i}\cdots a_{j,p_j}\cdots a_{n,p_n}\\|A'|=\sum_p (-1)^{\tau(p)}a_{1,p_1}a_{2,p_2}\cdots a_{i,p_j}\cdots a_{j,p_i}\cdots a_{n,p_n}\end{aligned}</script><p>可以看到，两者的唯一区别就是 $a_{i,p_i},a_{j,p_j}$ 和 $a_{i,p_j},a_{j,p_i}$。</p><p>由于 $p$ 为前排列，所以可以忽略 $p$ 位置的影响，只用考虑调换 $p_i,p_j$ 对 $\tau(p)$ 的影响。</p><p>考虑每一个 $k,i,j\in[1,n],k\not=i,k\not=j,i&lt;j$：</p><ol><li><p>若 $k&lt;i$：调换 $p_i,p_j$ 之后关于 $p_k$ 的逆序对数不变。</p></li><li><p>若 $k&gt;j$：调换 $p_i,p_j$ 之后关于 $p_k$ 的逆序对数也不变。</p></li><li><p>若 $i&lt;k&lt;j$：调换 $p_i,p_j$ 之后关于 $p_k$ 逆序对数会 <strong>成对地变化</strong>。</p></li><li><p>$p_i,p_j$ 位置变化会带来逆序对数变化 $1$ 个。</p></li></ol><p>综上，变化之后 $\tau(p)$ 的 <strong>奇偶性</strong> 会发生变化，也就是 $|A|=-|A’|$。</p><p>证毕。</p><h3 id="若存在两行对应成比例，则行列式值为-0"><a href="#若存在两行对应成比例，则行列式值为-0" class="headerlink" title="若存在两行对应成比例，则行列式值为 $0$"></a>若存在两行对应成比例，则行列式值为 $0$</h3><p><strong>证明</strong>$\quad$ 构造符合要求的行列式并进行推导：</p><script type="math/tex; mode=display">\begin{vmatrix}a_{1,1}&a_{1,2}&\cdots&a_{1,n}\\\vdots&\vdots&\ddots&\vdots\\a_{i,1}&a_{i,2}&\cdots&a_{i,n}\\\vdots&\vdots&\ddots&\vdots\\ca_{j,1}&ca_{j,2}&\cdots&ca_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\\end{vmatrix}=c\begin{vmatrix}a_{1,1}&a_{1,2}&\cdots&a_{1,n}\\\vdots&\vdots&\ddots&\vdots\\a_{i,1}&a_{i,2}&\cdots&a_{i,n}\\\vdots&\vdots&\ddots&\vdots\\a_{j,1}&a_{j,2}&\cdots&a_{j,n}\\\vdots&\vdots&\ddots&\vdots\\a_{n,1}&a_{n,2}&\cdots&a_{n,n}\\\end{vmatrix}</script><p>可以发现这个行列式有两行相等，设其为 $|A|$，可知，交换两行后矩阵数值不变，但等于 $-|A|$。故原行列式值为 $0$。</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『初丶晴』旧忆</title>
      <link href="/2022/11/10/%E3%80%8E%E5%88%9D%E3%80%81%E6%99%B4%E3%80%8F%E6%97%A7%E5%BF%86/"/>
      <url>/2022/11/10/%E3%80%8E%E5%88%9D%E3%80%81%E6%99%B4%E3%80%8F%E6%97%A7%E5%BF%86/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="欸? 这个『通行证』看着不太对, 再试试看呢..." data-whm="密码不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="877397058d69fbe6edc85df5b7b78048b84c3dcef32bf476226a029a2028f861">8dfed501bcaa90b15714e3bdc993ce4cd992d53dfa3b2cc635d9ae939003f1ddcc424989075bdf424c5cb8f31000e57a9db4b0b97597d7d935821682bf3633ff21d58cd00a65cb714708a23bf10fb09377480104872d1577718545a026e87b6e6be02b88d273d406a950b47a793c882a7470ea4c5017db39affbb2e39d72717ac5cd1d81c9baf73b9079980cd02c11d247255c572085c52950588f545554569cee49b9890d2ef11cd0eefcf42540be2056ab5a2c061677512c5fe71ed8887cbf5143b2cbd6c0c6574e2e426ab510262a6c548f4134bef635c2d83f98074d8ffd623e89c11289bd340406a6c974896c7cf6c0a499c2f3f636631f25f6140ee07d550e4e1405e062c543fc3253bb8a6816e6cdea657ff2d1fc2758ff456b6dbb3d2fde932ee9f3adb8a30afb6e0d760b6e7cfafab421de701e4c58b68527358671dc8ce99da15f8973336cc8bcb4eab3e40d9eaa2151ce0c67d3ba312c87aabe66fceb5b2156240356a1a4ecb955a10987d592512001bb636130961a818fbed78c267768be7f069cb363e03f812db02c7f649b2e4b5af001a02b13934741550141fa85e2120d4a95afbd8e25186ff2aef24199fde811e12e8db9957f83d34ada2e2c59b99f4fdcecd73d24ace3a641fa4b926abf1896e1597f5afd90fa2532f3c4ee464319b8193d11abe21c41b95afbb018c9b2153f5b8b4838fddab0686a5f0b67d64e354ba8e85c65309f68f4d64ec85f575317697616e742275def672afac6bf9849e5377bc16dc5aed6745c061fecf8c6dfd4bf2008a0a3a369764be7f40135bff1d6c3353da7fb8201c260674018387492526eae093da7faaf7decd8381e645c9b3cd38e1904685230fe51cd824b489a7caf91cffd45364f8fb6e03ddd481a35732cf5c4379e6f5d1739928f9e0d5c55bfecec13db4d1167dcb3234fc165dea0eda766d181b1c7f39c98977339a69079e6408b98ab3325a26385e65a451d74c98da1239bc8b616e3e0ec043e3300ef63134a1fff5f0a6df73250f177eb19e013e18d74435facff95476483a748fc392d50e2350a111ec6a05b8062cc49b1b21d9f79574102822e7101b70d16e5a4fa7f73c07d5d8e51b7b8192eaa64b79c12fddc1e3823c7c9247af7c7c4d3c29507856b626e119db4176e14a58759d228a7879ebc2091df245b8f8fe7dae26b1494d1b11fd0015c0e62657af0531d74871d735cb728e5df8990f62955ed40bfe2b41fe33bdd9537f3192458de999a554ac094bbd044740c94d833a66461ef69b77d9fca0efb8ca1850720239fc0285635732d9edac314286dbf47f0b4af9b97e840cf6e29b30f957d7b6e1a4b7041a60968e9091e495f517064151eb950857d482e6e825a622109c2522f39a472e85e2821da2b83dc4d743bf3a6f043e89bde899eba6a7a5fceb9c22575570a5dd6771530974fec3039f6eda3cda2beb98962d9316aa7ff9b2ae59589624616cf8b258618f9a72ff6eb6af9ed3ec338f5a498daf0ce480c230857f35ff8e100a3e0b2caf721b19516b288ed6488d354ee2a457f941215383112234c14b6707c091cd3cd8cf8d4597196ac15a9161c458bcb579f5f105760de12509e71fb36a05870b78c294d93bc94648d7de3a34abd6827b549688891686af0131838a288e859f7b5d0ff1c0d4a307c18d3ba4e65724b05e962b16c514b2d80563d8eab2c5d1cc9609a0554f4fcc240a9bce59af5da805b6bf048ba282036917e98be6d4552d2dec130ee0cf68a8bb96553579ade317eb915415c635d921e5f65a70a61e93070fa0872057417d9abbbd93c9d9e3e4599c2cdabe884bc1ec2c71d8a2be87e855f20af135be6b1cd0b1202c0f092059997f6126c3f481163e8efd2a9992cfbd2024286d0a84f45e722bc871027ea9417859593cee38d82c7711b5403308d2dbc115c72270492d8ebd5dd1f4c3a6be4605b90a0afafd6836548811d0b5640d1742ec399719adde3710784663c9c32ca19a53fe0e79b4622785ac7e51ed0deb5345bd470fededae9978fc5763abf6a426656650fbc35a9b05142f897574da5dd019e7f9acbee15daf3f39117c78df87ce7d59927a0cf83625b2dce7dc5258ac9d8687e7c471c67ea77ca66d33173aa7de71bb8726a23570aff1c7ebc81c58245568a62a3c8c37da4d58f99e1a3a9fe90516882165be5a32c03a8c04310c87ad083818f0b1c7e4b779ac9f0a8d41f4d3f4b0522f47d061c92cf7ba7fe5fa5a0c7c510ad3e40a0ef41c44d6e198660d9616a6fcde6a20c9ade1ef108f535fb7d416309200efd44b8b03a06a8bbc0108242da56f35ddf5ac6f2c14d9af5932b2d041570f7ec76989f0e0cd38424e2ecdbd2dcc253423002d30a714488d38f66b2e6b3fe091d1e04c11fc552aa42c976834e901f0b645dcd2d3c0cd43cc240cbc75ce62af4e1a80855e24515c9adf521f63d5cc84704bc25cbe9355c149522a0966931766686d267e50aa1564259d64859f452ee1eb81f61c00a0a60eff54cb5f7ab05263c2aa5d2a0fdcd258b5065436e62c47e99755ea8c0bb50c3a8edc6be32439a3fe314d238680ca929a2da8f16691de502efe3253e324bfcbd79d1d3881b19a6061632ccee9c493541bdb11a33afb5c10dadf1d32c1477ed9dfbc3cac3965d85d5e836a04f3b7083c409c37179458ece2608ed6c384c653796cdd5246f54ec8dd5789ffcba87757375f93ee45cf8258a4c0b56cc96d09a4a48b1f3847931f20e2dca2bb6e365ddc1a76ccde6339a8a2a93b98b3e34e9c8b0915e8b3e30f39fc182dc992aeb30f45ead0355e11da2be40f7243d69b2baa78038158daf45f401ad9313bda451d3219fb19082d94d5fd1b52fbf1d48401bdfeba60bcb705795009ee701c356a6f38451836118e6c0e5c106eaca3d78ab526d9e3c678a2ff2e59ecf43e8f5968e636435e27b41126f70e3c4ef9c83cdf6b2d38c37fb14484d3e3e0c508f2e84dc59061e34f94287fe6719bc40b2e396431312ad39b53daef3eb8f0be6cf12dddbfe81d07423bab5b1f33dcb9369c5523a759861d8cf1920338abd31fd0058ff6dafcd9853b39b27d5e7f252c53864455abe573d0219af5f73a41df976fd9b9d89ade924eeccb6bbf00129aa1858d55565d3d2891c55b267cef1a3206f4d5618538015b07f0f85ac8fb826da9e38329a9f079d853aed5e139123fd4ecb0264624b2ee4fc0d6dbd8dd834b7711f87bb37dd7776e9f5f126191f3c16578cd0a9845ea2d5e9247bbcf4791fa2e15f1928500bc30aa44a64883d2fc5844173276b16a67a3c902114b600d1f1d0090b7b7dbf279ba8c0caa6d00ee9bd90882fba81b5d0774b2934337320e7022a5d488204c026e7943fb601026e41c0b946d52b1f1a5a309c6669040586e50fc104ad9ed50bf9f22af238515b2d081794abd2488d15c346319375eb16c72381fc8c96ccdb2230dfdc73afa5bc841f8e5e08484b5f9eec731f1375911dd73719af8b0bd37139aa94abd12ff00c5836693b18b30365e346cdc43c6b3a98f2d21a8491be970934e2fc5e2669ebc4c45fefe803e491cdfdae97898cc0baadd47f1b12b2ed0cd968893e87cb5b07fdb95e7d7785743eeb5eaf12db02ccab9d0cae08bbd0884fcc96657bd9004e23c9a0228ce1b395db14edac61e16148d21445117758a83a24d513ff558c4925e758489b4f0e249ab56c18ace09009a205a82a0b9fe5f1eba8a8e1609ca7f89a330c3432b30aa7697eef0d0a62e3d8ebd4e8885f098bfe3cd275e0a17bb120bc0a6640c5cbca2e9efa3276652eb8c5b839aee50bdd4dd67b7fb8d1672e63ef28d062f9e20835be71b92238ac8ce538872304743887c7e659ad0642423b5320d8a8f374e5223ec588017479cae7c064256aec448a2afcdcacd953ab94ff0b03a099fef521554be61ed77eb42769d2ceedbf480b8356e034197c022bff569501f147b84a1ebfb6ac09f8cc6e31ff28f5a8bea43c1c98a8ef95de0942a9b01fd9f010d7960fc618b3c4f916ad28504a0d17644a425a979c2888879ed1afd5042b6ef09e89864f5198b23edb7bfc5505f4b671f941fd0a10089b7b3f1c86ab1eb02856569f9e2b3deb1bd9abf99bc7a519e813ed00a0b0488ab31ae65ff06bb45ef10a3248a6b7a855ab83fb4ef340967aa7ec85e43c9b15c9fd2d5f137008a9d074608f2ba0477a310dadae20a576ef845606c63d03a148da9480e1c6b75d48bddd1d1a7a1ce5e51ba8b803cb0b899b747d798b77d320e259a2216601ef14b042ef5487d5a619c7223a6136f01c477defbb3f0d654a1cc4b6740258257a50d6e7b44be1ac160294a2275575fa1a87641b64966d611590c553363e460533dfe8ed1b792934c4a031037a16d86f816125fcbc73ac412423cd2b30f8f97d78f6c392f7920985ddd4beaea0a34a9e69e5459612ed92a0c9874a0c05d57c0757c2151959fa8e716c5b42d229aebac3d773b8f2e01388de78e567f71d717eb37950640409466b755ffae786dbc84776176d54c6f291388c716d2107fb37c8a06f6d54ed1655efbe43c5946c32d62897a9ca48c8dcc078766ffb24728cb2e31af6b578afde70827807bdce91df2e515065b9bb0b7f2f31561b9b92bca3eed71cf9990aeea522c51b0b778ba7c9efa12c0cff0b0a942924c938a21ecadf0b72c16d82fcd85d7aaa1ca9160834c2119660ccc902c805b51b9e0ddd6fd47ee4ee71ef5f0707b32bac989c4a324a39dda6dd50ad47f3d072412890b25596b46e77261caf348d7e17e7c29343a615ce1eab4da64830278ba319926e6bba0199297f28a2679e3873af5fbef9b9cddf70bb3af216253ebb89dec7c6819f1b71fdd9cbf444f97a6367f5c1570f4fb4a206f1c6b26baff132a50a857cb2c20cebdafc5af6658baca683d2d2b56078ab153676fefe3f945dc0bf1c5392ddbf172bfee09db2eb8923fb4f3251e02d650203362d35b982436fc98d1154b12e2075b7dc38b558d859e4423e92671bd3c2da8ac8d76959b05d82dc2ee127b0bdd8eba51055a509f00d99b40a224f9b7eb2179ff83570fe02659b8467c6816dacc95ca977df26104555d6b973851fd7efd90f4f112b16b9c34b64216c8d6d0181e2387242ba4f5c8b43d7991b52d076e1f087c9f494c3ae9aa0b609fd62b02a0f3f3b2d71cac7b729295b3fc57b989bacda9a7331ea15a0b5f12908a9f211b36560befe9fe979307fcde2cf61d130e105e67f3150385f4ed1f30f9c537b068cb6fd3370195cf157300ff193a78f905ba99da04c009f6900fa9e051d6bc9e1644a2e25a14ba61c87fa32620564124d6eceb054dcb8bbafeece4bd8c373a020b777e59016d8a170f096be5de725239ee8eb4f2270656779bb8b44f1cffb56acaf4bb2bd41c99fcb200d94c4c2bc9d6b823ecf3287d48f6ddd7dcb1bb5f364ca5f449175ffd34985d9c2175ee24e1f70607e31017d3a2362b6cf12756a21e972a0a4abbd7c993cd4b763fbab1a85da1c218e244b3190f98d21d9ccb3c6f6653dbd9dd64cf6213a96521fc75fdbdf9a1ccf3eaf1223318045bd7e2958cc750d0339d3b485f681172ce461d5e2cc296c89b9b899e77781c0130b3738905ae9fb4d1168ba17614d99b36694dd7c6762fafa8c08e4f2de7b908b1587bfe0fedda3de5c43cac4f7f92887622d4b05e66407498fcc8a1d7ca5dc9cea1c6a0aa3b7da6387f5401b4bc021d1f4e070975c62fd4bba9e0b2d3c1d13aad552ad3f05ea4aca78110c86e0cd2fb1644399d5c5a3951b6b38b1af1459bcbe58f459e0ef9c289866aecc74f6d3f07ed8d0d25f524946d4b88bbf8d5bbd637fe6d587e9df07e1080d05c2b3b831e436516a39b28b840199829011f1853f31ab7b33311c70771e39f5a2297835cbbf80086e5c9149c1faeb9156dea824f749946303cb3e0148508bb600c9adede8105bfbbc7582d315182c65f8d17622bc484d231dbb5c951fbc1f1c1f358d0a51497e110c25eb12aeb8940c19c0e507cf0fc4b9a3a3ee33f11d04405dea5ff5eb06071f264d9f7954cf96a4cbe3359bc98c2055986afbbed3c2a90500013ac416e924e9cb494b8d68dfa3731099bc25113b030341281480f43b5da63c931205fffcacb65981fcc0dff70be451d2b3585ac6566c480b02ca7295707ffa244e867c98eaa86e56d257cd28b22fbd15805d86df30016fc3c0f6acc6293038f2919f125b614d1253b6b286123fd7eaaffd7cd31a0a223c608a1d19293fc223ad3d7fd8ef595098098b9a2a989ed649022629eecde1dc1b348e4c4c40e3eddcbf98da2743086bd39f8d06731ac588463f2600c998078795ea29c1cb7edf7c361b8d2bbcf53969bae904559a639608cfe28cef4c9ff61a99e478c226bd892801d68e21b0aa6a01eb4ef01cb641f6674d0695ddfd268b8ff8cf2cb230a17c1ba4865b0180f94ee3513acf529ac90d621cdf1852a808154fab6d958a7767edabb08bb7ec0e35de00fb9993c2dd6ebbcfddd4292eff2baafd4641e250544f152425b7f05c0faa71c5776d062ef4caab3d28988ec245b8130b654ba865e0b73647c923bacc61129a1d3b1c09923266d6470570ac8dbfe225447dde82cbf059ac88da0658a80abc891c81f9b0f29eca5febd8e549ee37826c4f74698c447ec3ebd8b89f6e2cddfa0dd0c573d4844b605ed338ef96dd3f0abb042adb248c1eab95ff395480138447dc0db40b2371ac5ba4664390f8005e42cd26cf6f97179f132ed543c8eaecfd9573b11072e6683d648d1ea3899c663abf8ec8da83a233c4702eedfd9ba4ec9fdf27b6044f4b8a7c73ab62c9bc8f147c10016df665630333233b3814cad35212dc2b2616a99356c0d42f6820c96bd8ae5f086183a26ebe0027516205aeae04e8a957c73608c9742ba5d4db5bd95e54048c44661ff371ca5e3d46c2ac9b54e4758372ffdba73b9b291267378639f308e181fc1a638673228f4a7b9f520248e45fcdc905a620cc2efc7b1bd04e73a4f2d5e8a55195bfafcf84b2ecddfdc5d095f39f0cdccd40fdb29270458d2b666bb9b696d0ab8a3d863ae8d2e9b542c3713a7c1b7ebf1cdacf53deaf73939914e0c7661322da1b79939788fbb348cb2a9b0f6b994dc728cdc247ab3416d55f5825ac45c8f0ed3bade2e3afb9e27073081f30dcf6c600c8f18f0835794a9122c2d1337ae6b67b8026dd14a82fee9c633a44ca431619763f33d38c9a907ea71b0764d2e53c6ce632261dd86ff4a377a9742c97e66cba06bbc4636173d6d19b8bcdead1f80187da3cad711e2604262f329427f78f5f5f3affd0024b213d9a15964733dacf5ae10112a5ffaa9234fc1c345787a88394aebade0f69561f1c476e8a0f47f6e9e3ad239b2fdfa7a9f5811ab93980c6b6e40ac2215b2749cb2dde6fd0d3ff0845e30dd1aa3fe36dd142e5531b91bb89ea33ebfdc73613f661feab79d7ef1988d037858ce1511aed3f36f28a96291078c71fa42521ab47d38da4050f71489c1a58c6814076ecbfd1e05038db7e042fe6af30ad32c7301ef602a713662c996bcf6dfc0eee372f0572ca0a8a3ac379721e5768a6155992085a10be0fcce07ba5d07675dae6aab0a2b7ae5139fc548b9be12d65e1e99d24b49e8064b26a7d0c3fc2bc45c1b3530658497f4bd92e1ad0371958dd23eb4a28ad55ef9826272972d593ac9d13f63ecb9e57d8496ffc0192e2586bac423cd76fc75cdb24d29c54867cf1f6fe979ed8a30b7d0e4532586700fabb1715952b98b8b6d2ba28578f620989da8d1f7f30830ff5e0029b5969468189c1a1a22d316f36ceeb749b59c9b3443472567e3f2eefeabfa4a4a44ec7ae14185928665212f7ed0ee0389a238a373058da9586f3c8c75f8f065e1e30dcd6432ee66249ba8f4e4bcd20f105ca37344b3c7320eaa2115779d4e9c1e3b7d1ebb73f2e1891842037636526d2d4429badb0cf10121c238c94acaa454ea7a4c5d90b22a13bbd36596f4d16864098c425bd90a818e75085eab6da5d9fd75bc5d90c94a6a439c9a4f5f0dae1a1828f09aabaa463d9b41265725c71b20f6c0f215dbd7d47c3a14a8e218eb174ffda8163aed96d1903bd2fe80da9c7eabb238d9a37021347a93e19817e966593e9f3fcd8aa727b5e786ba1b44a12ad21a7aa659541f429ede67f77ca76071e23009a8d6950df715da0c1d14f9d4a023d227bcd494f894d341d4af8afa9b2a74b5024dbc421433b8c0d0971abea1b3ca49ca20b6a32b4ede8d7477b04e3f4de53c240646768dffecdc51da6276896f37daccc7d815b729b8731af6e799832cff2653656209af92b30c91df73fdb1f4185e3602de51c1a3bb74fe82f3dc5ff09921345144eafeb65dde9453025c731ad8f604ba7fa90537e50ec4162b423ba5e3d34659d280b144f38100b11722911d0d84a2d395c1cbbfdf79a0b301b260772cf765ed996195be179ebf04a00723818e02952465399ade60da286b868ea8ed8e990c4db97002f9b452bcf72374f0abf7edfd660e30c0f6ea5962537054b8a94aa736d83db396cd39d695942a85446b47f84ce66891bfc7dfea8417934f80cec529527fa40df3d16e2ebb687e5210188a57e64b2cafd19d86ccd1270a559730dc2fb8108c10664172964de666c09fe834da209284e83fd4a1c65d5ddc999914bd2a47103ca04122b492469dea7b123461f88207464e3826cba87f83db9a4632333933b9e4f69dea6f4c8435a575e68852f1135fc1d5223276f5ee97864f97166164699100e995b969671450ed813ea30e72a9824ec37ab462eb296445156baf1ef7a7ee249490481b76bdf5fc89f526239c309a020099fc1b679589cc67f6016ccf6d34f8f6d97029d89e6c23c4f9069bf4e2118f3eb80b2c0e51364733c6fb016a953a15fcb3ddb88f8494bc31131fe5ac681dbfe07ebdf8e08530479f6c7a3a586aab24fb6dd4484796562bcc7125f2cdf341fa03a5192423363a63bcef9d2c5634aceb91e63a8db57739f8ad318cf6e979db426d8e69b9a7c63d96e52f5e16c7e2454f0f3d7d1ff7d4d453da6897529bfbd7c9049a70a0d1abfb7cd3621e56047ec097e2110b165dddde4d0b17f25a2cd153d8fd363dedc2194d933900fadac1be54a8a5a4851978e2649143f2306930c26ad2ce98a37513b3a3aabe9738ff5a1d523dbf709efd5a163dbd756e9d2bd573d158e8b6563351102f60bda5daff24400fc3c0bd6c3ae97631eaf5da761e31f99dc586d6bbedd72a58d8cdb98d0cd3d2931a72d688cd8da89523be3d7a9693d39399eb62b8e356ebfe8e0e92e4a14061c2f0c238fd734dc85534115b29e73e9b1658d408f38f0a515f16bdabfd3409e3da6f5fb2c10d6869ba9047dfa06c1c81136c7098b8b431c6a4c994031620f522210ae264c91da413d8b354de5d4421fffaa3667fef55c3763339dc4de3448cc506fbafec58f10fd560279f07c5e81148085f1862dbc350c472991ab49204f00077113a4027f1bc124a6ffb02fc4ec4ed8c7d94afa9b7ea1397d2ac271f8a8ae6853bd4ce6154840fed914683e491ccb7af5920682715a391223017003a7785ac2c02c82965967f438f75b479174748d990ce6317a0a17ca50c3a607a6d4661fd16418f0ce0bdadbaad2f194159b3dd1bb2a2f8022a5a99d9e2d8e67809f22386a16e164dd1ee0a6352d0b9867cf3ac87b3629a58f0ee2260adf82baa45b7afae33328df24edf0d057835a1e805457d4b112be847abb7c3f1d2d034e6ac317fb948aa9a5b063b3622c69c0908a0331b07286a82ab754314953da871e11065864b295c960e7024b66c9fdcf5981964de9403603982b4d9f4d476f258286a1ec7034b086f99c7e79380639449e2d51934afd790f062108d5976364d3be7fd47bca9e28947238850ca239085ac8cddfdbe5974857f4aaa90ecfe9b698af5a2fb978056bb904037672697416ce82b3660d98c4033a84e4132a9fc5dcca0996ae08ec45c70dd79859705cc0586d309acee029b747d722318d6a0114aba6a94010fd2f5fc1561d858b38518defcae767f6000f2ca63bc22379a9e7f797b8f4dd4af2182bd28d9eec47e62cdd677c372c898a18ec16822160f25c9f5f4c551eee4a457aca48408e921bdd7e8fd0c4dc7ba9430425ecf63842653c6e21dc43b18511cb98092e417b66e28db774de1f955ad1b39d3b0191989d38c814a261e7b4659304aae7108766e7ec9acfc416d7a584ed5181f4b64127e9c6622b54f79da878ed783acafd6d0142073d590a7f012de39db749fef20ca5603e2e360b65bba8bd5917a4b12cc56e3e01aef40f38f0306601c4b8d213d37f0d47804d34c3e428dbd3d5ffce5b71ea5ed7eade976daf81cdb1b0854c9b5c2953fc8c4f534b9264060ef54e326ac1f5fccbceb4f2580fa6306e239d7b7183c7f17924df0130d4b603b64023cae8c57da6d93110cc46b4a8209aa464aff7a4851d60c1be3fbf58749fca0db037d7e08928a22cee5e8d40b683251c901355e4a386308c62296699f181630ca787e06045c5507963ef1c1d60feb8e8a7220806f30dcc6c5d827fea67715536c9a8f214bffc6db3bdacebee9649e95b81c11a9942d4c0b7a9fd5de5670bbb92a2e8a422963a17fde29478ba24aac13590296d3f0791fcf57ffd158a92ec319fb626cac958c18d265612dd08c0f71031d1cb0a3937bfaad4633885a909a8996b2ebf2534c954495c34e6a5c57b1a95df210c0c4246ce0842a8112d6f8f611897c3d317778ba2139e7a19d84756d8432b4cf86881a5ad16d30df9372fde880361203de61eaf0ce60e41b2dbbb185a5f7953c332f5716566aef265ee2af304894c27c702772a3b6e0af67b79947bae9487e53d5be9f4a01ff3d39449420c9a0821190f2e2f7147083d416059a4bec93333c40d27e2e8ab520a0e02e0426cd7fe158ebae24505993bf1dd759cab97a625504b3c4a18ba016dbcb3d686fedc58a2522aef4c33eda0265637b3f27cd1f6ccd71e06a705000a40b2851d8ee4b5524b7b33e3ca82bf71b59f90631745c29a668460a1ec74fcd567b694f14f9c06fb8a3ef9e4c8ee9751dfe818d0cdb2df7f02ba3d1832adaaf720c236484a2dd893dfbfd33831f55db73e1d4ebb44ba026c533a77654d83af66e231722ae2579cf97681e113e87f896ace569a7da2c2a456bb637307275607c7bc3fe635e97be8e87f2eb2e1c3de779998ddcc9b7460124588c4818b0502b77003c0222a1b69f53352a0d652c6ba687506eedb01dd4ca450903396d771eab0c61e94a8919b7b84c794a12cabecf06021f8e91767aafeb7cc875f709243837f26c0557d6c0dfa335e0fac20afea7f2e6876caccf50b11309f199870b1d8651cfdb21a7c2d92c9a0c1fcb72b5ef9740e71b6511f2605d23d48bf9428d54480dec98e8f41fd06f19dfa87a6392c10bc5814f19c2060a59acf9118821ecc78187d5cca7bc1c7ced036a032a06270b070b3ab64c51ecbd1558654758ddc14a09b9c1e105c9e29555923acaa04c37451573d55853b753f9712764ea8f4cb1a5da934c5fa52d761579564fc733e1089e0f0b12861f8a375d758753af616ddccc3f84b01128e86a364cfe226779726ac3c26ce7249f8801a9aba15d80cb5963b13b026bd5b59f107f3f7baf63672f0b10ba737482a3dea4249264b7262351d09759d8936d1f792cb3c493bb25d8acb12e2e38845258b0aa1028f2600978930d22a2d1045d8727e6b99541257bf72b2d0a96e592ea68bca146d25e6939969fe07b69a7ca14b93c544eb9cbfddcdee61700cc7b1c839c53cdec3365058f9b64b757c780f0a7f2f26adbfd9e5754003a94175f77954efd2622c75185d3d3888f97a50c2cb547dfe2930698fe2f88bfbd0e0887b5a2e7c0381eaa5abfe457c997f2ad9ac34d08b61edd5bede663e14e2ea08866d3a2041d4b972c49e4febd73d9d6cee6164ea1d26c9b719ffa000201377f7f36696b3c0eaa9768efc6c46ff680d5bea255c6430e5367b4e1afad3b5eb0b008ea01ff630551a37c6fe7bf8274d16de34eaf8de05111ef279c1da6f5336771ced453834f5ab1204f62509283b3eb4da1f7805e6e03b8084bc6ef1fdf5e9110574e30e7adf9515092b2334e5a5556e15bcc66cb01e3354c059aa31fb79d41892436a21d32ce385c145b17d2cdfce29c600979bf4557109a6b3fcb4b8711d67b483cfe38b1653bdc83ecb8ff0a2c5b6f02d0e2ba3ded4d674b76ed204a1ba8ed90c42a3cf13d5a7f3ca9568dca634cf749e7b442ee60255e7ef4cee374634345472f6849b44e0456337ac2a895c9921e14724deb4289dfbfd4ebe4afcbb60e3d7939376806d76490c8117db05cd43070bef51b4d67acd4e1a362a5db90f1a9ba19021a386648020d5fdf8c91582c74bd782839d0aafabbb0cc2007a966a2ef1c62f5291a59144da07f02677e4463fbcee3a76d7c55566bc359bcbb89de34cc405d7456391e448a4d1eeba85169f78f980ae02cf492ede7852dcb4e58bbbba64c17fc02baa02d1545c1dce507cfe09f61e61925db76f13516793bef2d33692acf8977fbf1e2aa28fd221c8cc5d353b885b4a5c7949b2fcc69826090a1dd4b510710e0738f9b5e8c261091e3d4d6d00d6f5733faf82041daf5fc83cf434cec18636a3eefcc834ce7010150e80ac8b414899ca1d24241bae87641d3e5fdc6aa444d2d59485648a96bd8b1f1346c1365c9f9443cd82a19f5cb6e3de6ffd4024b913a1fe1b9c55cf8f46565dad54140cce0e0458c0ca845cc8ba90c5606436e7b0020f52cf41318ff44a30f69d7529c3f234fa6541eb84a8c35bc29b2b14823d697ab990e12168c9a546f942202647ae92f0203976237376c6f2becbe1b4a0d158d58372168fc303ebb646054fa851ec887586961f83be1a12f6319afa856e45f484baa034bbe19eaaac5f186246f2a7dcfc23d927bb8fae19121eb3cdffdc7441a05d9bf7654f47e3b0feaed5db31a174e667e2b87e32d7422e56f68cee293afddbb532f78e3a8da780e6904b9800f1a79310abfdda9d2aead5415b60b47b1567b48a3c6fc858f40c40cb3c0de1f0a130da9c82144a9e90a0b2a0f25ebdf3ea7755259556a8d0a27c5658f2149edce8e639df2c6e2bd0f4961416293df8b64b9090f1161b6818554ac8cbd20ca4b142a2f98cc70a63ee19b6b21b35015e997b9b9b4c6decc7a2f6d67706e4b080c2c02f91e7f6e47bf18c3f6b0331e761136a65d1d4c08159c3bcfd3561e8837f4bdd22a21b324b35e52d27c451eab4d1262a3cf2f4e227dcf5f2d2e8d711a4579b48a9cbb594d3c79f19d9fc5e5de919b4e12f4168d293adda8e19470a5c8809887650f57d511a833e7be195564362d7b674a465738725d7d08c9599e7b5a9a8f7e362f767137902892dfca02c009b3fbc5c9bf9e178d05dbfeab5ddf8f37492801896bbdb6ced27097c94ae10285d89603d802472abf72f6188c03244d8c67228f92034fcb1d656f8a280789fb7db85a11afff244260b43dd353fe68ef2625401b02adafb08240986c4e5c0d8c3b9353bf4bf0e698a92a89c9c16057461dabeb43cc2102d98cc33a39ef8b05536e27d941821f84118561b0b9b4427b39ac41ff718366a05721d0c7cecb195472c3961afdb5aba7ea84453ad4ea7bb877eaa4f8083cd5acae88f4ccb25a393c374c85233e22d6d0ec4bd9a115c84d1c427ad4206a0d993cea970c3345f6a30eadeda363e42f04a818fac9c5eb3e4531ffc901e3ea083c74886b390c6c53f95a778e1b0947464e1ce2cc49ddacf7679e05c7e567c1356b66b0b857e5bd8ed3fefea36f71242a7e4ad0b047160495e94172f1b27e6c4f56247db2d231fa7b9c6ed9d886f9a886809a6b23afef72eabd1b02e9f576966a0776ae20a17772ce781f6e155a2b277b74cd0c5221c4b2ece804df0dc349c45ab841de8625cd41fd6e8715831d590bb0aacfb609bb109ae97beaf6ee191bc2acbb3f8149f38b7e6e0a333ed487609184c646cc51fb6e704f441c4f952d5027ccfc0df20bcb7847e67dd2e46243258f7b7bccef074af7a86f5990c9643d435d7842b7e7fee2a94be42592cf2e96451933f20f12fed6dab479e3e727545371f3d800390f48418a6c4ad4108c213429e4893fab6af581f88c0478193ec52a9398cd6e9e988471947ac0f747cdbbda3d11c81e3e1ff531d64037e18a6cb876e8088165decd4fdd69223e8a1923d50d41d4ea4263b0d6d5f39e957302e3aa68ee40437a66d9aeea05412c7739f488fd677f042091078a0c36d2a8c49769e2307ba96c4715b80b5f0645e89c75cb8e1e080800291989d6fed2f47a6eff80ed8f1967fc10970a6f2cc494cc8f315f557638fd0ab885c8c86c5d3c9085765c37c8d93f8492376715babbcdd103447c162b9351e2e7785216e1d167ee344fefde3805f652f73ed4df5c2256b13fc84539245fec991fa9ac8c9727ba3b0af314757eafcba1a161984c429f52ea1c182c5af612de592375a2f2d4b1c9c23b01910043c7d9edd5f2a7679fc57af08b8845629cbd5186486c65c23371ac36ccdbe405e2c8d2951a90bcfe7802f258fe3bcc2baa68124f04c9fb15206cce93433ef78454047cad8d559de8771bc791a8ef8fee1fe596a7351c7bab9c1474ea1fc35ec1265e47b2c8db2c72bc7d7654973ccb8d1b0ee79426149717c8a0397057956b20752221e9c99e8d0b33a2a7742449a66e368b0db46a5890eccba2243fab1f43a9621296a7e561c3f58ed19110526e609cc3a2b331805922459bc4e05ccd5de2f15cacba75d730f1fbfe96345f5ce38db29f02cee3364787c1b430dbbe911e08ed636f3fec52644d114b5a5e68880259807b9535c7e55abd0b2674da2fbf2d69f524f6861ed3f10dd025d592f210229ff1b496aeca5428190f1523ad4828c56631a5c2eae65518e33b0ca6ca27100fe2de74e4459559f6c9f7e7b65fa19cb578ab517a84f4b5b750688e0566feb004fea1cf6c833a53d171abb86b57c50feb873e494c87b32ff422b5ecd9eec9298aa8b32a03f177dd4a38a948950e72df8966f471ff34975e8c047398409fee65482fa56afb5d5a45ad8f17abb5496d7070869ec4577b9cf046681e895350f1bc25e8a8897aff15839b1fddc0db0d8ecbfde4acf22849ee944fb8fe3473be73988a4e60603bcb626a381d4f0bcc225944e31934aa3b2e9ab4dea183be8a8c92523e3968bb79b424e342729253d7b9b79e4497fbc116d457e736cc936f8626801ec933e287a4c7527e8d27f53690cd3088479c427e51495722280b23b56718b652c3822b9d311fa6693ddc6dff5d48926abb5681e11c68ab97d72e95de14ad7299021d5253dda6f0a35a4edab2b0fd562871a1aa7ed98bf105d07ef5cd72fdcbf6edd3a2e5674209587d9f1674e833d71e6f940fcbb79f48bf9d3c92fda7bba28a92f69ae682593ed936b607f2ffa3f99b8948bb0429bed61acb846260616509e62980d49a7c39d73ace36f15026ef7cacad3fc9df16a2e0013e044d8c5d28019a9e1bd6fb03a875b71cbb2a534752bbeb755ff3fa5a2cf970e58f500f8969ab3d11a33b6cc9b0adc1a3d4315304a500c8e435ac227a2418b97b8c523c7864da53cf9d76bc26a3c7955b2052e4418d22ab9b6cf807695c94464a7247db7415cbe0a7ea675173e4dc2c7b518bb8d9e387b99aeea0d2d07757d2286a0327e9e23fc7074a379db04835f51b17f36b0337bcffa324211d4d7fc277f6c59b7a7bcbc9ceba7e55fabd4f404f067a4ddfde7a35b1470579d87218c0e1b4b0f1a1add00ae0d33d71c3eeaa462afe337af778c168cecccf7f2aec0254c2f4c056b37aa79e6128003e4c453261c015035963717eaf9cdb1e927a9f1404c7149c8dacbc6d4a658a43128c8cb6ec66985c8340d54587eba8ab459129ef1ea40c59c92dd2d87689e31f33dc272ff1bb496172ced7140ce7d193762e1d3ddfc2f97dd78afabfe1f2342ddb85385a412f99830ef3be5989d938f39b9763d8cc39e74e2228df03eb2cbf15002f3f24cef7829bf18ec3293efd93203b3f77141973b7166575ad8eeee73ca62e433829df5cc76d739641601e033e16aa093efb7fb8590b79dc84fc97f3b06378ecc0abcc7952fa9415786814b732b1a8226dda37f8b50c1b2a025537125b1d282f45c59183ee52610445c0cb4ed74fd8013f4106f55dfcf1e62c50d4c45a508ce82bdfd8d4874d41d64dd46cb8156443ad91dbae59419ade3e6ea7a16584c27b5ccc1b38b9cb12485e9c304db5eea4e23862f44e66f1bb9b4f14b6429bba0a94321e6a6e88c08f82939014f0a52043e340de336d6828ef995468a5488817f77de1da52abb252f887328fc8eb6c721b97ef2123b27535961bbc2d61e6e797e055b9d181bce49d2999bdb8bb15a5b4ccc597044d10bd9987d24f1b6a5f6119cb8f3aba21134e3f9169a8f5bd6c1583ee7335eb9014e8f78eec3e5bb84746ff0946a36a106287d4f62d8e7f2d29f24620f00c4bc004fde54349deed8afcc9125edc268004f47f33b772008fbf8fa04614710cd7c2e380821efda9389430fc24b9bf289a1761ed5d224bdd4d56b893c3733b926a3a9b021906c1daf79d4f972a58e2d2781e1c677b0d16be08dcefc4a00089a679b89a432cfddfed47b88ed12c9a4a82e9fa381bbad308a5b0ebd519ebe9c8670fb719e05e7303d32ce442d4d332fdef5e87c4ea2c755c00c59752b2acbe305eb3c9254b9a125f82248c66904d10db9c7801ea6a2afa0a07bbdb87dcccb766ac91968de47b77681ea825bf903766c83944f8c4e833bd467f420aabd4b545bcd663bdc0a9fa922c84e897af0e1c43f48e45aaab9b6044565b2eff689d5edec259114a9ab886400d5c94bd10b3b20af8f2b007abe3dab6b14465113c285563569b2ca9eb37c599c0026ee96ebb67f491b02807ca2e15b885de8347694f1586115d0b7640934d50e7b49b9a7cd5ed6a8aea6f6dd412bf342d7f36b08c473c68ab026f1b358f2a386ffe8de7b1c8cc7e21d687440d1a13724846431875250d0719ca456b87aa1799212a2df1b1e8a6d9fb46bfc2799fea9ceed657020793d49b7eb3d2210820a0666097a29999225d908442ec1144b4d62eb86f64458753ed9f5c97af757dcdaa7f6e4f6201370c042aa13f2256e5ceef059244669da753a3dc416ca02e086fb914d11c6ea8c30cc8aa4a72cbfffd48ee5cfb2883b33165e70fe9f5b54dcef829f842d8c64dc91055511bf8ac01a99e71ef6ad158d6e664167f8b5bb3979fdb840fd63c57808812cb75dc55feb5985cf8eae92f85daf8e2964cffe9cf0735cfa6a5bd83d0ba73661ea2b334315d5fe55782c702b4843ee164dd09f2700e84381d87463c63d96a954c1912dac0d87bdea9cbed76af33ba7faf7e5fec3d3bfa138a3632260e55aadf7dd95de70ef3b137b382dd3fc9d0c259a4b4100daf58d6fb187d0d12148ccf785a6abdd1649dfcdcce0ce71355c65f20299ffc60138fbd7903297d6d3911f7c85511dbb08eb05802b14f8d898ee80f39bbeae74409a395cfc1b956d68d757f6f5905e00d86ba8ebb5ae263cc0eefc56c2c51847fb60db70649eaae8c98aa495e64598996c86bed28a764e1a2dec2608b701f03ae9243bcfc8e450090e75f3c84c8b6ff73c900cf896f647f91b432ffe9c5f519301679890bb8061810f5b20e60d693f4676f41c7bdcb7f0f3fc8c57a0f42bfcaca41dc1c79920337a30ae49f1cd34e8efc7624713adc6450c4f3686c1d0b7dfe700ef9c3fdfce480bcc525a7548fa75c8873227480347a8ecfd1f592eee9c28f7450671d078e35ebc59e286cc6372605bae3613c354bd9d818cef86afc29325bd3f066fc2aa54b8f8d01ba8a30569bc87e38de1f138365d1401e3f49014343e7369d8ada4fd7755898dc30ed1e087335e334af714c233e0c5577845e28097066fb2b5e12e8c284bac3bd6ac101c8578f0e0264e38311b0e59450e97c1a38b5128c22925ab3a71aacba6e1e1c677d36c110a5863a0aaf40f007989ca06d3349883c5b333315e586a17e3fde6da446a6b5ae25f31efaee29873b120560c94e1c6b86b19d27b626ab41738d8bb0ff3d52f497c58f51444f9b26c5d5f140d209392d9b75e74f016cb97aeb7702ef0327830d9bef9ed6d57d7da218676a94d5c497be3387f7732921a7123b2696d32424a83df73dbbd3b44bf7e433078826936244e876bd7a45371940b996d7aaece3b78ca3e76ee6197e13bf61ef9a36e513387df7d81cc638ad74e25103811cb9cc95dc93c421d5eb88656e960b9c435dbcff01c9da1e74976b462ad95649a15a23564a57cb7dc05b80fa5af9b35e79406a28f80af361644203731f6410596fcf8241686713b7a1079713a5507c70d569cf65950e498c0e0bff3555ce97277de715e3891b172f00e11f4c490b136fa925c52451533b4cd61b6008aa62dc8ebbb3d38a5fd20cf30796d334a7e0b3999647fe5bf0a57dd0f0726c8cff842013b29fd68567f6989002258c5c865db924d9cc8cd9d8a8d5c94527413bab2f1bf08e36daf7860f14bbdaf52c4e4388fab0351784c168aacd16f37a2e705db958c09fde76a8bfefb486696c6a5ab080ddce85459555f12c1e5f4910b0f29db19586f93cf9379ac75326dfecb107827bc1b9d341446141bb95f7e9a6029940659e5d441f4b3f5450457834a9aa6a7030bf1344943458cb9c8aee05d7ba300c6d7fe55542f789534f054ed418a730bb7bbe0bb0e5c150aed68ee3283b496ce01b53b98735afcafa90ce3d23bfb1eb77b45e3312c6ad1245fe4b759877e33c73462fe5f2918d14488b741de60175c411f276f0e9cc3e72c3cb43eb95f8afc76b56c7d8b075e13094e828df1bef758f3555d4e23154770bac80505852f1e7a5168762a3d7f240e5374434d9346a2ebbe4030ca69ce3f9f204a4c9169204622fc9cb87403535f681455ea7a59fa1e43f4adc5edd7be5752d858b340a7506fda110be28959bda9d5c36dc7c2a9cd1040d48fb27de02cf5d97aa455ac2c9b0a37d755181b684c72695281300d1ef8f8db4958f38bd8a0f3b84e7695a8bade8c3769ff98e15206f8abe4ecc2b6bdccddb876189c0308f19812a23cd21476c26ed7b86d78c5a1381936821334ee9d3fa728c7edc7205a0dc71778f7d0ac5ebe9ee7ce62cb3e064f84bccea7994174564a18fc287da2db68acc79b2c677381f02cb4cd8038252f034470ba41a3a1f00a737016f97514221b78afebad2cb8dbadc71cb480c1c91f0ef5339d4eed71530aacd8bd3d1323e59b566b8ed243635ee657630a2498780e658916edb4d0c451ea853c7fc6df81235abbbc600c3f54495fa9d74d3bb4034ef3501c8397a6117b33a53aa81bab23347e192933a95a6f02a6cb9f7a1595b1ab1c9839802dcfa2749d811f02b15d8d3fa5633c2598bca3d0198a4928e880d2e14d6d99ac68b3b0cbb0adda7cbf1c69ad4672956ab083c75e3197ba08bcd8cf90e0d3faabb6fd74c3561045ac01662be7fe8c8c13548d6682b3d3f92a2d4ef9d0cb9d414829f92ffae3030104338b47c8edd3fcc262fb2d1d0ea051f04f676c81d106e55a45f9e8b9ee746b96ada9a3b60f3c65e86604541fe6ed5e911b7be8899244bde4bf435f80fc30650d8124b2e63d0605f33777c2b4182ef5447ae8a5b73369f036b9a73f77be6a776a1fafdfaed3ee6dd8d8f54e66a2a2470337bc2f3099b222e541dd64e743372f37b42df89c86e1a9f97bfcbe828b7498927bede9a05e580ecf9fe84dedf7d1c1bbdc095abb83cfcb08ef7324966158a4f66fbcc2a3efcdbc3c86a92235f4c93e4347228ac9937d6aa400b7c85f6b2d6e6a8c53ae54b260347a267aea632d1e49f88b0944c9a0b23b7a057355b7cca52f882c90d9fa2bbc601d65622b6086c59487ea698f7907f1c939eca58ec4f031ff475fe3213a0859779d16deb33db01f31d7b479e45970c031c475a03d9dc812cab9b31430527bc26ed671dd8906465dd468bda2ff30adda428a5c5974c368e62643bb827532f4706385f6f9148838725de2bb9db768e35859c2f2e057f120cc255152b342d688b175eb09f36808798a869ad88678fb99ba50b64f61542176b773b016952c0efa9426c56d166720c66671439847e7aa5e74e32db20ae83dd5c69f3ae160bc5d25b5734d172a2593186dc095982c79a9e7682614ffbeda24b12d7df7c47804c3d89c1c089c18243305f50836f303b044ddbd226154400c70eb0ae956197bfa502ed9e488f8413200a3bd78500696ada598c3a60f2a5e0f7e4cf999a816e8e3142aa8cfd4787dd0ac2296f916317a7f54dd1ab69d77a4d71becea92c6feb12abc77feb3791a2e25ea977df5c2ca7af3b32d2603b18e09dc81b126efe9d62b449fff11b4b3446c9b106f6edce81b9dda155834d6fd09f1d1bac60c6d8bdef5a431d7269938449471cba03c6dd88695682f851891436a5f961df8d68c776ea8393dbea5e3dbb9b691153ad0f08ab80482d90b1b693a8b06c416b2c4274e0ead309c67545dea410e4164faff208664d0540c2c5c261cc01ec0565f673d4a0335f91f87807eadc2d885c8f7e41d2e884ff300aa10b0e369365b230f717786c18352956a0edd226e047ef288dc980c545016339edca1438a0c93c98279281a88b95ff2c2eb9f15048db963dd1e9186a157761ab77279ac3f75b4f07794887877b4947522bd3131ceeb5eee0e7f48e949429ae4fe8e983803b12bc7ef54a92e88ad22f94ad2d92b9c70ef2deeb188db534fc09c13cad84facf9f13457a5cc470ebdf54c376e45fa42d91765ae5f0c0c9e3985e02f0d488a542d415c4f7b091bfe63fb2734afd25bfbc0793521c0b1e959b4e85f5f93d7f0f629203fcd88247ccb2b6331d541be11e3a7b766c9adf408dbe69937c81f9aab40a2b306a7da7ac126e9859f0dd2773f71e69c51b9275d25352d59f85405f0bd922cac61fb451f31a5b034217ddc762ac51ca439245930cc7a5c0716b1db5827519e35cac9a0b321fb65b84b68ce62844eef808f04da021b9b21269ee80f25c8b7f367a464590401b9adc82c5b0e7471947bab8467b0f0caa0b8f0018285ebb8a3676e69fb245df91397166986e1460ac6517da65dcb9380d00452c632cb7bb7c5c88958c304879c6a7f801a18b2eb53792a34671b89c70512ca8281bb3ab5c5db58d2d72fe5bb26020aa1c0b2a640da6e16126d6f268dad2c00717e0c50f16e53c1ee6b4fc8d0e767edb82275d63ca42687c915e51f9493e89760b9426a4054e842ca4e075b188fad658fd63801fd758c9b7bdd8043008756c426c598c5a526d12fe386642f6a4c2b0dac58b21d00f1190f467691355c7b93bdffb69317c8f0d28b0c0e9f33ef9f4298141ec4bb5530ef737f3d9ec68620c65700cef718cd1f7e588bf21b3e305d24e9d7b3b3d03e48f52b841fb73383a851163e2a272b41d55eb6292a5cc49e641d4b5d464b156e5f378ee19d146909bdf423e5ada2d8e01ed3dacba3a5b89a633bf72d722ea6104f5296cb89bb485b4828af700ebe1f7d0a633787ee99cecc47b05944442a59894e64ce146b04c8a2c21fbec4d12c640999b269a505e41b648c17052cb08c50d714525041f3e56603cf977f85d0517a351ac5d037547650b8d45393b0bdc11450695a3c32d7401de041690ec4442bf37990e47397f1458f6cab8a331194f09faf00256f8e693daf0e9398c67e3600c2a6a9c3526ccdd97ca4bf0d328c6b72f0bf20eadffcb6115c6c587f2b1a31f933ee35f19a2f4e6c145423ff8840a6f8993c564ea1932cac98967c6a925747de538fc2fd8074030a16638cb5b39f5af48c2c98fe980217da7f44e2b8fa831100dafcc31a1cc022abf8bb922642b4c1c8ed0e788f6df83455e025c72d49b8bfce3bd5415da039fb41de2a3f546cfff3a20f370fb513f1262e4ff71e1c7138f93338e04d1e4fc5503eea2754cfcf95e0eedbd46e2e6e6b152c84a48077cb29e7a0343cb4e29f3d01a49e059698367840f4878552b4403d9f692e90e5d32e3e042b552dbff12370164ca2911d113eecdb64020734764038999435bc6a4f252db3492b7b8919f85847c6f7c8f2369829cefdd6df4a879f755fea8cbde81aa01da1ef27fd1a22233bd4cbe4f9bd92aaeb77a691e714f69546f48be0025940dc45dc897121d3e7ac390dc3b2ee05db783b894d54fc92d4af78240b9e10b0ead1509114f8c3f20a0ef578247c9847a464084edaf1ebc988f237fd2124077c56c643c29580eb3a60ff5f823d113c8adf833b80634d225d46c113549ddad1a0ea04dd030865382ab18c61767d07e22da1495597df6f503f0d1553b10f205192cf2fdfab1a585f2a991a8083286978f04232ebed2a4b91c9eb6ab9f2116bc3d27feb45b073035fb1b18adc15be0ad445007d487cd968d7ba33a6f7f3eb886ed9557fe7dafaaf2a33e18737b727734fc418fe7d06867bdfc1c44951bcd48e6a384968492c86190ff71a7f78689a5f33fdb8837fe39465dcd80f509f33eda6ff830b4d71f02ab4d4154fd0ce7e01199bad6e9b19d3cfa2e6ff90ec806ec91d28104956a5f01004ffdc20040b97668e014494260831b226d938c7b898146be9a766db314aa124247db61a500376c083d654520fbecdc97b16151e0a63b211db5734eb68bdedcd35dbea45d2a43e6e0df1244314abf9c729324551b825758557b57471fedcb683c7c0f417d9316e5d864211ab01ad3f765c81b5e82fe24233977ebfb667cf0c0d52274c0cc99c8983fc05c64fe5427fbfb90ee8d63092a0ab0630bcf308ca66aae1d3070c9bc7b30c8f62dbfa9475adc6009c1b174c12fd842e5e4ee614085300a7be01e7fec8871f5ec51debac2b7e3fa68a4b9c7fa82a486b7c84886a870545671baa83baf3e6834b56bad3c552cf4836262eb27a71238a022cfa037dcf0f244fc926ed6f639bd409127e5f2b6eba4c573142d2c69010d3340a6181a3b9165012892308c38628ffa0691179f3b3d6c2ca3d489d70b490be8d0f418f4121be408603057fd0a80f7ae04ae5b52a42604f0212e2b92713614b999dd02771bb5059a461c0199aabe49f99ae4bfe7f813a2b41a0beff77c5e4d14ed6321ef6f585f1a6c49e86e140248f8ea373844f4716b0746551367c83db5fab7a8a39a89cc495d9bac9e83c709436703b110665ce44fa99031099a1e1d6909c394b56b3d18429d34fdca4ccea26918daf602f41ffcb243be46c17e4afac47ffbd7b6ca3545a7dc6e496dc7a6c9c4a905c4e6e9ca00f8abc0f686600c971ba36add1baf20db865d6a27f6125ccf42476427fbd66e2f38e3496edee79b351a0db60bc55f55a73c7ef491fca4e9ac01d8d383843167e9193a62eae38e117f49312c824fd3c8613c27b3a7061d27fb961a6dcf03eb466e877147545fcfe2885970a2af3c6ca5c8d42317792182cd5ea57a0830aeb0f5ce5a472ef55b944b71e26d299449f01f6b8145db25a6afd4d9d367e279ff41453fb951ef5c880eedea18d1af6e1d408b07ea1d6960f3581439d941916fece4947e51f41fb9e6f96ca375cdaf3ac959d26f85763b668d91d31494ad04dd7bd7ab06f288df95b998659db6e3a07be09ff293ad719c38c0ab463a9cfd80dad5088b6548ecddb46d9a7e9eba361ef585cbdee09f6f699482f5aeab18f2cdc69a09b886cdab0c70b27bc8d74715740f94c2b7cf4f341d599448a06e3407d0ec1180adb247939cfc7a9f758ccf89e3b5b4d4c0a6065dc9e1797890cf6346ffc60a4420028722951819cb3ea29e686d5ca23ab21e9f49188af65c3de52301564bff330290fe3def5df3b9263c4a67151a1855f7122069cf04aac452a7c0c42bbb24f099b51a080d484b5ec719de67371e36c9b7b6c8bced43237409d4a96880242a0eefcb3888d48ec60d8e03c39b897c728e1db042ddfd3255f71708eacb3d3d6688ca29b95c5f9e1e82d0bc669af626de1ccc1407ca4a60bceba86ef1a98420dc290ea92864485a2ee445965fbda579f937e3d511d47b7b19f59bb37b50455ac037db08abae2c760cd92be113af3b264f3b7e51c698fda77ab274f71aec18fad0d4f8244afb10457d24d85473bdb85412eef38fd063c07efb42dff1a559d25b3969cbc1f4f547718d800119f988854f605d1369ee59fc0e707729f859ea7790071da18e3f1713bc5c6cbf64eb107c026c4a3875e545f5fa664814d13bce8df272f3ecb6e93881b364ae0ee068017b46ab4976292fa9fd256ae93ce374c72dafb3d92568bc06cd8e0fe3d881b47c73f4adce7b36b18412874d6d51f924b51733e4cb2f240521d221a4fee7b05dac1660aad73a80a97432d10fbb38c0f476a78bb8710015fe2d888e19cc330a5b27d4c6ccab30ae6db4b216b0a6a613d86ce72db47e3b5c94b3f5f4784f77c204a24e478861f031ab0d397429a156e613a0d51614fc7e1641d205c96287490cf290321b89b4e75d28bcadf203b4ca5b2b2093ffe6332177478eedac9f426ab0eff1561dac6ded00e57441f527ce36c9dbde1c8e3ee83db6f73a97f452e6ec251f4a5a300b8dc4179fe775f0c116dc05b8663e0ab323c51048d28c04704ee6bad47b10d38f7d2dbe9aa3544734f90532372a0e07f6b97028c5fa444a54d7fbc8ad84ea9b6221665df70eb2acfd8a4e539bd0326c431b4b48939c11b61bd7ac7a424e58b7a093a1245c7197d88ffafa2ecaa794352af933a0f09d213614af0d008e6032823924490241f9ea87d366563dd76941d06d69c428f97ecf1e705bea90c806a10236c4383fcdff438229910231f1d1f7fd26768ce855bff144334f70644c93c87ba60d8a430f5cfe8661afca9ba28b8f7ed67391d47a301efa7e8ecdd927ea93c85f992bc03ed8409ef121dd6cb190e707b5ce4f1eb8be2fbd9caea0d77ed3c8cbf723582d5cc4b1b31b82222c18358efe052dfd6eb110e1dd3bb2b4e8ef2a38fded9bb022120eb7722eb0c80f345ff7a7e855813fc05c1ad9b9366490b467ffb39bb36bc9ffbea41263ce7f435cc9602fe861243106dde3e2b846e4f92487c0d18391fba02a2cef16fdcb4a1eddfff933abf1e37b2cd9382b84019bd3bb1cdfdfefc1e474bacabe18745a2a35eebe0e253ca85aa3ca8312f86ef1c71dc182516e350d8b8064d734a6b529e772db8c72f41108eafc755141e5a0fff6db0b9db4a815723e797334607046a20ac2ad36431635ad29b7a8fba12b819d34d818874ed8230ed19fe4b91a64958429f7ffe0eefd83ce255ae6c10082aac83e5c8c5fac464abdc71cb3912608a03733b4e4e89903ee641d74399cc049f96d4a5ac2ad49d590bb47e26f42cb24b45126ccf6623487e96abdefd27bcc0d8a58620686881fa48da432a8126c229d8dcf0e7f454b0c01657fe2f38541183050f60bcd2236d5ae7eed2ef57476c9ca20d8e2d78ffe3177e89edf1fc24744e41c11953d5cc06c92482f6380e502e99845e7ad48f299ca363e3bb94fefe01f3baeecd15a3b0d03e564756aefd58544348dbcf5bb3c2f81d39b688a2d85df09dfafeb81793cf14cd7f7ca3e5c05be56bb7a9fbc0daf9d941d920a11eb620dad4c671d19a5a7f6d6cfc94902a9a2ea7f2fa0438cb28150630e0d51fa5bd1f8a015caef29fbec9edf755a705058842ea18f9516dac63ab31fa778e5870d781c6d28e5d9fd3d2a29085a9f49d2def261302e762360f22c064407a19e004a63cfa0c7d49fec820278802d1fcb5d2f5d2443dc00d192c64849925cff5a0905caaa6df243e99887f1503d3064b8e45ef27e2ff3dcd84f4fae15329b94b8280e8a638a5057a283181ac18cd36d1f533494ca9b1dd7e6b8d15680aed5ff055b0b64a8d112d9540e9952c884ed0de41f35cbcaafdc4a029e25a34c66fb12d2562191f326162b20b9f4d3a126922f1c4d39f195a786a5a2e25a2952a636e582a1d54cea74ace64c65bc9334053e2aefeea069c6c861ea7aa45bf9d633467b39e905485bfe1e4329efeca8a421a768c8eade3333aecaae8a4631c82d9e33eb9fd3d13165878993089458f68d41708e49af115cfb6492d263036a226acc0e32628cb4b125b2890e658f3780b1814a096c0d20f43c22bb37b3955c7a89bea428760b2c8c3debbc43c330458cad0d24bedae01be3025cc606c6158d4f8ba64c479d52b000d97cab229dfa9c13fdaadc6ebb7cbad55548f4dc91878a616560a5df509f28eb7ff890365c98ad70691dce443a34b173099e596a90dde4637a1316f7979f5110f07f8e122e53534a96ef363ef069dfd609fc3ae71163b346f701f760e21904f405ff53d09cf27f403c98e6a6aeda24af4acaf544012e35f917f4e39a4a9b6c2472eb5b35e014ef9dc51f0fccc0ac87aab8cdd322d67778968db17f9a4eab4aec9580c90d961e99ece858559a3f701a748db4395c155a160e202a315225052a453cebab6cd37c32114aa93f62d51261a4f8faefb0730918e74d2ddadb7b236439cfbb361e98f17800dde132d7038dd7159dc38234935d14458e92c19cc7fde6efe81f2d2b8d922af531dfb8f0c94cfb146ff2f3a514c7899f6ca61e917c5b16572ce634eee96894174514f207c1a408212debb63888718d4716829f838339329821b98ec40fc491a0e7801a6136b72b920f388c09a9495c344033b8d9e030bb9b8bafd356f1fa16eea020e27ab260d6c5df0dca6bd0da2646e540b85ac1f91990b898311b33c28947c522669943032b6d647da38b36317d3c763614964c1877a41f1cc2d23cdf97d34c05ad1601db27fcc803fe2155b58e6319cd7c4d8a737d14937d59a03b4f487b8a44cc013999dd1fdd3cde0e1d74ee220bec0bafad847adaef7b3adb6df1f6284db235833584a8e360c286fca85a5ef12c09306ef709d869b28269ae3371e4215d8f6f0a8e66bb2c21aa7fafd2d9d88aa795899add8bcaad8a4b704237498a626d386c78b2c8ef1e1bfff5911e6475a47795969d364fba57ceb4db8f43ecb6224bc75a6b68b01fe186156204cff5fcb87c72a6ac1c600afc3bcbee97df89bc0e6241b8aa5634ea5bfc23fa522f844f5bdb9c4f55c24cdd79db8c851e0b54451eaabdde6747507ad86749db1553e3c80d0036c69ba74c0d7560adfc5b21e907f6ecba568374694b35685295bfcd56852b15cc35b47648ae941e79b7fc3b4dacf7ef59714431b90872a9fc0c24594ada88cf40a81f3861423fb0109e3ac04f5b46ebca77167752994b9a073338f585d72c1e443110db981ebce1b78e20bcae75e7a84c76f8d0088d08a844635bedc04c9e4c93aeb465eb687910d73728972d5a017abdfaaac2d05456e864787998d570dc481c5389c329d3a3aaee203a9b88db2214e7df2089276d1e40ad7c300fdba905fa9931b663c6fa96db7a1e7cd770f271effd140a38865b05c309c8e993d74da704441bd76cd5a312524cf6a8be8fb7d407013910efe3f47d43b3ac7f866fe95712c3157666828729707160635778501c71f1d6487c91c4b16cab974a2d013b9068e34ef459dc7d930185d7a522a9a49d31ae33fb45bca264ed2851fd46d7a9d70216e919c3ea64452b87cd34228ea022422e5f6930f48c062fed2b96b90475241df2ca7e44650c23eb232fa69601da8f4706264adbe225b813c6398b7d37ea2541ed6ca80cf9c1d0c59fbbab271ec2189c0845301f863ba7e4d17ffb8924940a9098b6a8ec003f84f98d08664648d27957c497489a17d08ea31dbdbf964fdf52b5dffdc4ca6d3e608d723af1525238f8ac68fa560e2d699f4e15ec04737b4ffdefa9e238534bddf2ce1d7317bee81fde685a64bf68c8a10722142e086a372ac076f9e9df96594f2b75b785546fe0d893d9e1b863e0d34b39a4fe792ac1982436ece3d765d3cc814f110fcee76d42207b4dc6de68153a695d569752278883e55fda870a7440db0f6185438dc9de8c6bbb38f972f43c7419cabddb865063ff2652a24ba894fcb120df3563586edba89a7604234a82ce31a8f5f420d5b23ab86dd145a038fc3f602d545b5a814a64a9009bc5d38b06fdfdf0db3828e2d98481020b21eb1cd968758de124656724c29221b236360dab452b15797e793259ef0fcc26827a835a1690e6b0998e5a042ed4c3dbb8fdc6313bdb9ab159e525dac278f5288354ca0806490c3f4972cd83d0a4dfc36c34bae39e6e91048f7195a1f6f05c8433dcd21dd4207c5e889bdd35e5845b08b27a4ef2e895f2520a651ae326467bc373171b6633afc32ce8b36436d3a2c1772b109f8c1936bda1f15c76206a38019bbfc51559cea462d5dcb2a260b33611a2e08c5e4dca989d3555299d0c7a35a8fa067966b7fa29dc6c0bfbf0ec8476072dfd36e1437fd0057736d67f78ab7e6c3995f9e72d88dbe48226df3db61c93abf6003468e2c9d4720222b8c62403fa85c970f2f7178e0be12b3df0d0ba9fccb8ffbc30572bd3709457591c8114c174248549c2afefb859eaa68074c093b44f6e31427992168b235a69d92463eda773045a51d77596e31c46ac5a5bf0fe1a44563aa2bf17440ddc483efc995509465b79473ccae093a9b61b3e53f70429c80afa94a8fc77fe76373ed1acc47cb16bc50fa7fbb634be9b9757407bacaad74bcdf25573cd9515c3b94058944ca114c640095a0b31939b46ac862bd3417d258888d3196af46dd0d33f1cded3b8977247144e9fd1d8da53b02c5f76e822962ccf292893d73ee8d01e4ccfe76333f44b281b51569eac944ccdb59a4bedb01f7ab8d4dc7cd8f36f239b13d165b0bdfa12b6925d1c9cf68faf98c169cab94b8b7f1e3b54ef55eff62fa1bc27534d3507903d590aef96a5d40f022a7bf45c7626fc6c035a4599e945b6775636ddadcc0249b3a2811087f7f69a3d92cb730e6f790246e4c81013a7086e9f98a69a65ab50e1fb23879d14a712b2f96e361359df39c2ec64a27a7dd9ad48d17f468e2877761f1bc783344a072e440c508e02eb3ec5362a8e53e6435f2018cbd05f264e48b221e9230fa7e5876bd4d8e47804be438a3bac7097533f9dc83fdcb515a50e3c73a4ebd3ff55b6bdeab5e1ab2758a5852b1366c78946f83c19776486eb40963203cbd21a36937fa1111a045807c4c36101a25cd9129a8f446898674161960a744f9aa3361fb26d3dc42b102f15a0c1439a80201080e28f0fad71648f48af33143ad27ae00663f860ea1ab90aa35a240441fb65bc83c676f087c4b17b1d15571a95b392a4d656e0cb308310e9484fb1f3624bfe4dd7da4a3b65d929827cb07c29c745d24275ae6f8e8a8bfc5411749116ad947205517c5071bbfcf5ae2f30342a0a718131f03e76a86b008895ff1a7ed7564e9d656d773221fcea41ccedf439840fe5da51b910f42006b6af083bee9d86737a81f77bb89b0649ce5292d26a273824aca6e1ed3005580448f44a9c1afe95e7daa4b47f2395e71671f666c527ec98a070c1de9c8b7fd8b0400ad60d5afa066bec517f24388e376d7885f163fcf27b7734b329038d80d944eb3c3244d634254d36ecc5a1104ea0ec0d9b79189ef1c29796789557ded2eb68264c8584aec88cef53968b61917da19f24d83c73dce8ab141bb3c831965bea98334a96f63eb3e4fe4eb2a1a769a6ab9535b159accbf0e05478340c6c2209f0735308f4aea4ba37acf2dc209a8706a1dcbc2590c88576da597d9a24384fc618ccdaf99d537ccf8491ae2ad862a69894cf9b5029c89caa0710433a8bc4a7288f4b97fdd5d8725fbb77ac3376687556079032e4ae164c48ffb30edc4c20dd2a254efc40ae4a02eb7751e3f6aaebc1b7a5791654eff48d94fb3db78693348c63d641dd538e6d2661a7b53beb30e05069e03426090df5c03718dd43fa9a758a104519632e5409fc30737281644dd69d6f491fc463071fe9ff976ad1e94f7767c3957d47f1ee83b25a1e2d0207c0fced5ce0d9daa47d237a778eabdab0264ac6cbb5399b7c407e3c66bd326834238f9fe4da7773fa722f49e317d65fb5eedad952c99dccb818be8f0043afb849f4b26a2ac0ffdb74f3182f159590b41f47c97c6dad19336143c0c45fcd11502fc82eaac2b8e3df14c7e729499e2a6473abbb93e685d90467ed804fc16f63e609270278e59b4b9a3d73e0166841c85cf883f3712d069573ba2935316d976c6cddad63a76d6df9300a8ffbc42a917de5873f005f85d1d064b6f1bb08aaafbc678f9ac5ec434848c77ac3d79e079d4ee1367841154c00d2273aaae17510661952665540b1d87e11c270febb790084ccc485a90f426ae2eacf952aa3b014fd8a1abc0a194aa2ad45aeb99af453ee7e2522ae079b2352e62c33cad8a05df802c92615cb6e03584d9a79fed353083badf513bbf1da1afd2a9ef569d58905ca38330a823eaaddf9e6791676c5d03d8d8fd4ad980db6f33f406324fb6dcaba50a0f32e2994ef8b6f11b95da14d601bce1c57f0073ebb351998fa34dc253e982b15fef7253e4316884cb6d48b0214610f0d75010199e92e5565f643c4ba520b9104dd6b347a2a8607aff0646867527864db162746a7088dae1da6ba4001561ac0fc50431d179ccea358e432e1fb64911939b48a81a752ffd059bf2a292488fb60fd8f5cdce516b8828192aa8a07d42e86a83a1161059752d6feeaf51dab3e6dd90c664fc7aa9b17b72a7173fa9b38d78e198c935544cce7a8367a12275fed78f687ac95a9af14c19680ebc035d1bdbffa9718259119f1f8d3e9b9dac2fb8d5852dc9b91739e2dfedb6e4f28d78e44cb50ce9f36b1404b6e6da0ce80657213dcefb6a3ee76f2323e8fcb87fc922cf6052d7227fcd812a63ebec5701cc93e613f0b58fe2d9f9486dc9a27a16581a2769da72f581ef05ef5de2dae1559ef2e88eb696c2e1877c1536183492f2eeb3e867b152112280d6ece821ebef935de4a6c10cd285771b969266dc7349c5799edb6526197eb05dc3857c600f0ca2e36910d07fa78d6042a6dfc5870611b80778d0b3b2c2e7b06ac09fb1d371e3330b76aec774d360cc18ea0e870d2494c968baa3131b173b63e1a87ad5f5024cb866bc24f272a012901f750b6f1cc5f077e8c3144c89a4874bfa45bd27d4bb1ee30f1f849b62490244cd524048397028263f9fc5852c86e077814363aaeca205136c54cbba023a3629759b86755270d4393afc4c3e32d6d64d51df28eac2bcb86985c83745d5c6d81811ce5216561eabe157e87bc3204a5098bdb351cf248280262ce7689f9e9cf0b21c80f491019bc3551746e640b713f2a6e84d28f00a55e55da5c17353006ee37e748af87a8f8fa63c29aa3d513ffc825b969426588a98352010dd4d4d776b0642858f4c7b2c576ca42240639722e2c14624ec273f7e882fbf8955a42f0c8f1071c97c44a5608b962216d152981091b7daa84ed5fc8fe0e76c2bec377e8622811bd2271514ca7bd6092f06dc207a50bdc49daaba79386bfae2a154ef738882c00ecedb73c9f11d38956ec8cded1143113afc9eeb4a64afce1a0274f1b00bacee5e57eab3fb91f0150f2b9e72f0e25afab0757a898e44f6604c2bbd83fed901aed7725645cfcfa358367a12c87d706f835c67fe41f45ad715030b8766b73102acaf6bd1ea582dc8f210446606732e235d3fc0ea8cf307a783492fa8f7eab9ed17160e4ddf915073aeeaafccd11a4ed83309ec075cead4adf6277d8872ec9b43ecaefe50078f7ff9d60c321ba08aec0bba83044001b40aa22a83317f67e23f98ae9036f307edb173dd2f91069ae29743fbae0ed282d07dd8266c21be677ecb5203141c2e470548167b0d96071958b839fcb50cebff2c38bd9869b94a99a3312bd7945cea79396b0973d09cd51bdd575401982fa2fda1c7a3349c945b2192faec4fedb1e15dc7e6da172a43e0e1fb1a1e8fd9477f40d499eb8b244ea185ae0624c1eab279dfeb829fea796e76e5a1033ea7f553d2e526be8eeb97d8d10b0a076c6caab65ea870a06e021d544a95544e0bba6db82b1392f20d953ba4c5578f8f9515bc1ebf76b9985842b817ebd99637d97dabf603f503bc98e9859fd4a7e014fa6726bee93fe31918fe685d9ed135a3ad7deacf3d97c0e06e5518c25cfe8d9b34fdd5cb23a25c6852b4448f06b97301197ae22822e4a54062e1b1a7baaff101923d4186b6f584c26643fceaf346e330e251dd75c887d9b7e5d66936fa8f34c2f5b0bb8fd0fd357cd2ac98b58f9284e9e47c92ecea5c0bc446724343f1772abbc782a4acde10cde21a6fec8e1d8d1b3e25ef4e46e991ba44169868dc0964fedf62b11852fc0685a0b48ecebd2cfe26413aa923ad59994578f7fa512c9cbc52338f2f288194a216676a9cabec6d02c76c0d885f59d18afc20d40208f9f197c870f2333e45e868af83fa6e53c04e332d3739af7ece517f2f017e633bc6634a4aee9dcbf5f00bc20cb9c85e19fecf978e70b93ad75d939ce256e27c90f19f5f24654e9c20cc7e8a7dcdb655e5a9270b218825d5b2f721936bbc2096d503a4a9a46dce42aaa7f02e57c2893facbbe857b94c84bc82a0abe82792f9578708f4129cbce57df99c0295dba94d3c1ec1325629aee4c1565f907b62a1748b1a9a882ab70afbdbeca3b498a415b7f5a19635a79bc374a5de63019e15a794ed5d1f4fdde55a3827b3e2b83df40061f60c21b7dbdaa913ceea149dffac97bbc54a6108b0d43da38386e49f636919f8468b8bd08f84efcdc6a388a7d6a3a3421484e1faeca5db84160e6a9338eab7f7057c757282c6063868359c0e2abcc2d75dc63d9f5d46ccee0eb4fe9d8386e4beb23f4caefb0475d43beba8bff2d581cdcd061d2d1237ff9ee77e0f92871095c17bc07327766c0bf6e18fa4e5fe7a19cc6a6d38262774530080ee05b964515c7a22dbd46a4d6cd6cbf9be5be6fc5b5f0e7b1e774e4c27fac9bb64e37c849eac3c923fafdf7bac3cfedf4a7c0c668ad6a3d3efec51794d1d6604dd0762d3b3acabd8e555252914ab8808a0dcfc1c121a7fa19d5efad8d0052e83c89fd3d2666f2dd3f10e356f620b36c547bf9a3fa4716fd5c967949de32a2c20275ab836778de1df6e7e315074732a86383526b0c1e1d3a1975e7144e11559b7c8674e5958dac9238000c37ef3f9e554f59f508d94d01858ce750ed7e5424bac89b8cc1b4cf0154a46b7e5cf017c0bd0297099b53ea2e8e8f314e4856ef62cda20dec6ddd9e387aa9be537f1e8fa5634df9115511ef381949a60968beeb478e85ffaa767bf7955a5389a11b258eec34384e6716b74eeb5fdc5ccd000d5b6a9f6b7568c5a148bf46669a69642b2904ea0de89065f7e7b1c1f5f6a75125d9a5d4d95a6c68be3fb4568e562eeb2127545ae99c69e80ef9d4cf357162d4ed5ff1b043bc3a43c185b334a55a3bd47ee9222ea8838d27bc868e3daee61daeca11dcdee9e52bc1ea0e09fe879bcd11bd79e00026787fd98eeafa75eefda37b62d69068eaafa128af386cc995a22cc0c99c7000b1bed5c3fc1f8923e4593d7539acf8c8806165fb5acd6021a4c51c9a5d433dfc6634c940aff323a8b4c018d83da7af773b1d7f61691d76dd765c0fbfdf4b2cfaeb190b90db08402b67237dcfa1246f749475237c10651a1296be37624cf4bbc7faab38de25259272e9ba3f11477c4dc5771d141f21f2525dfc6a580ecf5ff38dc63187ec352c99676455778da45d2060d796aacf41fb2318edb0145e060a5adf1462832c276ceebc4df36f881d12f34c245e032a229832843c864a79563c579dc646ad0bf91b16a6946031501ec776759fec9316cb66bfac33b4473bad6ec657a650bcb4e6de1aa291e6f51e21c706628b41cbc1aa94f5aab049afcc6dc0af0b2a5ef7c24d06fcbc15d8e109fd9d1312004bb49287ec068c6cd98183e3dec49047e3f0086b4deff140468f6533da8c394c9fa6e82afc5f56ac7b550040128094f9c572218de40b00942ef87cd976555cb80a1b5f0751adee4d172565b456275b888915f1f3fefbdb8d7155fb8f7f751b9ba1663974b1f2ad5fe9941705670584de03d361656949b58616ffb721bff6814e036e77644d15fb5e3e01285191a55cf99f5ff21f8ad569a3b88d4364f3084f3dcd0a5a0ca39f5039d50acaeb4949776a9366ed5f1a42ce89df31f634405ac1babf81692542313d2dc53d57311acdccb32db6903c394a0685f4249fa666bbda62eb8ef6a8e47074dd8fff3ca1c5b6c5e223799e8f30e3a3f5871b3b57fa466cf7bf93a432e66d41d6ce0c12b76a4ed773b38f7b90c81190e0693ecbdc4c75054627d0d33bd3de0c40134e6d39a1123073c4274d7d60ef2c6b9e847f6aa75662d619d79e0a943a8dd3022100b9570155357a00f21936de6c33479804e0b98ffb7c438c33cff5f5575d506e91c8fac82bc2e4eff19e963a7986882f3a4a2f6136e0d453b0aeeb0051939611b3167e8f17c72159110fd935013a4aacac527f1d29555cd66155c6f9068a0dfe40d591b5aab1a35375a223c2415bd9f007ccca435f8cf80ce74085370d33b6d2d825f7379de3bd650c6bca9e042924e0b18e1cd82690ea8cb3b42cf3a5c22e9b61d3c8cb4b86b0d3b59315c21d0a81f031c295a4efe40177ae98a303b5500e49529501296f785f322dfbc81c403129430cef5e7e311ad7cc357a4f755c0c101616fced921de2278436fe9ef7e06f2bd7161e6c940210f9c81a8c6e614e89c3545f985c900a643f2637cda6607c34156e2d49e57f81c963205a0677378d3dc3468ae7b52cb97aca7681c80758c0726c5cc36c299aa75fb9137f4a76bd352fc564ca8489b8631effb7b42e1c0f0cd554138bcd787ae2aacac5c1f72392424dfaf30ebdd6d1189d06766e416f7a3f3d9beece70985731afaaaf0e099ffdccd7b7956b0fa91dddf0aa9983187e2b0c70188ca16f2757e40790014e0af9632fc81126cd6a316fccc814edda3b1ca9d7a7259cd594adcaacad008fc60d393ff91f196c0e617ff270aca9a2a79f2880e7b54c39cea0d85faad3b69eda0a7e6e9458e53f2e97f17f58b21d29d2f567e940a94190b2dd872b9b811ccc72eee98d9303b0d400624b25717c706f65f0d6a372f66f1b1e68bb11fddbb856a751ac4fa06320370e44e6061169bb9d3968decea00a14a396a45fc9d55cd427bedab99fbd9280ccb3920901c07e2cda9d29881359a430e7b00208a3f948ce2886e1b95817735183fe6478825dd6c21a56325228436c2bdbb783e02c771291b65f0653048437d1c55d793612d48e880245c69515e5725d3724b97f75541da79d140a7afd3b4cf6563914410471fd137222bdf20c0528c2f0aef1ca022aba5324f63c22f87e75fc08b98c6a824a2aff47f856d8e1025a9557b90740988b3c601668b638bd3aecd292aebda90c70ea2ac93ac009fbc74a659473b8459eace3d5b8389e3e05f52b810c874b0053c001b310d83611a66e38d3bffee24a7e3cef0717f753cdd35daaed065cae8995bd0c16d80b5b3497243e8d77d9aa4bce1467a75588c882d5cb7847b9c4e31bc96623d12f269908289921bf09c6163174998b98b6eee974c16e137bac4463a159df75450d0c07e7a1b6a8c66ba6c24864e07ae37250c075830ac13e0bb1401ee766f5302a4f35f327642fd4dabe895fd490884fe9a76aa9fcb6f8a4ec5712dec0c1e5bc2695d9e6fcbd450f899ae2299f8fa81cc8fbf4ac39aa25a6c5d6e6f7264642b382da959428fc9d843f327ac64f0c079068bcb9f33cc8e34c7cb900605fbaa8e145ca47d9bcfd79f5b17f8d6a727698d4bdd079f1a517ccca95f4cf08628775d1dc427de384d5f63e8df5fb37488c3d7b13c66a81466b7530268d44fb11f1553d6d18a1433587e909e29ecce2b72bc1e17b18c0d17e748f9d559df4f3285e50e9f085534042d91f214d375d40e19f2c3ee09e2c0df9bda29b80cd990bc0956fba14605d9c90da06cc11cfbf84d803628f57f933b41c856665aa9e21e5da6389061567db0cbf07ca99abb8bde364f09c43ff0fb7da5b3c1cc063e8eeec38ef9b502a339fc14689d99bf79a09c40d45d81e1245b1dd416a522ae73ce1d03274e2cd29fc1197475a87ad8b1be2079d4ec32e73308a7f0320bc176773c745c3fccfe1281592a90edfd161f06881dc4d374d176c24f0167426aac10ebd760ba94e0839eadfa79dadbf5fa4675b7266ae043550a4ef784c6d1989feb73f0f21db010e606680d8835851a5061b878aee0b176aa2ff2209c8c8517fa936b31aac3c9c94d4b20bcb7f1f2f99f904a78696351783ef0118652799c4185d53b415262b4449a8b786433ac3e1cc8a5568780c0ada45ea38c0f8f00f1b1d884a4bf5f91dacbd2effb7195855c7eb27b67a1fd0baac0e71690af171353357d09ab236a2ac61ae6dc7a7b90d9f2bb9c40aa4b632c73b149250029a5d4247bfb777144bd9788d866048fe888b7dd4c1f71656244035ffbea89051753fe2f2f66bb1ad17e9bcf7ee8d5689ef37b5fb41174f6cd0e073955846b2e428a85a55372e02a7aa45ae4a6a47d9cdb922528066c10057168f572e0ec7640c08d357739397783d7900c21789580293bed225a087ca49989a1a7d86b367322e28e9b7a6e5238b2c807a071725adee0d28cd37c2b2e182f8ef97b19da4bcaf2c367b173b8bc8c28ab37fd986145bd87ea388a541877e8d873441a7bf0719bc30dd49e3cae684c6527f56a0d65fe3f711591bb5be41df1b55d494dedccac7146969a1eb4b72a0f0780446bb837a399cd09c7d142616258ded88a0ff2140e86fa6831e5fea94c9087d36b85781080958cf5dbc59fcb63ade3c1868f7f0a2c1c5cec5dceedd257e86c3b74d398fdadeeec7fa98f962f7264e32a872a9c4755b874d3170dc73fe676c55256440b13be3e2baf08dbc02cc7a7083050ba0b18888d54ee6d92c8307985d39390290f9f91e0ac1dcf8a3a5ec29d3ec54dc73a0d45043205373624918e6aee2fa6a7aca0c8fd2ab722ddcae8ce70960dd1561e7498bdd3209a98152aadc5623522d24542209cc23aba5fc833b701df7b538b2cb1ce977dd6f18a82d46c8778c5635dc7b150b0f461d35e8e3b1cf16a2e29a0adbb3e291cc0b255ed3535be38d72662df6fb5ea7fd582f683e62ba6697ad1ffe91f9798d39e6cdef22f0d9e53440cba33263c6d5cb1d056c89c325e8ce5bd5f50ad620dadfb593462daec0df035587ca7287013453e61dd99773d56c2cd3d350336f49529583a7b21d6ec6f56d1ba006a58c4cb5221692eb378cec8ecf3b3e49781a6fc7ce1ca965447702a2e9aee23e9f682deb6cb3664fdd60fa252d459b815fbae80b907feb2355d49586dd3df3da3aa109aba83526a07dd133f239bb69ccd4ebf78c1f98b72d8151d2b671554518fbe091f6d2a6e90273922eb3067f6aa2bea1c5759f14142082576f1ff0cc4276e7bb945f68a666a2dfecdb0cbf3c635525121e13bc6144076f048bb4b09d95b895129069962973a36bc9e1d6149d8f2a226317d03a5e290926d739994a65ef5ff7a9322ae05a9168d4114ddb420379adf1844e8c6e8a9ad94edb94198391e02f573a3102b3773cd5dbafbb71cd9a903d39cbd9301a2a4eb0641176de937de1bd5aacf95d902711c36251323a5581756062d50738a5ff5194015bedde74f3402055855fb24d6b376530064097a494098dd4abaa5c932c1bfb96b4117c16aa276e030ae50c6da7705f1282838988f9e21c460ce87273124f1ac71b1ab8588ee00a791ca3a8684a814676d2f77a5993e7d39f3a8e32e7d78b863032aad0b9ed30fbf241335e3208228c6ed7b5e945636b03e1a9db5bbf6db4f7c18ba4d9bc67ceb8d2c0118ad0857820af82e66c2d661c4a6a1de4f9d6b051cd7bc41dada8f484605b5fe480fa8079c4e4ba4499ec0f1854e075153bd53333da840bb3c84c94a92a4f9102ad0379b3019cee0b228b8545feb32ce7669e3596144705c4778a7eb3818fca26111a908c272617101b705dc3fc9e717d1f03aa55de07d00e78475e9163de4097bab199658928781270b45bfe621838791e6774825d7f9653cd18a4b0978dac06041ccc6c6ed4bcf31e95e440949efadc601c27ba0566f316dfc6217187ef00edf35c4fadcbc91607e0ff5d0471bdd0ec65557476ba81cdf12dc12b9c2ba29876227808099e4a11d4b5b2d5365cc1f78b20ff1c63b94655ab6e0c84e4ca265c1179cf4e220cccd1414c347611dc0e823001528eac7042f97f3ff92dfe0ab69c3006ef6fdbe231f46d16fdf42dd3795d06764384cd21787708bcec4cfe19de82b8ae9fa28bc1abe5c1d1fba6a061bcdcc2796b8a1b3dfa8511e0d66d1ce588ed1c56f8f9e331f8be96f14e2969aa3d21961d07ce98544e877f7319c6165438d3ec9ce07e3b9aa69247a76f95e7ccdb81c679318f80233d3e9fa621958f97800b1e81512ea5ce6de2f31ef5286cc4894080cd2b4dd00e368747d219f463be26a7853c8f320dde113dc8c255b5726f22f4b67728988d24061c65db86d53f9d3de648f3bbdc9ffe321eacc03f370a053462527a64145a84506491fd63593092f7bc8c770ecdd27e5c8c1bc1779da5f3ddaa74a77e2f17f152b6902b9c18e461cb95e0c53892218222d29d095a20346160f703c8794fb7ffa95dc51d3a77446f9f752bd27084b6c459db4d91f026c77594bbf71e5beb45b32b740e7756ea6f59890e180853bb3a9efdca75e88d8671a40765f9a10922a2d179625b988fa971bda98e4cbe62fe936134fc5035c0b8f95c5fb600882fee6d7c2198df5f5bcf304f761999ff39a02e6c2a836b2086309cfbf82fcf4fd317e368be2e4eadcb3e896e4a2ebf844a3abec9337ce0f63977b4f6c89ddbbe81730c824120937f2c5dab3a3bdbbead20b3228c491bb3c1f447e4640e5930c8172626abdb20bb171908767019e67866242642eca3a86d0a5f50bca3ea1c71165daa4c3a02a79fa1789591bb16987ca3d30ddb6d44b63ffdbc474e5d33a75dcf45fb84089c9fd5995d8ce1a9b4a4e4ccd23c6c1a18f1df945d6a22d2b9eb144315ead4e98268cc661a48273c90bedf7f156de565c53aa53049ba4b9890d020957a2abb62d607f7a122a501d29aab3d57928e722b6ca20442b760d050fa84fb2d3e694af8382730906548f32476f915b1c73ba6a0d2eab8351b5b1de60d442cb08d283470ab46fac0ff31caebc5ee9fea924b4364f7489d9a177d6a220edba1c346042f8f5c00f7fe9319d4e158c6b814a4d067da65621131545c2106fbdfaad97d6a7f77ac0ea2c5d87554edc0af9c8ec42a4a583a35b3cbfa85b97c615d5ffece7ff3296c1a1878142e877c299aedd9a31ec3f4f7d97d5e553e5a584331d767f509fcbe7444c84cd30c64b959a962e1de05ad67dfda0672adbebf8aab67508594cb084aaa69bce8c409968ed8b22ef40cd63bfddd31999f2a110f3af24a18815c87051c3fa861fbc4d4c389d6b5e3d3b565986664e072c2563b981dcb8938ba1565cdb9c16c624b7dd4a970c0185f607e62ae5e9450482d80ae6e88f0e4ccafb7ba5b11d436a97e8b853406b7d1603e96f6f2575b84c445437a8cc9b32b86a02894023497214fda2f583adf97f6f3f8781fb58601c5bd501f656c873017155bae97a090ff5c40ab479cbc26fdf3b144b42f6d02999a78348e455f37b24e2644616b589ed13b765b05234efefef3851121fb34ac569983e8578ee4fd9497c19d86e0530127379723fc05929b1662e6386866945ec5ff5cc0a5ec490ee8df94fd12974f1ddad98b0cee549dc15292551a99e78ae57a38095c0d2dcb160cf8238379edc3bbbeef7940b896f5ae562c72ad10f105dab693008db0d80d88147bfc9ac9934f0d6bb9c736f5e9adea95fcd259cb16fbcde2b3baa66923c614b0aa7625b80aad1a97dae622813c9297b4fa52cd149c75afe8c7718e5e706fd628ec6b1c84cb7a47237e836217e15e2704c053d92d7170c410ab2db6c68802faf932d550fbc450bbcd9b7eb42c2cdfe7aa2f64ca6852a1581143479f285d25313ced6652127a269f65bceac9dddffa60500e5616c8b5f3fa6bdaf04bb08512a74589213364d91e7103f60f0ae9d370f9dd9a21b82229fd5c3c9004c4e204e2e1f748ee78441e11d8e0752af8db17f9d85585a551c410eee176e45982cfadc3ac0fe9a76bac63594b297a4e97b038459dc6caf940655d90302090c38a9366d1bdf78cb430692c56e7a1e886df8ece9f567cebb52898683da07bf11a0f57acc003cb4d31c9ae88cea53d07a92626f4f5f0c8eb837dbeff2758c7dc3c9394b90eb6078e9b4f2efa4c074c2074afa19c5664e8a02ec28d0310f07e29967ddf1a7b6387d6c1da7bee2235062a3fc2b179130d2510d1a5ff2ac904eadf5c41849de2e2dda397b65972a5b356f695986847f2847d4e196ac56414dfca458bddcff5c680f5ecc505e1cdb750aa514a440f03424711e5e475fa1ff12806203a8f6d85d44021a28bf9996ba7fe0db834dea4e89669fffe46f498b0b429a3e5d4f6362c9f8d0c99de34b15c50ead523a61537990788dcaa05b6d4271114822bab5f9c7ef54ecdbf3f53ce83864ffdc089db7fba487fd4496ae3eb0ee4c3d2c0f175d871a4e45b8b2f962f0e64058955085867b8a210b943929bed59cdfcc2e5132279d5f630ba6fc3d110836f0623b1601b561464997c2c3929623263d3c35b565c3d510b21b013ad76d96a6a3825e7267da9afaf791491a69d50bafe7ed4ef1db56e1b0fe2e405493ea994ca9a58a52784b67ba2aa8c5f0aad4cf3a8bbb121eb1787f793daef1961fabcf3fe98b54d358eb8ffb13fba43db356673ffb33585f4d0eb772acc4b9f2f53ad15543067c8911346144b67b0314e13eba94274f4d73969b755334da0b49b4ee201f78fcf86c705e389b428cf33101e5320d232dca2b9bbe10ee9b14ad6f39d32746f540a71a0526bac3f43df2243156899a992ec7fed2c3afd8d04230240e466536bbe225baab5d910724c42ffa421518ffb87ba17f03384d7aeb37c7fb91b5d95dd928a882020a63be5301a1c79b6a1f48c86dc7ceb8176f71ed01efb95fe508a4aaa7aea2c937a09d18ff7fa30005615005e1ca4b24420dceddc62b6512d7882e74accea1a40979234163031a3e3e296c0846b44090c425ea78e95c3cdb8319d5ffcd77e7c52475d056e75ac6b4d321c9219c5665ef65e46172351ab16a5feca2f64e6ce708a635efd3d17c5b2fcefe92b1409533444932fc367126cc8ae0b43285af770971b60ac29fe31893e97d46b20d3b57e3cdf5c6035473e976a527639c6bf3d4592598066691cac36fe298dc31c6226b6a952b5284420f53d5332ca957e8502c0f67f98b0c413d45f5e675cca4f22f91812f04a7ba102d9d78e9e0ec39f3b62f7205b652559bacd682b5e0cc79d37cbd26630f23849d6c33dd5451c53228b387ac1ce30c16805184b5fb559114ae2b993fffef15cc654a53b9841e7f55394169ff883c7c1729eca68a1dbbd43e2c4f550251bebe9e011a4a1e91c7166ac979a1ea1bd2e68fa696cabf909f26a6b274c3fc007eb2b5aac1df9a3edba2ad6d215b3930c25259be414b43a0f0856c37cae3c8ed390f6eadf73782b2e180964074128d1dc32727ec5103547e40a731757a94f5808bf0b58029816bc0942742976bd398f8b2fd0246e0056f410aa3216fdd5fd85b9bbadb3c2725c1a315198141bda2e697993b2ef2c46e576d34823be9f2e4bda46a39eaf7de5175ff03e3305acffbb13f61f99cb45aaea7fd6504367eb2e826b6320f5d0fc802d637ab5ef330b273b669a4bb923748352f43002d53aae433fd43453db7abe7ec4acb439ca2466ca8ca8b55df4ec52273c35b219572f38e8f80300a0a3002f6498e0bc358eb100cc5587bee86bcf847a6757fbf84b0df81caaacac6f43fd83cc241a2ca7dc7b13ed1954a9b2eba376e074c5f11a8444df105bd79b4fb107f7e3627218a3d3891d3ab72873c63c43a438d6c22d7376eb64ed0722d73b0bf928ad66c080a9365681902ee7f953ffe7de94bec71127e79a5f5d568e89d86888e1cc13676bb64c39c0a5167aa99e21e1f3774442223c821e65b0d698f56ce144e80a679dc556e9d1b263f10a823a7630dc5f14ab80f03a2b4bb6b38c53d199619460e3f41a71e2f7339d660a277e457e8269a83c15d0d50cf6c9f039943c835baf7cf938096ad2e6f9adf143576eab949bc535411a73ecbbdf1906ff997c1ac892ab4e4145fa36acee4d1458b1fa5ad673b8789a0a26f8952d07913f95e0c7a0d2548f96e29479e81b10c751d5a1eb6f52624a0910e6fac99656a6469e84a026f5ec8365362d79c820a1737900c90bea2b09a5f03cbca74f59b2dc78f1cb8c3b783daad60dabc3289a2b9972bb45c8d767555d24786c32ab62d3a55b3206684b0c7d7f53e6c87db3f4eb6a3660c9f3a67f5c2e71a3079827ec6480f54a2733b3594d620f0ceed12ce0fcb55d21dd6c5ab5cd14682aa63bff0dcbe3dbc1867bcf500eaac023fe8af690720f14271b519f8402b9bb11f780c08f144e546628cde915eb6a1e64c0a08cd3f7484f3b48e6d1bdae80c91a3628a7446eafbcff1420abdaa3bee1961819ebd8feefc9ff940829f52e52b6c790b441fd56a51f86caef50616c45cdceea093239fe06c80ae5a62af57081f80e30b4acd9e172dfb65e0d09ad5fbdd9b61431e407306d746046d5dc7692fa84acefc8b6215626f4476415c54d57926905da59959faa773a7bc18965cd10f8a9537386c018d6fc27f629c340854147145dedb76b58545dcac0b21259b965d5d8065e83da189dae176029930ccc846fb8a5885bbe260b040a3fa109e27a91518487777f9d1bde2abfda26d30d619eb74d3a6fb3a5fbebef658aa5f8f2d938ee9f2ae6d4086e27e384262e2b2a7c7f44ec9c18bf8339f18c645cbb66da1b595dae436b81569749fe6fe60d542fa13ac07db9c5df87404e8f1706fa977daa764fd5803f131baeb0e375aad33566727c5dfc1ff5572cc69c83cb64b9d8e4d41f531d036614b794d2253c3ef00ebe0b64d582d9245f5fe25055c2b4fef61def7be4ebde5cd30961635de5efb9bc534c1ea5db72b5084b7f099021da7c35e71cbf65816521bcd8bfe30e46628735345cce3db468df900ba45ab84773f54f70daab7f1b65daa77b68aa5554ca507d61e25dd31a518045f143e53049eece4741667ad2a42b1afd3a95de06113c9c25b0a7b77ddac2efc0f0da641fca8965034a7d8968cb9f39eb8f242d55630b3a8900902e6c06f2f4a2abe4733ad50338b8d0b2ba81bb7df3fa9255c5ba1442394d712a5053424b2eb167344fbad8364c8d274e52d1667ccb9898d6783e8e0954fe8afee7645399df57e5afa7f9022340c7204304bcf1d9fda1dd9f3552d169e4101ee4a631c88588df0c59ce78b0b283b64573f078ae414bf11a542bb0c42327d726a47175a0e5f9c3b90f248b0c73c896e663d05ef87cc6dd850e966c55c8071e014dd645da3b3b0cfaef7f6d5b1b1aaff0ffa8fe6b58032f98950c6207e02cdf40505219245e1bdb38eb248993d67c9bfff707cbd47fcc839dddf0080e275e08a83b8838604a8045e2fe0b493d70da9365f95d1b87444354a6a60593ba8efe0045354f339a6fb870969b0ec132d6584daae8816476b152d899585bb14245d79e14f4274b882241537fe21594938e1faa6e3b34542262b42386df99adb4cd4a38f45875a9c3e16926d998b2f976a27232d36fb6eeda8ea8a5d1446ebd9598b5f9ee3e27f7375f79b0ed80a1b3e2575a6cb4cc6ffc454b6f38c1707a58275b45486ce235a6d8b456367d05548e29e4cdff3346d87d462d02e5e8a745c775fa14096a647a8251c76062f45f8c64ffe569c64f6a6843d127f394834b8b364fb0a09cc6439e9468471348060f1fe9e232036b2167bf019c68eb6f50d053f97798b52da4b412bfc81e2db46ce6c57da6f8f75e19525fdcd394a21de811c14a3042aef60f284dc44a56b5b0f24b99f51aca9faabc4983a52a26084508beef8770535d45a15eb3683b0b9add6433559472adbecd510b4f077d9d2e3901db50b1db774aedebb874ae6ffea9f2155fa037328a50abb87c2aa359f3fcd54e22fa1960922713931336d0302a2f00179c93dd01d9e9616d0faf6c64bdc8cf0105f3aa93a1a50158277bb2b9f3f8102ac99a173664607124b82d2c4bb40a4505eabe07d91d02c39be39add6e2351a7074406f130a4dd8e9a178751152f10c764fe62996701a96922a18b235e21977a9429f96c5da338b430f17a2fb85f07b7be835e605de120ffdb943851814fa73c1167d8182907897bb79bcd96ee2064b1bebb5570e858ffececafb7ddfa9bb4a23d4fa2f1c8898e700bb822d5511fdcd19101b7a312f3714f4e857c2a27f7ab91c7671453c96d21a2412cb00bec207eb745a632d8405690970b9d6ccbdb534b23e7f9bdb2712720064720b5dfde8840bda8980b8b35f2ac48214fbfe713c24db97b27a9860760d967854484cdc5f35cc5166b11422d83ad72a828e6044c9890f4b9a222223853137d7217f16d49584f891109b1b4f61587defc09a6c6a938666b335b7e7cc0bcbf609bb1e02f6674febdf1f41092a6df9cf69890a053ccab90b891757f568a3bf34c1ba4f35e367529f1dac0c66c58fb173da3346f8a11afcd500c4294f812e31939ebcbd83936324c3af30988a96c660cae3cc8b96e60cfe492f8c97527aa45083039bf76252ab8d4b01cd8aeea0a7b2e058476f7c38b89dfc5ef15754d73e1743e648a444af2418a7794227d0fcdc3b8a4983a012acd89a0606a40dd626f84af6def3984ab8b87e3ab18fe21a89d843c3cbfcd8b1adbeb84c8752bd4c6be0d9bfc838964078202b3a1e1fce788d753088129fa94d491d0dd8dfa7ddbf1304ccff5f38b69c70853fa3ee1e034190746eae523cf21683c008fbe6b563a03d5575ecbd9a2e5d7ed81fe9a27c58f9fa78fa6c8766ec6fec70bd16c2a958b6d58a5848729aaf3e93ec7d42c0554be7e95c027f8ea368c7044961ab63d0eb31ee0d343f811971e646dba63bde9e9e7907c5b87ef7646f26acc712f8b2790f6f77a195b8bb1051872444a30295c9a0c31a187ae8b38e8c454732e409e3c70a776922c2c14fd651d048937d97e98ba05e8407507c0fc664fc1645e580853455945974db65fe24d2d7c825a3e3856bf9b570ad57fff237c3b821338fc8a2894d075b6b94f851e833429b2fd1401fcf6ab3ac9a873bf0b5f9cf5e80db12e85b1a5b8380307eb7785248b4fbf01af0e9d990ee01c05cf3aced0bcea3b26bbeb62fd754b4ce3a40be3d0c3bb3f509334f79899e8a2d66c89a147a8eee96d08436746ac00e13ada376a04a8ae1446eb82d9cadb07bea697a17cf2cc83bb6c0cbb49be398013daf2a63742d2c98e08b2131acc2a51dafd66bfbac3543bfbcdc2589652834f53593eec6d949c57b917959b2f690f61ddef9e088cbbc66cd1f0649d92e8c2e1521920434a937859e28cb92aa4e47cd4a095b042b40100c55661b08f000456f0e36ee28409795b49c44976bc4a28a96afd2923d58fc236e8d298f5c796777d330c33c5d47ae6fa2218a6d6bd2ebb7d8ea9608d4027867e4ccdb2ecdff6e0d238ccedeec00b0aa880d95f0973f395743ff4eb475d7274313d48c7fd68bdabdbacdfe05b2805710294df44bcfb72b5f522a75ebc9660da3bf246797a3f38b4179130012a78b0c03ee12b578e9f33050636bbde2365988cc9233e164202319b74fb6cf0dd5fce6be2afec0f758fb73fd2d0a3fa9a66fa6dc923b7b4a9c526b79450b27f79a3091c57f4ebfd283ac7a6b60814334f7a86f768b0a21db7fe0b8deb3d4dc3fbf9cf5944eb780e6f6cc38c57caab8847e2baece85ee0b0790f250df5e1aa02cf47e959e24cc8e3719f3a226221f88d89dc297afacb59f51af8c1e9d7e5253e3fade7e01c687965c90758a6182eac85a38a71ecebd0ae164a6c898bd6b945ca6ccfd4f0157fc48f16d584a2c27376d4ebc98fc17c7fb28b759b6eafc708940a122f360013a24e6c7308053424df4bf3b52e75c4536ecd69a446c147217a1514ddd3f9d8e1ca2d4f5b607eaeae63e76631d35073d3e24b5cbbc9f24f5e05cb18cc1c2ef087bdf595b06106dbc712c5580e4584c9d6bb662e52aac3bc2b1766b505286f4e43ac9c27ce535d13306ef06f39c59cf97665c6753d6186eb3f0b8a9af6081af32d4bc49621e0d896b3e977b197a334b7c5fbd366db84d2a9e6dea2ef4ec237878e7c2e59cc0944713180ceab1d998889b8d67babdfc1eaf0d878022119f1c4aef13931a50701121ec9dd00e8fb7309db7622c17d202af89e2266cbf1d14d038ffaf6d55b41c513186519d7d187c5be4f3ccebfbacfa90158b53ccda2335146a86824aba80643f97614e81fbdae2c8b002948d64bc4d8866aaa3fb3dce40d7ad4b14b0f03f95042cce77b9c63370bdb67e9729aac8f41f9e36353f73a4e24fd6e63f2bd6728dca483abc621df126f3c4b0078fe50adcc2031eab6563af449d7277512277f870584e2719912e2ee6ad036e2e75da2f8cd7677000311be92cb96bda5b910469b3d297b0847dedb0dfafbd0fbc3af9db146534ce8d07368829fe2813a823ebe8ed18ca0cebc7504d8a27bd68f3b5bd1322d74f732eab32ab630275dc822759a9bb108dcdab727bcc06741dbe110835a69296e35e95f659a2da5b8b65d433f5b7aac86ddf35f8d8f7596af4c4d7462a16325a88b8820b3119595ed4bdf0a855f0f4a2ed8cf00bfecdf7e7d019640a3f940ca4f19c388ca405501c083f60b330cc82acd213fc5859bb796c8ebe9621da382bb66426fd68d23ad082f2a8335d3f639c0430bb1f34e35adacb644006916abfb737ac4d6649615c083aef088f5224e69fd8b47967c8322275cb7ead9b789f27d74725b07943686978c74b73eba40df3974d4581e6ea70a05f58e2d7c34ed8c63e722c533eb0bbddcb23d4c49cd9ca93b44d3a27f9557f65022708fdc280de2065428455acc65db8f8ababe61a638679b59e85a1a3e0146bb7257f90b0289cc8ca1cb24eb6cecfb5de26777c8d432bd340634dfd2f996f6b1f854ff643a95f90ea50876a16a6185e7c0beb46285e2884bd6e3159359abcc95b09cc4a168aaf24a53e3ba4ee13d743c9a5cfabaf1886fa2cde909b2149a7cf35af9ec7981e62f9473730fe9664db2194eb9b8f6d4913e2efe595611fe73274871dfd0924e1af16080d1e78ac5b546987148eb8da5ec0d0f8ffc5df4587aa1feb7096c2faeb4735d7efeb45cabe2082566f021c16e90c3cf2a586de0c06a6e79f03fc48bbd725349ee297310e60af060804e6abe24c4eeae3db2d0957e0152a8593b79d316ca9ef0b65c3a2789ee8003e95bf06ac77e433de598e43fdffeb12e243e663606d706570797cbeb30404f8908270c92f09489d385461e3de11040d192b9bdf05e68ab98bfab2540c24ed4884389f4142cd1aa1bfae7232a6184fac343e138f63ce455a6ac486cf64a4c80a012d3bd1b1caad6de5ae460a36672aa193ba7ae0cf49dc920a8c812031f011399ac8c42b79a79d032a8765bc768837adc6857ef289e8d79e7b179a747150b3ab4a90af98efd9b46715a4912c57f0003ebff33d2ed1405c144a30691790861ec6bd5382259dd24e6738fa7e2f4dc1e9266fbdb206654e04114dee5cc7978afc709329c03dd570cd75cac495f882bd67f940387a8edc96490ae0cb94b9a8411b62e26bdbc8f16d0585d8e15ca23b20f8f10a8e58929e05c0bf0332b486b63c6dc51641122e0e3525cea32b9492e0b468f20baa8069eb0cd1d5bd5439def855560b2e5f2d7d1bc8de220fa571d1cab63957318c916454ed5bc0983776336c94dfefe7983a5db8de0e99479f6de05f4447420dadbbe15d6256d44615f75576909c505a40a3b58c8259325b44a92cc70856889eabc2a717d4f3582ee5e2fecd2f7dbf34a8f69b8410c4837fc38f612ef0d22df2ce00df59b0e6ed6eb0e7f2e5a4b8fcedaece67d3febc0365942ed215bd0a18b0d4c8d6496dbf067253fa7a70890660a965c9f76dd0d2886806247105eee2ebd91acd6730fe80dfe53749df769b6a1de3d09f2d74023a05904e26c14b43e5b9630f07f8b08d074174738d23c7ee5f19c97216128fff1b3a3b87453d10daeaa261f1a8c2b5f5817144ae29e47d926275dd4a87caabcb4ce06e9ce8395bf2c922162cbba774022aaeeff3075e55d1f5225405c55d79a98bc5672093d17b092d21f34dd92fadbd6e1faf4f6c0b3d29441592522bb9340bc60d2a84c963c17855438e9ee5d97a2817c9665f6ec58db66a8f042937c185aa63a8f3c1fb8375b8839b9a650848d72aab5658da678f77423acabee6951ce7a9f5ed214b8cbb357b6e4c535765246183b4d0a8bec4927e29150c569c12dbfbabfeceede2f5bfd1337393c93b1b8d4f588ead294d0ccca51b125aa1a7b08465e7efb9b9d9307f20f4e5744aad2a713df8641b90af051ee7245ee9ec49af2dab44983c34218d71b65d5273b743a8baa94f821440b8be486bd1856440ade0a5fbf2be6ba4c5545188c7b4ac3516c94c9c07f2d3dc39a6729ce6a46e50ff4dd32f17dfcc9d5db1ecc395350a4229b716d4ab06f563fdd2fbeea5feb4d59fd79c1a2a03740b3b9c6031b8dcd3a8a9fe922b2bf64f5d1ddbff7af3d1bb9b6bacf193dee7ffc3c8c311295acf74681ceca37f689019beb25f1127af5626131f28499442507d6553848e34f877a9510fcfdcdb21692afeb02b4d81d811ab51ff85ecbda64fa749438852ace58fac756fc4685685b07fafa65c57139d52c299e1f637837127aacac8a761ee756b5de5b16ab8dc14caabbfa715fadef763b1fb208fe78bac58c3ad412eacf7941b1236ed4bfe2117ad523789d6592979b7837efcbf3c51b26d8183a6d17e994ed9fc21e02d7924bb9d9f630865065da173229d6d1dcd94f5ab449b13f29ea182bb875021ec51776ea7f57165b799e515f72b331e5101097231d111f7030e91a155ece053ea3134faa8b6044b6a025f04104c31cd859a0deebf6a818cfca8145d3b1b1ad5592d96806b8ebf6e77dcbec4bb5bb9821e4379eb436e70672d4a55dc3e4185b51d8da46004ca0e9ec1b1d59b7a4b189b63087f23429a1947c1a28adfb8cee0ffe7c1e7dc0bafacdd8789d784f14dc9dbd59038f18fcf79498fa7f818384aefcee324bce057c71408fce03fe1e562e1e97b483d5778d867713a985e7e73b72a0a1332765b3ca1c7a35e3de80db20bc35beca42aaee69bc1412aeb409da3846aa20a8d9403078b141a1ffdd0197db53ac33092ae744bc092a28d51b269a0a33f3b1bef9d4bad50727538ad221b36cebd1ae215192dd2c6a20470860a10e062005d186bdd6c1041</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">文章被主人加密了, 小窝要核验主人给的『通行证』.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树链剖分</title>
      <link href="/2022/09/12/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
      <url>/2022/09/12/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>树链剖分</p><p>树链剖分，就是将树剖分为若干条链，用来维护树上信息，常搭配树上值域线段树，如：</p><ol><li><p>修改<strong>树上两点间的最短路径上</strong>的节点权值</p></li><li><p>查询<strong>树上两点间的最短路径上</strong>的点权和</p></li><li><p>修改以某个点为根的子树的每个节点的点权</p></li><li><p>查询以某个点为根的子树的节点权值和</p></li></ol><p>其中，操作3和4可以直接建立树上值域线段树解决，操作1和2需要进行树链剖分。</p><p>树链剖分有三种方法：重链剖分（复杂度 $O(\log n)$）、长链剖分（复杂度 $O(\sqrt n)$）和实链剖分（常用于LCT维护）。其中，重链剖分最为常见，因此<strong>本节主要记录重链剖分的学习笔记</strong>。</p><h1 id="一、基础定义"><a href="#一、基础定义" class="headerlink" title="一、基础定义"></a>一、基础定义</h1><p><strong>重儿子</strong>：一个节点的所有儿子中，子树大小最大的那一个儿子。如有多种选择，就<strong>只选一个儿子</strong>。</p><p><strong>轻儿子</strong>：一个节点的所有儿子中，不是重儿子的节点。<strong>根节点也是轻儿子。</strong></p><p><strong>重链</strong>：从一个轻儿子开始，沿着重儿子走，连出的极大子链。</p><p><strong>轻链</strong>：不是重链的子链。</p><p><strong>重链定理</strong>$\quad$ 除了根节点以外的任何一个节点的父亲一定在一条重链上。</p><h1 id="二、重链剖分"><a href="#二、重链剖分" class="headerlink" title="二、重链剖分"></a>二、重链剖分</h1><p>重链剖分，需要我们维护一下内容：</p><ol><li><code>fa[MAXN]</code>，即节点的父节点。</li><li><code>dep[MAXN]</code>，即节点深度。</li><li><code>son[MAXN]</code>，即该节点的<strong>重儿子</strong>编号，如果是叶子节点，则 <code>son[p]=0</code>。</li><li><code>top[MAXN]</code>，即该节点所在重链的链头。</li><li><code>sz[MAXN]</code>，即以该节点为根的子树的大小。</li><li><code>dfn[MAXN]</code>，该节点进行 $\text{dfs}$ 的时间戳，即该节点的 $\text{dfs}$ 序。</li><li><code>w[MAXN]</code>，即在 $\text{dfs}$ 序中，该序号节点的权值。</li><li><code>tick</code>，即 $\text{dfs}$ 时间戳。</li></ol><p>前面几个信息可以打包进一个结构体，然后线段树需要另一个结构体。</p><p>重链剖分要求重链上的时间戳一定要连续（方便在线段树上区间修改和查询），所以需要进行两次 $\text{dfs}$。</p><h2 id="2-1-quad-第一次-text-dfs"><a href="#2-1-quad-第一次-text-dfs" class="headerlink" title="2.1$\quad$ 第一次 $\text{dfs}$"></a>2.1$\quad$ 第一次 $\text{dfs}$</h2><p>第一次 $\text{dfs}$ 需要处理出重链剖分的前置信息。</p><p>从根节点开始遍历整棵树。记录节点父亲、子树大小、深度，还有重儿子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    T[u].fa=fa;</span><br><span class="line">    T[u].sz=<span class="number">1</span>;</span><br><span class="line">    T[u].dep=T[fa].dep+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> tmp=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        T[u].sz+=T[v].sz;</span><br><span class="line">        <span class="keyword">if</span>(T[v].sz&gt;tmp)&#123;</span><br><span class="line">            tmp=T[v].sz;</span><br><span class="line">            T[u].son=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-quad-第二次-text-dfs"><a href="#2-2-quad-第二次-text-dfs" class="headerlink" title="2.2$\quad$ 第二次 $\text{dfs} $"></a>2.2$\quad$ 第二次 $\text{dfs} $</h2><p>第二次 $\text{dfs}$ 就可以剖分这棵树了。</p><p>我们进行重链剖分，记录该节点所在的重链的链头和时间戳。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    T[u].top=t;</span><br><span class="line">    dfn[u]=++tick;</span><br><span class="line">    w[tick]=a[u];</span><br><span class="line">    <span class="keyword">if</span>(!T[u].son) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(T[u].son,t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==T[u].fa||v==T[u].son) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-quad-建立树上值域线段树"><a href="#2-3-quad-建立树上值域线段树" class="headerlink" title="2.3$\quad$ 建立树上值域线段树"></a>2.3$\quad$ 建立树上值域线段树</h2><p>因为子树的 $\text{dfs}$ 序一个区间，我们就可以建立值域线段树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].l=l,tree[p].r=r;</span><br><span class="line">    tree[p].tag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[p].sum=w[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,ls);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">    <span class="built_in">update</span>(p);<span class="comment">//整合子树信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、维护信息"><a href="#三、维护信息" class="headerlink" title="三、维护信息"></a>三、维护信息</h1><h2 id="3-1-quad-进行子树加操作"><a href="#3-1-quad-进行子树加操作" class="headerlink" title="3.1$\quad$ 进行子树加操作"></a>3.1$\quad$ 进行子树加操作</h2><p>因为子树的 $\text{dfs}$ 序是一个区间，可以在线段树上进行区间修改操作（$\text{modify}$），修改的区间就是 ，其$[\text{dfn}[p],\text{dfn}[p]+\text{sz}[p]-1]$中 $p$ 为子树根节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r)&#123;</span><br><span class="line">        tree[p].sum=(tree[p].sum+k*<span class="built_in">len</span>(p))%mod;</span><br><span class="line">        tree[p].tag=(tree[p].tag+k)%mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);<span class="comment">//懒标记下传</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(l,r,k,ls);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(l,r,k,rs);</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//in main:</span></span><br><span class="line"><span class="built_in">modify</span>(dfn[x],dfn[x]+T[x].sz<span class="number">-1</span>,z,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="3-2-quad-进行子树求和"><a href="#3-2-quad-进行子树求和" class="headerlink" title="3.2$\quad$进行子树求和"></a>3.2$\quad$进行子树求和</h2><p>类比子树加操作，在线段树上进行区间求和（$\text{query}$），求和区间就是 $[\text{dfn}[p],\text{dfn}[p]+\text{sz}[p]-1]$，其中 $p$ 为子树根节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r) <span class="keyword">return</span> tree[p].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans=(ans+<span class="built_in">query</span>(l,r,ls))%mod;</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ans=(ans+<span class="built_in">query</span>(l,r,rs))%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//in main:</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">query</span>(dfn[x],dfn[x]+T[x].sz<span class="number">-1</span>,<span class="number">1</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h2 id="3-3-quad-进行路径修改操作"><a href="#3-3-quad-进行路径修改操作" class="headerlink" title="3.3$\quad$ 进行路径修改操作"></a>3.3$\quad$ 进行路径修改操作</h2><p>根据重连定理，除了根节点以外的任何一个节点的父亲一定在一条重链上。所以我们就可以进行重链到重链的转换，从而一点一点地在每一条链上进行区间修改。</p><p>考虑每次选择链头深度高的那条链，将该节点跳到链头并区间修改，此时就改掉了这条链（也就是路径的一部分）上的值，修改区间为 $[\text{dfn}[\text{top}[p]],\text{dfn}[p]]$，其中，$p$ 为该节点，而后跳到链头的父亲，此时就在另一条链上了，可以重复操作直到两节点在同一条重链上。</p><p>如果两节点在同一跳重链上，则可以直接进行区间修改，修改区间为 $[\text{dfn}[x],\text{dfn}[y]]$$，其中 $x,y$ 是两个节点，且防止无效修改操作， $\text{dep}[x]&lt;\text{dep}[y]$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addOnTree</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    c%=mod;</span><br><span class="line">    <span class="keyword">while</span>(T[x].top!=T[y].top)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T[T[x].top].dep&lt;T[T[y].top].dep) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="built_in">modify</span>(dfn[T[x].top],dfn[x],c,<span class="number">1</span>);</span><br><span class="line">        x=T[T[x].top].fa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T[x].dep&gt;T[y].dep) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="built_in">modify</span>(dfn[x],dfn[y],c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-quad-进行路径求和操作"><a href="#3-4-quad-进行路径求和操作" class="headerlink" title="3.4$\quad$ 进行路径求和操作"></a>3.4$\quad$ 进行路径求和操作</h2><p>思想类似路径修改，只不过把修改操作改成求和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSumOnTree</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T[x].top!=T[y].top)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T[T[x].top].dep&lt;T[T[y].top].dep) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        ans=(ans+<span class="built_in">query</span>(dfn[T[x].top],dfn[x],<span class="number">1</span>))%mod;</span><br><span class="line">        x=T[T[x].top].fa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T[x].dep&gt;T[y].dep) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    ans=(ans+<span class="built_in">query</span>(dfn[x],dfn[y],<span class="number">1</span>))%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、参考代码"><a href="#四、参考代码" class="headerlink" title="四、参考代码"></a>四、参考代码</h1><p>本代码为树链剖分/重链剖分模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((tree[p].l+tree[p].r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (p&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (p&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> len(x) (tree[x].r-tree[x].l+1)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">G</span>&#123;</span><br><span class="line">    <span class="type">int</span> sz,dep,top,son,fa;</span><br><span class="line">&#125;T[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">F</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,sum,tag;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m,r,mod,a[MAXN],dfn[MAXN],tick,w[MAXN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    T[u].fa=fa;</span><br><span class="line">    T[u].sz=<span class="number">1</span>;</span><br><span class="line">    T[u].dep=T[fa].dep+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> tmp=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        T[u].sz+=T[v].sz;</span><br><span class="line">        <span class="keyword">if</span>(T[v].sz&gt;tmp)&#123;</span><br><span class="line">            tmp=T[v].sz;</span><br><span class="line">            T[u].son=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    T[u].top=t;</span><br><span class="line">    dfn[u]=++tick;</span><br><span class="line">    w[tick]=a[u];</span><br><span class="line">    <span class="keyword">if</span>(!T[u].son) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(T[u].son,t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==T[u].fa||v==T[u].son) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].sum=tree[ls].sum+tree[rs].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].l=l,tree[p].r=r;</span><br><span class="line">    tree[p].tag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[p].sum=w[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,ls);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tree[p].tag) <span class="keyword">return</span>;</span><br><span class="line">    tree[ls].sum=(tree[ls].sum+tree[p].tag*<span class="built_in">len</span>(ls))%mod;</span><br><span class="line">    tree[rs].sum=(tree[rs].sum+tree[p].tag*<span class="built_in">len</span>(rs))%mod;</span><br><span class="line">    tree[ls].tag=(tree[ls].tag+tree[p].tag)%mod;</span><br><span class="line">    tree[rs].tag=(tree[rs].tag+tree[p].tag)%mod;</span><br><span class="line">    tree[p].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r)&#123;</span><br><span class="line">        tree[p].sum=(tree[p].sum+k*<span class="built_in">len</span>(p))%mod;</span><br><span class="line">        tree[p].tag=(tree[p].tag+k)%mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(l,r,k,ls);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(l,r,k,rs);</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addOnTree</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    c%=mod;</span><br><span class="line">    <span class="keyword">while</span>(T[x].top!=T[y].top)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T[T[x].top].dep&lt;T[T[y].top].dep) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="built_in">modify</span>(dfn[T[x].top],dfn[x],c,<span class="number">1</span>);</span><br><span class="line">        x=T[T[x].top].fa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T[x].dep&gt;T[y].dep) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="built_in">modify</span>(dfn[x],dfn[y],c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r) <span class="keyword">return</span> tree[p].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans=(ans+<span class="built_in">query</span>(l,r,ls))%mod;</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ans=(ans+<span class="built_in">query</span>(l,r,rs))%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSumOnTree</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T[x].top!=T[y].top)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T[T[x].top].dep&lt;T[T[y].top].dep) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        ans=(ans+<span class="built_in">query</span>(dfn[T[x].top],dfn[x],<span class="number">1</span>))%mod;</span><br><span class="line">        x=T[T[x].top].fa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T[x].dep&gt;T[y].dep) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    ans=(ans+<span class="built_in">query</span>(dfn[x],dfn[y],<span class="number">1</span>))%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;r&gt;&gt;mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x,y,i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(r,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(r,r);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> op,x,y,z,i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">                cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">                <span class="built_in">addOnTree</span>(x,y,z);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">                cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">                cout&lt;&lt;<span class="built_in">getSumOnTree</span>(x,y)&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">                cin&gt;&gt;x&gt;&gt;z;</span><br><span class="line">                <span class="built_in">modify</span>(dfn[x],dfn[x]+T[x].sz<span class="number">-1</span>,z,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:&#123;</span><br><span class="line">                cin&gt;&gt;x;</span><br><span class="line">                cout&lt;&lt;<span class="built_in">query</span>(dfn[x],dfn[x]+T[x].sz<span class="number">-1</span>,<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合计数</title>
      <link href="/2022/08/03/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/"/>
      <url>/2022/08/03/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>组合计数</p><p>本章主要记录基础组合数学的有关知识，包括加法原理、乘法原理、排列组合、二项式定理、卢卡斯定理等基本知识。</p><h1 id="一、计数原理"><a href="#一、计数原理" class="headerlink" title="一、计数原理"></a>一、计数原理</h1><p>基础的计数原理包括加法原理和乘法原理，是组合数学的基础。</p><h2 id="1-1-quad-加法原理"><a href="#1-1-quad-加法原理" class="headerlink" title="1.1$\quad$加法原理"></a>1.1$\quad$加法原理</h2><p>若完成一件事情的方法有 $n$ 类，其中第 $i$ 类方法有 $a_i$ 种不同的方法，且这些方法互补重合，则完成这件事一共有 $\sum_{i=1}^na_i$ 种不同的方法。这样的计数原理称为<strong>加法原理</strong>。</p><p><strong>例</strong>$\qquad$中午可以去A、B、C三个街区吃饭，三个街区分别有 $6$、$5$、$8$ 家餐厅，那么中午吃饭有 $6+5+8=19$ 家餐厅可选。</p><h2 id="1-2-quad-乘法原理"><a href="#1-2-quad-乘法原理" class="headerlink" title="1.2$\quad$乘法原理"></a>1.2$\quad$乘法原理</h2><p>若完成一件事情需要 $n$ 个步骤，其中第 $i$ 个步骤有 $a_i$ 种不同的完成方法，且这些步骤互不干扰，则完成这件事一共有 $\prod_{i=1}^na_i$ 种不同的方法。这样的计数原理成为<strong>乘法原理</strong>。</p><p><strong>例</strong>$\quad$餐厅有 $4$ 种主食，$2$ 种配菜，$5$ 种配汤，那么可以组成 $4\times2\times5=40 $ 种套餐。</p><h1 id="二、排列数与组合数"><a href="#二、排列数与组合数" class="headerlink" title="二、排列数与组合数"></a>二、排列数与组合数</h1><h2 id="2-1-quad-排列数"><a href="#2-1-quad-排列数" class="headerlink" title="2.1$\quad$排列数"></a>2.1$\quad$排列数</h2><p>从 $n$ 个不同元素种依次选出 $m$ 个元素排成一列，产生的不同的排列的数量为</p><script type="math/tex; mode=display">A_n^m(\text{或记作}P_n^m)=\dfrac{n!}{(n-m)!}</script><h2 id="2-2-quad-组合数"><a href="#2-2-quad-组合数" class="headerlink" title="2.2$\quad$组合数"></a>2.2$\quad$组合数</h2><p>从 $n$ 个不同元素种依次选出 $m$ 个组成一个集合（不考虑顺序），产生的不同的集合的数量为</p><script type="math/tex; mode=display">C_n^m(\text{或记作}\dbinom{n}{m})=\dfrac{n!}{m!(n-m)!}</script><h2 id="2-3-quad-组合恒等式"><a href="#2-3-quad-组合恒等式" class="headerlink" title="2.3$\quad$组合恒等式"></a>2.3$\quad$组合恒等式</h2><p><strong>恒等式1</strong>$\quad$ 选出一部分再反选，有 $\dbinom{n}{k}=\dbinom{n}{n-k}$。</p><p><strong>恒等式2</strong>$\quad$ 考虑枚举是否选第 $1$ 个，有 $\dbinom{n}{k}=\dbinom{n-1}{k}+\dbinom{n-1}{k-1}$。</p><p><strong>恒等式3</strong>$\quad\dbinom{n}{k}\dbinom{k}{t}=\dbinom{n}{t}\dbinom{n-t}{k-t}$。</p><p>$\qquad$辅助理解：$n$ 个人选 $k$ 个队长再在其中选 $t$ 个大队长，等于 $n$ 个人选 $t$ 个大队长再在剩下 $n-t$ 个选 $k-t$ 个队长。</p><p><strong>恒等式4</strong>$\quad$ 枚举最后一个选在哪里，也可由恒等式1迭代导出，有 $\dbinom{n}{k}=\sum\limits_{i=k}^n\dbinom{i-1}{k-1}$。</p><p><strong>恒等式5</strong>$\quad$ $n+m$ 个选 $k$ 个，枚举前 $n$ 个选多少，有 $\dbinom{n+m}{k}=\sum\limits_{i=0}^k\dbinom{n}{i}\dbinom{m}{k-i}$。</p><p><strong>恒等式6</strong>$\quad$ 枚举第 $a+1$ 个位置，有 $\dbinom{n}{a+b+1}=\sum\limits_{i=a+1}^{n-b}\dbinom{i-1}{a}\dbinom{n-i}{b}$。</p><p>$b=0$ 时退化为恒等式4。</p><p><strong>恒等式7</strong>$\quad$ $\sum\limits_{i=0}^n\dbinom{n}{i}=2^n$。</p><h2 id="2-4-quad-组合数的求法"><a href="#2-4-quad-组合数的求法" class="headerlink" title="2.4$\quad$组合数的求法"></a>2.4$\quad$组合数的求法</h2><h3 id="2-4-1-quad-根据定义求解"><a href="#2-4-1-quad-根据定义求解" class="headerlink" title="2.4.1 $\quad$ 根据定义求解"></a>2.4.1 $\quad$ 根据定义求解</h3><p>求解 $C_n^m\bmod p$ 时，可以计算 $n!\bmod p$ 的值，之后乘上 $m!^{-1}(n-m)!^{-1}\bmod p$ （即逆元）即可。当 $p$ 为质数时可以利用欧拉定理和快速幂求解逆元，其余情况可以线性求解逆元。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll p)</span></span>&#123;</span><br><span class="line">    ll w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) w=w*a%p;</span><br><span class="line">        a=a*a%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m,ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (a[n]*<span class="built_in">qpow</span>(a[m],p<span class="number">-2</span>,p)%p)*<span class="built_in">qpow</span>(a[n-m],p<span class="number">-2</span>,p)%p;<span class="comment">//a数组为线性预处理的阶乘数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-2-quad-递推求解"><a href="#2-4-2-quad-递推求解" class="headerlink" title="2.4.2 $\quad$ 递推求解"></a>2.4.2 $\quad$ 递推求解</h3><p>根据组合恒等式 2</p><script type="math/tex; mode=display">\dbinom{n}{k}=\dbinom{n-1}{k}+\dbinom{n-1}{k-1}</script><p>我们可以递推求解。下面的代码求解出了所有 $\dbinom{i}{j}(0\leq j\leq i\leq n)$，表示为数组 <code>c[i][j]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        c[i][<span class="number">0</span>]=c[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            c[i][j]=(c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、二项式定理与杨辉三角"><a href="#三、二项式定理与杨辉三角" class="headerlink" title="三、二项式定理与杨辉三角"></a>三、二项式定理与杨辉三角</h1><h2 id="3-1-quad-二项式定理"><a href="#3-1-quad-二项式定理" class="headerlink" title="3.1$\quad$二项式定理"></a>3.1$\quad$二项式定理</h2><script type="math/tex; mode=display">(a+b)^n=\sum\limits_{k=0}^nC_n^ka^kb^{n-k}</script><p><strong>例</strong> $\quad$ $(a+b)^3=a^3+3a^2b+3ab^2+b^3$。</p><h2 id="3-2-quad-杨辉三角"><a href="#3-2-quad-杨辉三角" class="headerlink" title="3.2$\quad$杨辉三角"></a>3.2$\quad$杨辉三角</h2><p>对于每个 $n$，二项式定理拆解后的二项式稀疏构成杨辉三角，如下图。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/bisgz7o3.png" alt=""></p><p>可以发现，三角中每一个数为其左上和右上的两个数之和，可以得出 $C_n^k=C_{n-1}^{k-1}+C_{n-1}^{k}$，即恒等式 2。</p><h1 id="四、卢卡斯定理"><a href="#四、卢卡斯定理" class="headerlink" title="四、卢卡斯定理"></a>四、卢卡斯定理</h1><h2 id="4-1-quad-卢卡斯定理"><a href="#4-1-quad-卢卡斯定理" class="headerlink" title="4.1$\quad$卢卡斯定理"></a>4.1$\quad$卢卡斯定理</h2><p><strong>卢卡斯定理</strong>$\quad$若 $p$ 是质数，则对于任意整数 $1\leq m\leq n$，有：</p><script type="math/tex; mode=display">\dbinom{n}{m}\equiv \dbinom{n\bmod p}{m\bmod p}\dbinom{n/p}{m/p}\pmod p</script><p>求解 $\binom{n}{m}\bmod p$ 时，可以利用公式求解 $\dbinom{n\bmod p}{m\bmod p}\bmod p$，同时递归求解 $\dbinom{n/p}{m/p}\bmod p$，需要预处理出阶乘数组 $a$，在计算 $\dfrac{n!}{m!(n-m)!}$ 时利用逆元求出。因为 $p$ 为质数，所以可以直接用快速幂方法求出逆元。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line">ll t,a[MAXN];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll p)</span></span>&#123;</span><br><span class="line">    ll w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) w=w*a%p;</span><br><span class="line">        a=a*a%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m,ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (a[n]*<span class="built_in">qpow</span>(a[m],p<span class="number">-2</span>,p)%p)*<span class="built_in">qpow</span>(a[n-m],p<span class="number">-2</span>,p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">lucas</span><span class="params">(ll n,ll m,ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(n%p,m%p,p)*<span class="built_in">lucas</span>(n/p,m/p,p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,m,p;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line">        a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++) a[i]=a[i<span class="number">-1</span>]*i%p;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">lucas</span>(n+m,m,p)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-扩展卢卡斯定理"><a href="#4-2-扩展卢卡斯定理" class="headerlink" title="4.2 扩展卢卡斯定理"></a>4.2 扩展卢卡斯定理</h2><p>此部分需要同余基础知识点，<del>貌似与卢卡斯定理没有任何关系</del>。</p><p>因为利用卢卡斯定理处理问题存在局限性（$p$ 必须为质数），不能处理普遍情况。此时可以用扩展卢卡斯定理解决普遍情况。</p><p><strong>求解以下问题</strong>：对于组合数 $\dbinom{n}{m}$ ，求 $\dbinom{n}{m}\bmod p$ ，$p$ 不保证为质数。</p><p>如果 $p$ 为质数会方便很多，所以考虑将其拆为若干个模质数的式子。根据唯一分解定理，</p><script type="math/tex; mode=display">P=p_1^{a_1}p_2^{a_2}\cdots p_k^{a_k}</script><p>所以考虑拆分为</p><script type="math/tex; mode=display">\begin{cases}x_1\equiv\dbinom{n}{m}&\pmod {p_1^{a_1}}\\x_2\equiv\dbinom{n}{m}&\pmod {p_2^{a_2}}\\&\cdots\\x_k\equiv\dbinom{n}{m}&\pmod {p_k^{a_k}}\end{cases}</script><p>因为 $\dbinom{n}{m}=\dfrac{n!}{m!(n-m)!}$ ，在模  $p_1^{a_1}$ 意义下不能直接利用逆元化解分母。所以考虑如下拆分：</p><script type="math/tex; mode=display">\dbinom{n}{m}\equiv\dfrac{n!}{m!(n-m)!}\equiv\dfrac{\dfrac{n!}{p^x}}{\dfrac{m!}{p^y}\cdot\dfrac{(n-m)!}{p^z}}\cdot p^{x-y-z}\pmod {p^k}</script><p>$x$ 为 $n!$ 中包含的 $p$ 的因子个数，$y$、$z$  同理。</p><p>考虑逐个解决。因为 $n!$ 中一共有 $\left\lfloor\dfrac{n}{p}\right\rfloor$ 个数是 $p$ 的倍数，然后递归处理其他因数。</p><script type="math/tex; mode=display">n!\equiv p^{\left\lfloor\frac{n}{p}\right\rfloor}(\left\lfloor\frac{n}{p}\right\rfloor)!(\prod\limits_{i=1,i\not\equiv0\pmod p}^{n}i)\pmod{p^k}</script><p>将 $\prod\limits_{i=1,i\not\equiv0\pmod p}^{n}i$  拆分为两个部分：不含有 $p$ 的因子和含有 $p$ 的因子。</p><script type="math/tex; mode=display">n!\equiv p^{\left\lfloor\frac{n}{p}\right\rfloor}(\left\lfloor\frac{n}{p}\right\rfloor)!(\prod\limits_{i=1,i\not\equiv0\pmod p}^{p^k}i)^{\left\lfloor\frac{n}{p^k}\right\rfloor}(\prod\limits_{i=p^k\left\lfloor\frac{n}{p^k}\right\rfloor,i\not\equiv0\pmod p}^{n}i)\pmod{p^k}</script><p>所以考虑设立函数 $f(n)=\dfrac{n!}{p^k}$，所以有</p><script type="math/tex; mode=display">f(n)\equiv\dfrac{n!}{p^k}\equiv p^{\left\lfloor\frac{n}{p}\right\rfloor}(\left\lfloor\frac{n}{p}\right\rfloor)!(\prod\limits_{i=1,i\not\equiv0\pmod p}^{p^k}i)^{\left\lfloor\frac{n}{p^k}\right\rfloor}(\prod\limits_{i=p^k\left\lfloor\frac{n}{p^k}\right\rfloor,i\not\equiv0\pmod p}^{n}i)\pmod{p^k}</script><p>边界：$f(0)=1$。</p><p>这样函数 $f$ 就一定和 $p^k$ 互质了，就可以直接利用扩展欧几里得算法（$\text{exgcd}$）求出逆元（ $\text{inv}$ ），化分母。</p><p>然后还需要求解 $p^{x-y-z}$。考虑设立函数 $g(n)=x$（ $x$ 为 $n!$ 中包含的 $p$ 的因子数），所以有</p><script type="math/tex; mode=display">g(n)=\left\lfloor\frac{n}{p}\right\rfloor+g(\left\lfloor\dfrac{n}{p}\right\rfloor)</script><p>边界：$g(x)=0(x&lt;p)$</p><p>这样就可以求解啦。式子变成了</p><script type="math/tex; mode=display">\dbinom{n}{m}\equiv\dfrac{f(n)}{f(m)f(n-m)}\cdot p^{g(n)-g(m)-g(n-m)}\pmod{p^k}</script><p>然后用中国剩余定理（ $\text{CRT}$ ）合并即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 10005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n,m,P,A[MAXN],B[MAXN];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll p)</span></span>&#123;</span><br><span class="line">    ll w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) w=w*a%p;</span><br><span class="line">        a=a*a%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x,ll p,ll pk)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ll a=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=pk;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%p) a=a*i%pk;</span><br><span class="line">    &#125;</span><br><span class="line">    a=<span class="built_in">qpow</span>(a,x/pk,pk);</span><br><span class="line">    <span class="keyword">for</span>(ll i=pk*(x/pk);i&lt;=x;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%p) b=b*(i%pk)%pk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(x/p,p,pk)*a%pk*b%pk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll p)</span></span>&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a,p,x,y);</span><br><span class="line">    <span class="keyword">return</span> (x+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">g</span><span class="params">(ll x,ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x/p+<span class="built_in">g</span>(x/p,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">CmodPk</span><span class="params">(ll p,ll pk)</span></span>&#123;</span><br><span class="line">    ll fx=<span class="built_in">f</span>(n,p,pk),fy=<span class="built_in">f</span>(m,p,pk),fz=<span class="built_in">f</span>(n-m,p,pk);</span><br><span class="line">    fy=<span class="built_in">inv</span>(fy,pk),fz=<span class="built_in">inv</span>(fz,pk);</span><br><span class="line">    <span class="keyword">return</span> fx*fy%pk*fz%pk*<span class="built_in">qpow</span>(p,<span class="built_in">g</span>(n,p)-<span class="built_in">g</span>(m,p)-<span class="built_in">g</span>(n-m,p),pk)%pk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">crt</span><span class="params">(ll cnt)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        ll M=P/A[i];</span><br><span class="line">        ll T=<span class="built_in">inv</span>(M,A[i]);</span><br><span class="line">        ans=(ans+B[i]*M%P*T%P)%P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">exlucas</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll tmp=P,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=P;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp%i==<span class="number">0</span>)&#123;</span><br><span class="line">            ll pk=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(tmp%i==<span class="number">0</span>) pk*=i,tmp/=i;</span><br><span class="line">            A[++cnt]=pk;</span><br><span class="line">            B[cnt]=<span class="built_in">CmodPk</span>(i,pk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        A[++cnt]=tmp;</span><br><span class="line">        B[cnt]=<span class="built_in">CmodPk</span>(tmp,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">crt</span>(cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;P;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">exlucas</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同余</title>
      <link href="/2022/05/05/%E5%90%8C%E4%BD%99/"/>
      <url>/2022/05/05/%E5%90%8C%E4%BD%99/</url>
      
        <content type="html"><![CDATA[<p>同余</p><p>本章主要记录有关同余、费马小定理、欧拉定理、扩展欧几里得算法、裴蜀定理、乘法逆元、威尔逊定理、线性同余方程、中国剩余定理、扩展中国剩余定理、BSGS以及扩展BSGS的学习笔记。</p><p>由于内容复杂且关联较少，建议配备 <code>ctrl+F</code> 进行快乐食用。</p><p>正在继更ing</p><h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><p>这个板块着重介绍同余的基本知识，虽然多为数学竞赛内容，但也对信息学竞赛有不少帮助，定理和性质为拓展内容。</p><p>本部分参考《初等数论》进行撰写。</p><h2 id="1-1-quad-基本定义、定理与性质"><a href="#1-1-quad-基本定义、定理与性质" class="headerlink" title="1.1$\quad$基本定义、定理与性质"></a>1.1$\quad$基本定义、定理与性质</h2><p><strong>定义1</strong>（<strong>同余</strong>）$\quad$ 设 $m\neq0$。若 $m\mid a-b$，即 $a-b=km$，则称 $m$ 为<strong>模</strong>，$a$ <strong>同于与</strong> $b$ <strong>模</strong> $m$ 以及 $b$ <strong>是</strong> $a$ <strong>对模</strong> $m$ <strong>的剩余</strong>，记作</p><script type="math/tex; mode=display">a\equiv b\pmod{m} \tag{1}</script><p>不然，则称 $a$ <strong>不同余于</strong> $b$ <strong>模</strong> $m$，$b$ <strong>不是</strong> $a$ <strong>对模</strong> $m$ <strong>的剩余</strong>，记作 $a\not\equiv b\pmod{m}$</p><p>式 $(1)$ 称为<strong>模</strong> $m$ <strong>的同余式</strong>，或简称<strong>同余式</strong>。</p><p>由于 $m\mid a-b$ 等价于 $-m\mid a-b$ ，所以同余式 $(1)$ 等价于</p><script type="math/tex; mode=display">a\equiv b\pmod{(-m)}</script><p><strong>定理1</strong>$\quad$ $a$ 同余于 $b$ 模 $m$ 的充要条件是 $a$ 和 $b$ 被 $m$ 除后所得的最小非负余数相等，即若</p><script type="math/tex; mode=display">\begin{aligned}a=q_1m+r_1&,0\leq r_1<m\\b=q_2m+r_2&,0\leq r_2<m,\end{aligned}</script><p>则 $r_1=r_2$。</p><p><strong>性质Ⅰ</strong>$\quad$ 同余是一种等价关系，即有</p><script type="math/tex; mode=display">\begin{aligned}a\equiv a\pmod{m}\\a\equiv b\pmod{m}\iff b\equiv a\pmod{m}\\a\equiv b\pmod{m}\;,\;b\equiv c\pmod{m}\Rightarrow a\equiv c\pmod{m}\end{aligned}</script><p><strong>性质Ⅱ</strong>$\quad$ 同余式可以相加，即若有</p><script type="math/tex; mode=display">a\equiv b\pmod{m}\;,\;c\equiv d\pmod{m}\tag{2}</script><p>则有</p><script type="math/tex; mode=display">a+c\equiv b+d\pmod m</script><p><strong>性质Ⅲ</strong>$\quad$ 同余式可以相乘，即若式 $(2)$ 成立，则</p><script type="math/tex; mode=display">ac\equiv bd\pmod m</script><p><strong>性质Ⅳ</strong>$\quad$ 设 $f(x)=a_nx^n+\cdots+a_0$，$g(x)=b_nx^n+\cdots+b_0$ 是两个整系数多项式，满足</p><script type="math/tex; mode=display">a_j\equiv b_j\pmod m\;,\;0\leq j<n\tag{3}</script><p>那么，若 $a\equiv b\pmod m$，则</p><script type="math/tex; mode=display">f(a)\equiv g(b)\pmod m</script><p>特别地，<strong>对所有整数</strong> $x$ 有</p><script type="math/tex; mode=display">f(x)\equiv g(x)\pmod m\tag{4}</script><p><strong>定义2</strong>$\quad$ 设 $f(x)=a_nx^n+\cdots+a_0$ 和 $g(x)=b_nx^n+\cdots+b_0$ 是两个整系数多项式。当满足条件 $(3)$ 时，称<strong>多项式</strong> $f(x)$ <strong>同余于多项式</strong> $g(x)$ <strong>模</strong> $m$，记作</p><script type="math/tex; mode=display">f(x)\equiv g(x)\pmod m</script><p>当满足 $f(x)\equiv g(x)\pmod m$ 时，称<strong>多项式</strong> $f(x)$ <strong>等价于多项式</strong> $g(x)$ <strong>模</strong> $m$，式 $(4)$称为<strong>模</strong> $m$ <strong>的恒等同余式</strong></p><p><strong>性质Ⅴ</strong>$\quad$ 设 $d\geq1$，$d\mid m$，那么，若式 $(1)$ 成立，则 $a\equiv b\pmod d$</p><p><strong>性质Ⅵ</strong>$\quad$ 设 $d\not=0$，那么 $a\equiv b\pmod m$ 等价于 $da\equiv db\pmod{\left\vert d\right\vert m}$</p><p><strong>性质Ⅶ</strong>$\quad$ 同余式 $ca\equiv cb\pmod m$ 等价于 $a\equiv b\pmod{\frac m{\gcd(c,m)}}$</p><p>特别地，当 $\gcd(c,m)=1$ 时，上述同余式等价于 $a\equiv b\pmod m$</p><p><strong>性质Ⅷ</strong>$\qquad$ 若 $m\geq1$，$\gcd(a,m)=1$，则存在 $c$ 使得</p><script type="math/tex; mode=display">ca\equiv1\pmod m\tag{5}</script><p><strong>定义3</strong>$\quad$ 若存在 $m\geq1$，$\gcd(a,m)=1$，且满足式 $(5)$，我们把 $c$ 称为 $a$ 对模 $m$ 的逆，记作 $a^{-1}\pmod m$ 或 $a^{-1}$</p><p><strong>性质Ⅸ</strong>$\quad$ 同余式组</p><script type="math/tex; mode=display">a\equiv b\pmod{m_j}\;,\;j=1,2,\cdots,k</script><p>同时成立的充要条件是</p><script type="math/tex; mode=display">a\equiv b\pmod{[m_1,m_2,\cdots,m_k]}</script><h2 id="1-2-quad-同余类与剩余系"><a href="#1-2-quad-同余类与剩余系" class="headerlink" title="1.2$\quad$同余类与剩余系"></a>1.2$\quad$同余类与剩余系</h2><p><strong>定义4（同余类和剩余系）</strong>$\quad$ 对于 $\forall a\in [0,m-1]$，集合 $\{a+km\}(k\in\mathbb{Z})$ 的所有数模 $m$ 同余，余数都是 $a$，该集合成为模 $m$ 的<strong>同余类</strong>，简记为 $\overline{a}$。</p><p>模 $m$ 的同余类一共有 $m$ 个，分别为 $\overline{0},\overline{1},\overline{2},\cdots,\overline{m-1}$。它们构成 $m$ 的<strong>完全剩余系</strong>。</p><p>$1\sim m$ 中与 $m$ 互质的数代表的同余类共有 $\phi(m)$ 个，它们构成 $m$ 的<strong>简化剩余系</strong>。</p><h1 id="二、费马小定理和欧拉定理"><a href="#二、费马小定理和欧拉定理" class="headerlink" title="二、费马小定理和欧拉定理"></a>二、费马小定理和欧拉定理</h1><p>前置芝士：欧拉函数。</p><p>利用同余基本知识和欧拉函数，即可证明费马小定理和欧拉定理。</p><h2 id="2-1-quad-费马小定理"><a href="#2-1-quad-费马小定理" class="headerlink" title="2.1$\quad$费马小定理"></a>2.1$\quad$费马小定理</h2><p><strong>定理2（费马小定理）</strong>$\quad$ 若 $p$ 是质数，则对于任意整数 $a$，有</p><script type="math/tex; mode=display">a^p\equiv a\pmod p</script><h2 id="2-2-quad-欧拉定理"><a href="#2-2-quad-欧拉定理" class="headerlink" title="2.2$\quad$欧拉定理"></a>2.2$\quad$欧拉定理</h2><p><strong>定理3（欧拉定理）</strong>$\quad$ 若正整数 $a,n$ 互质，则</p><script type="math/tex; mode=display">a^{\phi(n)}\equiv1\pmod n</script><p>其中，$\phi(n)$ 为欧拉函数。</p><p>特别地，当 $p$ 是质数时，$\phi(p)=p-1$，并且只有 $p$ 的倍数与 $p$ 不互质，所以，只要 $a$ 不是 $p$ 的倍数，就有</p><script type="math/tex; mode=display">a^{p-1}\equiv1\pmod p</script><p>两边同乘 $a$ 就是费马小定理。</p><p><strong>证</strong>$\quad$ 设 $n$ 的简化剩余系为 $\{\overline{a_1},\overline{a_2},\cdots,\overline{a_{\phi(n)}}\}$。对于 $\forall a_i,a_j$，若 $a\times a_i\equiv a\times a_j\pmod n$，则 $a\times(a_i-a_j)\equiv 0$。因为 $a,n$ 互质，所以 $a_i-a_j\equiv 0$，即 $a_i\equiv a_j$。故当 $a_i\not=a_j$ 时，$aa_1,aa_j$ 也代表不同的同余类。</p><p>又因为简化剩余系关于模 $n$ 乘法封闭，故 $\overline{aa_1}$ 也在简化剩余系集合中。因此，集合 $\{\overline{a_1},\overline{a_2},\cdots,\overline{a_{\phi(n)}}\}$ 与集合 $\{\overline{aa_1},\overline{aa_2},\cdots,\overline{aa_{\phi(n)}}\}$ 都能表示 $n$ 的简化剩余系，故有</p><script type="math/tex; mode=display">a^{\phi(n)}\prod\limits_{i=1}^{\phi(n)} a_i\equiv\prod\limits_{i=1}^{\phi(n)}aa_i\equiv \prod\limits_{i=1}^{\phi(n)}a_i\pmod n</script><p>两边同时除以 $\prod\limits_{i=1}^{\phi(n)}a_i$ 可得</p><script type="math/tex; mode=display">a^{\phi(n)}\equiv1\pmod n</script><p>当 $p$ 为质数时，$\phi(p)=p-1$，并且只有 $p$ 的倍数与 $p$ 不互质。所以，只要 $a$ 不是 $p$ 的倍数，$a^{p-1}\equiv1\pmod p$ 显然成立。两边同乘 $a$ 即费马小定理。</p><p><strong>证毕。</strong></p><h2 id="2-3-quad-欧拉定理的推论"><a href="#2-3-quad-欧拉定理的推论" class="headerlink" title="2.3$\quad$欧拉定理的推论"></a>2.3$\quad$欧拉定理的推论</h2><p><strong>推论1（欧拉定理推论）</strong>$\quad$ 若正整数 $a,n$ 互质，则对于任意正整数 $b$，有</p><script type="math/tex; mode=display">a^b\equiv a^{b\mod{\phi(n)}}\pmod n</script><p><strong>证</strong>$\quad$ 设 $b=q\times\phi(n)+r$，其中 $0\leq r&lt;\phi(n)$，即 $r=b\mod{\phi(n)}$。利用欧拉定理有</p><script type="math/tex; mode=display">a^b\equiv a^{q\times\phi(n)+r}\equiv(a^{\phi(n)})^q\times a^r\equiv 1^q\times a^r\equiv a^r\equiv a^{b\mod{\phi(n)}+\phi(n)}\pmod n</script><p><strong>证毕。</strong></p><p>特别地，当 $a,n$ 不一定互质且 $b&gt;\phi(n)$ 时，有</p><script type="math/tex; mode=display">a^b\equiv a^{b\mod{\phi(n)+\phi(n)}}\pmod n</script><h2 id="2-4-quad-光速幂"><a href="#2-4-quad-光速幂" class="headerlink" title="2.4$\quad$光速幂"></a>2.4$\quad$光速幂</h2><p>给定 $a$ 和 $c$，每次询问给出 $b$，求 $a^b\bmod c$。</p><p>我们可以先运用 $a^b\bmod a^{b\bmod \phi(n)+\phi(n)}\pmod c$，将 $b$ 缩小到 $2\phi(c)(&lt;2c)$ 的范围，有</p><script type="math/tex; mode=display">a^b=(a^{\sqrt c})^{\left\lfloor\frac{b}{\sqrt c}\right\rfloor}\times a^{b\bmod \sqrt c}</script><p>其中，$\frac{b}{\sqrt c}&lt;2\sqrt c$，$b\bmod \sqrt c&lt;\sqrt c$</p><p>我们预处理 $(a^{\sqrt c})^i$ 和 $a^j$ 即可 $O(\sqrt c)$ 预处理，$O(1)$ 回答询问。</p><h1 id="三、扩展欧几里得算法"><a href="#三、扩展欧几里得算法" class="headerlink" title="三、扩展欧几里得算法"></a>三、扩展欧几里得算法</h1><p>前置芝士：欧几里得算法。</p><p>本部分着重介绍扩展欧几里得算法、裴蜀定理和乘法逆元相关知识。</p><h2 id="3-1-quad-裴蜀定理"><a href="#3-1-quad-裴蜀定理" class="headerlink" title="3.1$\quad$裴蜀定理"></a>3.1$\quad$裴蜀定理</h2><p><strong>定理4（裴蜀定理）</strong> $\quad$ $\forall a,b\in\mathbb{Z}$，一定存在一组 $x,y\in\mathbb{Z}$，满足</p><script type="math/tex; mode=display">ax+by=\gcd(a,b)</script><p><strong>证</strong>$\qquad$ 在欧几里得算法的最后一步，即 $b=0$ 时，我们一定会得出一组整数 $\begin{cases}x=1\\b=0\end{cases}$，使得 $a\times1+0\times0=\gcd(a,0)$。</p><p>由欧几里得算法得 $\gcd(a,b)=\gcd(b,a\bmod b)$。假设存在一组整数 $x,y$，满足 $bx+(a\bmod b)y=\gcd(b,a\bmod b)$。</p><p>因为 $bx+(a\bmod b)y$</p><p>$\begin{aligned}<br>\;\;&amp;=bx+(a-b\left\lfloor\dfrac{a}{b}\right\rfloor)y \\<br>&amp;=bx+ay-b\left\lfloor\dfrac{a}{b}\right\rfloor y \\<br>&amp;=ay+b(x-b\left\lfloor\dfrac{a}{b}\right\rfloor)<br>\end{aligned}$</p><p>所以，令 $x’=y$，$y’=x-\left\lfloor\dfrac{a}{b}\right\rfloor y$，就得到了 $ax’+by’=\gcd(a,b)$。</p><p>对以上过程应用数学归纳法，可知裴蜀定理一定成立。</p><p><strong>证毕。</strong></p><h2 id="3-2-quad-扩展欧几里得算法"><a href="#3-2-quad-扩展欧几里得算法" class="headerlink" title="3.2$\quad$扩展欧几里得算法"></a>3.2$\quad$扩展欧几里得算法</h2><p>上面证明的过程中，我们通过 $ax+(a\bmod b)y=\gcd(a,b)$ 推出了 $ax’+by’=\gcd(a,b)$。按照欧几里得算法的思路，并给出整数 $x$ 和整数 $y$ 的计算方法成为<strong>扩展欧几里得算法</strong>。</p><p>下面给出扩展欧几里得算法过程：</p><ol><li><p>给定 $a$ 和 $b$，递归 $\operatorname{exgcd}(a,b)$；</p></li><li><p>是否 $b=0$。如果是，返回 $\begin{cases}x=1\\y=0\end{cases}$；如果不是，递归 $\operatorname{exgcd}(b,a\bmod b)$，并重复进行1和2操作，直至条件成立；</p></li><li><p>每次递归结束后，计算 $\begin{cases}x’=y\\y’=x-\left\lfloor\dfrac{a}{b}\right\rfloor y\end{cases}$。</p></li></ol><p>也可以在算法过程中顺便记录 $\gcd(a,b)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll&amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d=<span class="built_in">exgcd</span>(b,a%b,x,y);</span><br><span class="line">    ll temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a,b,x,y;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">ll d=<span class="built_in">exgcd</span>(a,b,x,y);</span><br></pre></td></tr></table></figure><p>上述程序求出方程 $ax+by=\gcd(a,b)$ 的一组特解 $x_0,y_0$，并返回 $\gcd(a,b)$，即 $d$。</p><p>对于方程 $ax+by=c$，当且仅当 $d\mid c$ 时有解。我们可以求出 $ax+by=d$ 的一组特解 $x_0,y_0$，然后令 $x_0,y_0$ 同时乘上 $\dfrac{c}{d}$，就得到了<strong>方程</strong> $ax+b=c$ <strong>的特解</strong></p><script type="math/tex; mode=display">\dfrac{c}{d}x_0\;,\;\dfrac{c}{d}y_0</script><p>对于方程 $ax+by=d$，我们将其特解表示为 $x_0,y_0$，有 $a(x+m)+b(y-n)=ax+by+am-bn=d$。因为 $ax+by=d$，可以推出 $am-bn=0\Rightarrow am=bn\Rightarrow \dfrac{a}{b}=\dfrac{n}{m}$。由于 $\gcd(a,b)=d$，故 $m$ 和 $n$ 最小只能取 $\dfrac{b}{d}$ 和 $\dfrac{a}{d}$，能保证 $m$ 和 $n$ 为整数。所以，<strong>方程</strong> $ax+by=d$ <strong>的通解</strong>为</p><script type="math/tex; mode=display">\begin{cases}x_1=x_0+\dfrac{b}{d}k\\ \\y_1=y_0-\dfrac{a}{d}k\end{cases}(k\in\mathbb{Z})</script><h2 id="3-3-quad-线性同余方程"><a href="#3-3-quad-线性同余方程" class="headerlink" title="3.3$\quad$线性同余方程"></a>3.3$\quad$线性同余方程</h2><p>给定整数 $a,b,m$，求一个整数 $x$ 满足 $ax\equiv b\pmod m$，或者给出无解。</p><p><strong>定义5（线性同余方程）</strong>$\qquad$ 在整数域内，关于 $x$ 的同余方程 $ax\equiv b\pmod m$ 称为<strong>一次同余方程</strong>，也称<strong>线性同余方程</strong>。</p><p>$ax\equiv b\pmod m$ 等价于 $m\mid (ax-b)$，一定存在一个整数 $k$，有 $ax+mk=b$。我们可以利用扩展欧几里得算法对其进行计算。</p><h2 id="3-4-quad-乘法逆元"><a href="#3-4-quad-乘法逆元" class="headerlink" title="3.4$\quad$乘法逆元"></a>3.4$\quad$乘法逆元</h2><p><strong>定义6（乘法逆元）</strong>$\qquad$ 若整数 $b,m$ 互质，并且 $b\mid a$，则存在一个整数 $x$，使得 $\dfrac{a}{b}\equiv ax\pmod m$。称 $x$ 为 $b$ <strong>的模</strong> $m$ <strong>乘法逆元</strong>，记为 $b^{-1}\pmod m$。</p><p>因为 $\dfrac{a}{b}\equiv a\times b^{-1}\equiv\dfrac{a}{b}\times b\times b^{-1}\pmod m$，所以 $b\times b^{-1}\equiv1\pmod m$。</p><p>下面是一些求解乘法逆元的方法。</p><p><strong>方法一：解线性同余方程求解乘法逆元</strong></p><p>如果只保证 $b,m$ 互质，那么乘法逆元可以通过求解同余方程 $bx\equiv1\pmod m$ 得到。算法过程已在上文中提及，不再赘述。</p><p><strong>方法二：快速幂求解乘法逆元</strong></p><p>本方法使用有前提条件。</p><p>如果 $m$ 是质数，并用 $p$ 表示 $m$，并且 $b&lt;p$，根据费马小定理， $b^{p-1}\equiv1\pmod p$，即</p><script type="math/tex; mode=display">b\times b^{p-2}\equiv1\pmod p</script><p>因此，<strong>当模数</strong> $p$ <strong>为质数时，</strong>$b^{p-2}$ <strong>即为</strong> $b$ <strong>的乘法逆元</strong>。</p><p>我们直接对 $b^{p-2}$ 进行快速幂计算即可得到答案。</p><p><strong>方法三：线性求解乘法逆元</strong></p><p>给定 $n,p$，求出 $1,2,\cdots,n$ 在模 $p$ 意义下的乘法逆元。</p><p>显而易见，$1^{-1}\equiv1\pmod p$。</p><p>假设当我们递归到 $i(i&gt;1)$ 时已经把前 $i-1$ 个的乘法逆元算出来了，我们设 $j=p\bmod i$，$k=\left\lfloor\dfrac{p}{i}\right\rfloor$，有 $p=ki+j$，即</p><script type="math/tex; mode=display">ki+j\equiv 0\pmod p</script><p>两边同乘 $i^{-1}j^{-1}$ 得</p><script type="math/tex; mode=display">\begin{aligned}kj^{-1}+i^{-1}&\equiv0\pmod p\\i^{-1}&\equiv kj^{-1}\pmod p\\i^{-1}&\equiv \left\lfloor\dfrac{p}{i}\right\rfloor(p\bmod i)^{-1}\pmod p\end{aligned}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;p);</span><br><span class="line">    inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        inv[i]=(<span class="type">long</span> <span class="type">long</span>)(p - p / i) * inv[p % i] % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,inv[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法四：线性求解任意 $n$ 个数的逆元</strong></p><p>任意给定 $n$ 个数 $a_1,a_2,\cdots,a_n$，求它们在模 $p$ 意义下的乘法逆元，其中，$p$ 为质数。</p><p>我们设</p><script type="math/tex; mode=display">s_i=\prod_{i=1}^ia_i</script><p>通过快速幂或者扩展欧几里得算法求得 $s_i$ 的乘法逆元记为 $sv_i$，即</p><script type="math/tex; mode=display">sv_i=s_i^{-1}\pmod p</script><p>我们将 $sv_1$ 乘上 $a_i$，会与 $a_i^{-1}\pmod p$ 相消，得</p><script type="math/tex; mode=display">a_i\times sv_1=sv_{i-1}</script><p>我们就能递推线性求解乘法逆元。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ll n,p,k,a[MAXN],s[MAXN],t[MAXN];</span><br><span class="line">ll ans=<span class="number">0</span>,temp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(<span class="type">long</span> <span class="type">long</span>)ans*a%mod;</span><br><span class="line">        a=(<span class="type">long</span> <span class="type">long</span>)a*a%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    s[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    t[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]*a[i]%p;</span><br><span class="line">    &#125;</span><br><span class="line">    t[n+<span class="number">1</span>]=<span class="built_in">qpow</span>(s[n],p<span class="number">-2</span>,p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)&#123;</span><br><span class="line">        t[i]=t[i+<span class="number">1</span>]*a[i]%p;</span><br><span class="line">    &#125;</span><br><span class="line">    temp=k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=(ans+(t[i+<span class="number">1</span>]*s[i<span class="number">-1</span>]%p)*temp)%p;</span><br><span class="line">        temp=temp*k%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-quad-威尔逊定理"><a href="#3-5-quad-威尔逊定理" class="headerlink" title="3.5$\quad$威尔逊定理"></a>3.5$\quad$威尔逊定理</h2><p><strong>定理5（威尔逊定理）</strong>$\quad$ 对于任意素数 $p$，有 $(p-1)!\equiv-1\pmod p$。</p><p><strong>证</strong>$\quad$ 我们知道，$x^2\equiv1\pmod p$ 的解只有 $x\equiv\pm1\pmod p$，所以 $2\sim p-2$ 和逆元两两对应。剩下 $1\times (p-1)\equiv -1\pmod p$。</p><p><strong>证毕。</strong></p><h1 id="四、中国剩余定理"><a href="#四、中国剩余定理" class="headerlink" title="四、中国剩余定理"></a>四、中国剩余定理</h1><p>前置芝士：乘法逆元。</p><p>本节主要介绍有关中国剩余定理和扩展中国剩余定理，是解决线性同余方程组问题的重要方法。</p><h2 id="4-1-quad-中国剩余定理"><a href="#4-1-quad-中国剩余定理" class="headerlink" title="4.1$\quad$中国剩余定理"></a>4.1$\quad$中国剩余定理</h2><p><strong>定理6（中国剩余定理，孙子定理）</strong>$\quad$ 设 $m_1,m_2,\cdots,m_n$ 是两两互质的整数，$m=\prod_{i=1}^n{m_i}$，$M_i=m/m_i$，$t_i$ 是线性同余方程 $M_it_i\equiv1\pmod{m_i}$ 的一个解。对于任意的 $n$个整数 $a_1,a_2,\cdots,a_n$，方程组</p><script type="math/tex; mode=display">\begin{cases}x\equiv a_1\pmod{m_1}\\x\equiv a_2\pmod{m_2}\\\cdots\\x\equiv a_n\pmod{m_n}\end{cases}</script><p>有整数解，解为 $x=\sum_{i=1}^na_iM_it_i$。</p><p><strong>证</strong>$\quad$ 因为 $M_i=m/m_i$ 是除 $m_i$ 之外所有模数的倍数，所以 $\forall k\not=i\;,\;a_iM_it_i\equiv0\pmod{m_k}$。又因为 $a_iM_it_i\equiv a_i\pmod{m_i}$，所以代入 $x=\sum_{i=1}^na_iM_it_i$，原方程组成立。</p><p><strong>证毕。</strong></p><p>按照中国剩余定理，我们可以计算线性同余方程组的一个通解（最小解）。另外，我们可以用扩展欧几里得算法求解逆元。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,a[MAXN],m[MAXN];</span><br><span class="line">ll M,ans,summ[MAXN];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">    ll w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) w=w*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    M=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;m[i]&gt;&gt;a[i];</span><br><span class="line">        M*=m[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) summ[i]=M/m[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">exgcd</span>(summ[i],m[i],x,y);</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x+=m[i];</span><br><span class="line">        ans+=a[i]*summ[i]*x;</span><br><span class="line">        ans%=M;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-quad-扩展中国剩余定理"><a href="#4-2-quad-扩展中国剩余定理" class="headerlink" title="4.2$\quad$扩展中国剩余定理"></a>4.2$\quad$扩展中国剩余定理</h2><p>中国剩余定理只能处理模数两两互质的情况，无法处理普遍情况。我们可以使用扩展中国剩余定理进行推算。</p><p>对于每两个线性同余方程组 $x\equiv a_1\pmod {m_1}\;,\;x\equiv a_2\pmod{m_2}$，将其转化为不定方程 $x=pm_1+a_1=qm_2+a_2$，移项有 </p><script type="math/tex; mode=display">pm_1-qm_2=a_2-a_1</script><p>有裴蜀定理得，方程组有整数解当且仅当 $\gcd(m_1,m_2)|(a_2-a_1)$。这时我们就可以用扩展欧几里得算法得到一组可行解 $(p,q)$，则原来的两个方程可以合并为</p><script type="math/tex; mode=display">x\equiv m_1p+a_1\pmod{\text{lcm}(m_1,m_2)}</script><p>我们逐一进行合并即可求解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __int128 ll;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    ll a,m;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; qu;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll&amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d=<span class="built_in">exgcd</span>(b,a%b,x,y);</span><br><span class="line">    ll temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">lcm</span><span class="params">(ll x,ll y,ll d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x/d*y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        qu.<span class="built_in">push</span>(node&#123;b,a&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        node a,b;</span><br><span class="line">        a=qu.<span class="built_in">front</span>();qu.<span class="built_in">pop</span>();</span><br><span class="line">        b=qu.<span class="built_in">front</span>();qu.<span class="built_in">pop</span>();</span><br><span class="line">        ll k1,k2;</span><br><span class="line">        <span class="keyword">if</span>(a.a&gt;b.a) <span class="built_in">swap</span>(a,b);</span><br><span class="line">        ll c=b.a-a.a;</span><br><span class="line">        ll d=<span class="built_in">exgcd</span>(a.m,b.m,k1,k2);</span><br><span class="line">        k1*=c/d;</span><br><span class="line">        k2*=c/d;</span><br><span class="line">        ll q=b.m/d,p=a.m/d;</span><br><span class="line">        <span class="keyword">if</span>(k1&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            ll k=<span class="built_in">ceil</span>((<span class="number">1.0</span>-k1)/q);</span><br><span class="line">            k1+=k*q;</span><br><span class="line">            k2-=k*p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ll k=(k1<span class="number">-1</span>)/q;</span><br><span class="line">            k1-=k*q;</span><br><span class="line">            k2+=k*p;</span><br><span class="line">        &#125;</span><br><span class="line">        node now;</span><br><span class="line">        now.a=k1*a.m+a.a;</span><br><span class="line">        now.m=q*a.m;</span><br><span class="line">        now.a%=now.m;</span><br><span class="line">        qu.<span class="built_in">push</span>(now);</span><br><span class="line">    &#125;</span><br><span class="line">    node ans=qu.<span class="built_in">front</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(<span class="type">long</span> <span class="type">long</span>)(ans.a%ans.m));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、高次同余方程与BSGS算法"><a href="#五、高次同余方程与BSGS算法" class="headerlink" title="五、高次同余方程与BSGS算法"></a>五、高次同余方程与BSGS算法</h1><h2 id="5-1-quad-BSGS算法"><a href="#5-1-quad-BSGS算法" class="headerlink" title="5.1$\quad$BSGS算法"></a>5.1$\quad$BSGS算法</h2><p>给定 $a,b,p$，已知 $a\perp p$，求解 $x$ 满足</p><script type="math/tex; mode=display">a^x\equiv b\pmod p</script><p>令 $x=A\left\lceil\sqrt p\right\rceil-B$，其中， $0\leq A,B\leq \left\lceil\sqrt p\right\rceil$，有 $a^{A\left\lceil\sqrt p\right\rceil-B}\equiv b\pmod p$，整理得</p><script type="math/tex; mode=display">a^{A\left\lceil\sqrt p\right\rceil}\equiv ba^B\pmod p</script><p>我们逐一枚举 $B$ 即可知道所有 $ba^B$。然后建立 <code>hash</code> 表，逐一计算 $a^{A\left\lceil\sqrt p\right\rceil}$，找到与之相等的 $ba^B$ 即可求出 $x=A\left\lceil\sqrt p\right\rceil-B$。</p><p>时间复杂度 $O(\sqrt p)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">BSGS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    map&lt;ll,ll&gt; hash;</span><br><span class="line">    hash.<span class="built_in">clear</span>();</span><br><span class="line">    b%=p;</span><br><span class="line">    ll t=<span class="built_in">sqrt</span>(p)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">        ll val=b*<span class="built_in">qpow</span>(a,i,p)%p;</span><br><span class="line">        hash[val]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    a=<span class="built_in">qpow</span>(a,t,p);</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">return</span> (b==<span class="number">0</span>?<span class="number">1</span>:<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=t;i++)&#123;</span><br><span class="line">        ll val=<span class="built_in">qpow</span>(a,i,p);</span><br><span class="line">        ll j=hash.<span class="built_in">find</span>(val)==hash.<span class="built_in">end</span>()?<span class="number">-1</span>:hash[val];</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span>&amp;&amp;i*t-j&gt;=<span class="number">0</span>) <span class="keyword">return</span> i*t-j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基环树</title>
      <link href="/2022/04/14/%E5%9F%BA%E7%8E%AF%E6%A0%91/"/>
      <url>/2022/04/14/%E5%9F%BA%E7%8E%AF%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>基环树</p><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><p>如果一张无向连通图包含恰好一个环，则称它是一棵<strong>基环树(Pseudotree)</strong>。</p><p>如果一张有向弱连通图每个点的入度都为 ，则称它是一棵 <strong>基环外向树</strong>。</p><p>如果一张有向弱连通图每个点的出度都为 ，则称它是一棵 <strong>基环内向树</strong>。</p><p>多棵树可以组成一个<strong>森林(Forest)</strong> ，多棵基环树可以组成<strong>基环森林(Pseudoforest)</strong> ，多棵基环外向树可以组成<strong>基环外向树森林</strong>，多棵基环内向树可以组成<strong>基环内向森林(Functional graph)</strong> 。</p><h1 id="二、算法实现"><a href="#二、算法实现" class="headerlink" title="二、算法实现"></a>二、算法实现</h1><p>在基环树中，有许多独一无二的性质，这也就成为<del>良心</del>出题人增加题目难度的一种措施。通常会结合<strong>树的直径</strong>进行考察。</p><p>下面就一些例题进行分析</p><p>下面以 <a href="https://www.luogu.com.cn/problem/P4381">[IOI2008] Island</a> 举例。</p><pre><code>题目大意：现有一个基环森林，求出森林中每颗基环树的直径的和。</code></pre><p>基环树直径，就是图中最长链的长度。因为基环树的一些特性，这也成为常考点。<br>显然，基环树的最长链可能有两种情况：</p><ul><li><p>在去掉“环”的某棵子树中。</p></li><li><p>经过“环”，其两端分别在去掉“环”上所有边之后的两颗不同子树中。</p></li></ul><p>我们可以先用一次dfs找出基环树中的“环”，把“环”上的节点做标记，并用数组 <code>ring[]</code> 记录。设环上的节点为 $s_1,s_2,\cdots,s_t$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> last)</span></span>&#123;<span class="comment">//用bool数组进行记录：true表示在环上；false表示不在环上</span></span><br><span class="line">    <span class="keyword">if</span>(temp[x]==<span class="number">1</span>)&#123;<span class="comment">//如果这个点被访问过，说明是环的衔接点，记录，停止深入搜索</span></span><br><span class="line">        temp[x]=<span class="number">2</span>;</span><br><span class="line">        ring[++cnt]=x;</span><br><span class="line">        c[x]=<span class="number">1</span>;<span class="comment">//标记这个点已访问</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp[x]=<span class="number">1</span>;<span class="comment">//标记这个点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="type">int</span> y=to[i];</span><br><span class="line">        <span class="keyword">if</span>(i!=(last^<span class="number">1</span>)&amp;&amp;<span class="built_in">dfs</span>(y,i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[x]!=<span class="number">2</span>)&#123;<span class="comment">//如果这个点不是环的衔接点</span></span><br><span class="line">                c[x]=<span class="number">1</span>;</span><br><span class="line">                ring[++cnt]=x;</span><br><span class="line">                s[cnt]=s[cnt<span class="number">-1</span>]+edge[i];<span class="comment">//前缀和记录（后面会提到）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//如果这个点是环的衔接点</span></span><br><span class="line">                s[start<span class="number">-1</span>]=s[start]-edge[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从每个 $s_i$ 出发，在不经过环上其他节点的前提下，再次执行dfs，即可访问去掉“环”之后以 $s_i$ 为根的子树。在这样的每棵子树中，按照求树的直径的方法进行树形DP并更新答案，即可处理第一种情况。同时，还可以计算出 $d[s_i]$，表示从节点 $s_i$ 出发走向以 $s_i$ 为根的子树，能够到达的最远节点距离。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tree_dp</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//树形DP</span></span><br><span class="line">    c[x]=<span class="number">1</span>;<span class="comment">//标记这个点已访问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="type">int</span> y=to[i];</span><br><span class="line">        <span class="keyword">if</span>(c[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">tree_dp</span>(y);</span><br><span class="line">        treeans=<span class="built_in">max</span>(treeans,d[x]+d[y]+edge[i]);</span><br><span class="line">        d[x]=<span class="built_in">max</span>(d[x],d[y]+edge[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，考虑第二种情况。这相当于找到环上两个不同的节点 $s_i,s_j$，使得 $d[s_i]+d[s_j]+dist(s_i,s_j)$ 最大。其中，$dist(s_i,s_j)$ 表示 $s_i,s_j$ 在环上的距离，有顺时针、逆时针两种走法，取较长的一种。可以将环断开成链再复制一倍，再用单调队列解决。（还可以用前缀和的方法快速求出，下面会提及）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">slove</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    start=cnt+<span class="number">1</span>;<span class="comment">//因为这是一张基环森林，所以要记录入点下标</span></span><br><span class="line">    ll ans_1=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(x,<span class="number">0</span>);<span class="comment">//找环上的点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=cnt;i++)&#123;</span><br><span class="line">        treeans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">tree_dp</span>(ring[i]);<span class="comment">//对每一个树进行树形DP，找到树上直径</span></span><br><span class="line">        ans_1=<span class="built_in">max</span>(ans_1,treeans);<span class="comment">//记录最大直径</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll ans_2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=cnt;i++)&#123;<span class="comment">//复制环</span></span><br><span class="line">        dp[i+cnt-start+<span class="number">1</span>]=dp[i]=d[ring[i]];</span><br><span class="line">        s[i+cnt-start+<span class="number">1</span>]=s[i+cnt-start]+s[i]-s[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=<span class="number">2</span>*cnt-start+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;q.<span class="built_in">front</span>()&lt;=i-cnt+start<span class="number">-1</span>)&#123;<span class="comment">//优先队列，先清除不在区域范围内的点</span></span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">size</span>())&#123;<span class="comment">//如果队列里还有点，进行记录</span></span><br><span class="line">            ans_2=<span class="built_in">max</span>(ans_2,dp[i]+dp[q.<span class="built_in">front</span>()]+s[i]-s[q.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;dp[q.<span class="built_in">back</span>()]-s[q.<span class="built_in">back</span>()]&lt;=dp[i]-s[i])&#123;<span class="comment">//清除比这个点小的点</span></span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);<span class="comment">//插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(ans_1,ans_2);<span class="comment">//取最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要，可以打开<a href="https://www.luogu.com.cn/paste/867bnw9o">完整的代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉回路</title>
      <link href="/2021/06/06/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"/>
      <url>/2021/06/06/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>欧拉回路</p><blockquote><p>  2023.09 updated</p></blockquote><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><p><strong>欧拉路径</strong>：从图中一个结点出发走出一条道路，每条边恰好经过一次的路径。</p><p><strong>欧拉回路</strong>：从图中任意一个顶点出发走出一条道路，每条边恰好经过一次，并最终回到起点。这样的路径称为“欧拉回路”。（类似于一笔画问题）</p><p><strong>欧拉图</strong>：具有欧拉回路的图。</p><p><strong>半欧拉图</strong>：具有欧拉路径但不具有欧拉回路的图</p><h1 id="二、算法实现"><a href="#二、算法实现" class="headerlink" title="二、算法实现"></a>二、算法实现</h1><p>对于求欧拉回路，我们可以分为两种情况解决：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/bv9xrrv9.png" alt=""></p><ul><li><p><strong>无向图</strong>的欧拉回路(图a、b)：对于无向图，只要是一个<strong>连通图</strong>并且每个点的度是<strong>偶数</strong>，那么这个图就能构成欧拉回路。</p></li><li><p><strong>有向图</strong>的欧拉回路(图c、d)：对于有向图，只要是一个<strong>连通图</strong>并且每个点的<strong>入度等于出度</strong>，那么这个图就能构成欧拉回路。</p></li></ul><p>对于求欧拉路径，我们也可以分为两种情况解决：</p><ul><li><p><strong>无向图</strong>的欧拉路径：对于无向图，只有是一个<strong>连通图</strong>，并且<strong>两个点的度为奇数</strong>，剩余为偶数是，那么这个图就能有欧拉路径。</p></li><li><p><strong>有向图</strong>的欧拉路径：对于有向图，只要是一个<strong>连通图</strong>，并且一<strong>个点的入度等于出度加一，一个点的入度等于出度减一</strong>，其余点入度等于出度时，这个图就有欧拉路径。</p></li></ul><p><strong>一个欧拉图一定有欧拉路径。</strong></p><h2 id="2-1-quad-无向图的欧拉路径"><a href="#2-1-quad-无向图的欧拉路径" class="headerlink" title="2.1 $\quad$ 无向图的欧拉路径"></a>2.1 $\quad$ 无向图的欧拉路径</h2><p>我们首先判断存在性：</p><ul><li>连通；</li><li>奇点个数为 $0$ 或 $2$。</li></ul><p>通常使用<strong>并查集</strong>判断连通性，或者走完所有边，判断是否走到了所有的边（这一步在算法流程中进行，否则会破坏时间复杂度）。</p><p>考虑如果存在奇点，则路径只能从奇点走若干边（顺序是随意的，不妨自己证明一下）再次到达另一个奇点。</p><p>我们找到奇点（或者不存在），然后按边进行 dfs，注意，每条边在欧拉路径中存在且仅存在一次，且顺序随意，所以我们必须标记使用过的边，以避免反复遍历所造成的时间复杂度破坏。我们使用栈记录走过的点，输出时从栈顶以此弹出。</p><p>时间复杂度 $O(m)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> &amp;i=head[u];i;i=nxt[i])&#123;<span class="comment">//使用链式前向星存图，注意i变量要取地址，以标记使用过的边，不会再次遍历。</span></span><br><span class="line"><span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> v=to[i];</span><br><span class="line">vis[i]=vis[i^<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">s[++top]=u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-quad-无向图的欧拉回路"><a href="#2-2-quad-无向图的欧拉回路" class="headerlink" title="2.2 $\quad$ 无向图的欧拉回路"></a>2.2 $\quad$ 无向图的欧拉回路</h2><p>和上面类似地，判断存在性：</p><ul><li>连通图；</li><li>均为偶点。</li></ul><p>随意找一个点开始遍历。注意：因为找的是欧拉回路，<strong>不必要访问或判断没有边相连的点的连通性</strong>。所以，严格地说，找一个有边相连的点开始遍历。</p><p>遍历的注意事项和 2.1 大致相同，注意避免重复遍历。唯一不同的是，因为是欧拉回路，会构成一个环，所以，不必要使用栈记录走过的点。当然，这样记录也没有问题。</p><p>时间复杂度 $O(m)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="type">int</span> n,m,tot=<span class="number">1</span>,s[MAXN],top,du[MAXN];</span><br><span class="line"><span class="type">int</span> head[MAXN],nxt[MAXN&lt;&lt;<span class="number">1</span>],to[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">bool</span> vis[MAXN&lt;&lt;<span class="number">1</span>],viss[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> &amp;i=head[u];i;i=nxt[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> v=to[i];</span><br><span class="line">vis[i]=vis[i^<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">s[++top]=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">to[++tot]=y,nxt[tot]=head[x],head[x]=tot;</span><br><span class="line">to[++tot]=x,nxt[tot]=head[y],head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x,y,i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">add</span>(x,y);</span><br><span class="line">du[x]++,du[y]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(du[i])&#123;</span><br><span class="line"><span class="built_in">dfs</span>(i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(top&lt;=m)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(top) cout&lt;&lt;s[top--]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-quad-有向图的欧拉路径"><a href="#2-3-quad-有向图的欧拉路径" class="headerlink" title="2.3 $\quad$ 有向图的欧拉路径"></a>2.3 $\quad$ 有向图的欧拉路径</h2><p>我们首先判断存在性：</p><ul><li>连通；</li><li>如下两个条件满足其一：<ul><li>所有点入度等于出度；</li><li>“有且仅有一个点出度比入度大一”、“与有且仅有一个点出度比入度小一”两个条件同时成立。</li></ul></li></ul><p>如果满足条件1，随意找点开始遍历（同样抛弃孤立点）；如果满足条件2，找到“出度比入度大一”的点开始遍历，最后一定会回到“出度比入度小一”的点。</p><p>按边进行 dfs，详细内容与 2.1类似，可以用邻接表存图。</p><p>时间复杂度 $O(m)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=now[u];i&lt;g[u].<span class="built_in">size</span>();i=now[u])&#123;</span><br><span class="line"><span class="type">int</span> v=g[u][i];</span><br><span class="line">now[u]++;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">s[++top]=u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-quad-有向图的欧拉回路"><a href="#2-4-quad-有向图的欧拉回路" class="headerlink" title="2.4 $\quad$ 有向图的欧拉回路"></a>2.4 $\quad$ 有向图的欧拉回路</h2><p>首先判断存在性：</p><ul><li>连通；</li><li>每个点的入度等于出度。</li></ul><p>随便找一个非孤立点开始遍历，内容同上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="type">int</span> n,m,in[MAXN],out[MAXN],now[MAXN];</span><br><span class="line"><span class="type">int</span> s[MAXN],top;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=now[u];i&lt;g[u].<span class="built_in">size</span>();i=now[u])&#123;</span><br><span class="line"><span class="type">int</span> v=g[u][i];</span><br><span class="line">now[u]++;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">s[++top]=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x,y,i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">in[y]++;</span><br><span class="line">out[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> st=<span class="number">0</span>,numin=<span class="number">0</span>,numout=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(in[i]!=out[i])&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(numin&gt;<span class="number">1</span>||numout&gt;<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(out[i])&#123;</span><br><span class="line">st=i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(st);</span><br><span class="line"><span class="keyword">if</span>(top!=m+<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(top)&#123;</span><br><span class="line">cout&lt;&lt;s[top--]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、样例练习"><a href="#三、样例练习" class="headerlink" title="三、样例练习"></a>三、样例练习</h1><ul><li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1878">hdu 1878 欧拉回路</a>：</li></ul><p>一道模板题。主要知识点是欧拉回路，只需要求出是否含有欧拉回路，不需要求路径。<a href="https://www.luogu.com.cn/paste/pvhqvc2s">模板代码</a></p><ul><li><a href="https://www.luogu.com.cn/problem/UVA10054">UVA10054 The Necklace</a>：</li></ul><p>题解见<a href="https://www.luogu.com.cn/blog/liyunchen/solution-uva10054">我的博客</a></p><ul><li><a href="https://www.luogu.com.cn/problem/UVA10129">UVA10129 单词 Play on Words</a>（<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1116">hdu 1116 Play on Words</a>）：</li></ul><p>题解见<a href="https://www.luogu.com.cn/blog/liyunchen/solution-uva10129">我的博客</a></p><ul><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5883">hdu 5883 The Best Path</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P1341">P1341 无序字母对</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P3520">P3520 [POI2011]SMI-Garbage</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P2731">P2731 [USACO3.3]骑马修栅栏 Riding the Fences</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有向图的连通性</title>
      <link href="/2021/01/02/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7/"/>
      <url>/2021/01/02/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>有向图的连通性</p><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><p><strong>强连通</strong>：在有向图 $G$ 中，如果两点 $u$ , $v$ 是互相可达的，则称 $u$ 和 $v$ 是<strong>强连通</strong>的。如果 $G$ 中的任意两个点都是互相可达的，那么 $G$ 就是<strong>强连通图</strong>。</p><p><strong>强连通分量</strong>：如果一个有向图 $G$ 不是强连通图，那么可以把它分成多个子图，其中每个子图的内部是强连通的，而且这些子图已经扩展到最大，不能与子图外的任一点强连通，像这样的一个“极大强连通”子图是$G$的一个<strong>强连通分量</strong>( $\text{Strongly Connected Component}$，$\text{SCC}$ ).</p><p>$Tarjan$算法能在一次DFS中吧所有点都按 $\text{SCC}$ 分开。这并不是不可思议的，它利用了 $\text{SCC}$ 的特点。</p><p><strong>定理：一个 $\text{SCC}$，从其中任何一个点出发。都至少有一条路径能绕回到自己。</strong></p><h1 id="二、算法实现"><a href="#二、算法实现" class="headerlink" title="二、算法实现"></a>二、算法实现</h1><p>在讲解之前，先了解$low$和$num$操作。</p><p>下面是一个例子，下图有三个 $\text{SCC}$，也就是$\{a,b,d,c\}$、$\{e\}$、$\{f\}$.</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9nl2pcnf.png" alt=""></p><p>图1.a是原图。图1.b是对它做$DFS$，每个点左边的数字标记了$DFS$访问它的顺序，也就是$num[]$值，右边的划线数字是$low[]$值，即能返回到的最远的祖先。每个点的$low[]$初始值等于$num[]$，即连到自己。观察$c$的$low[]$值是如何更新的：它的初始值是$6$，然后有一个回退到$a$，所以更新为$1$；它的递归祖先$d$、$b$的$low[]$值也跟着更新为$1$。$e$和$f$的$low[]$值不能更新。</p><p>图1.b是从$a$开始$DFS$的，$a$成为{$a,b,d,c$}这个$SCC$的祖先.其实，从{$a,b,d,c$}中<strong>任意</strong>一个点开始$DFS$，这个点都会成为这个$SCC$的祖先。认识到这些，可以帮助我们理解后面的解释：可以用栈分离不同的$SCC$。</p><p>图1.b中的$low[]$值有$3$部分，即等于$1$的{$a,b,d,c$}、等于$4$的{$f$}、等于$5$的{$e$}。这就是$3$个$SCC$。</p><p>完成以上步骤，似乎已经就解决了问题。每个点都有了自己的$low[]$值，相同$low[]$值的点属于一个$SCC$。那么只要再对所有点做一个查询，按$low[]$值分开就行了，其复杂度是$O(V)$。</p><p>其实有更好的办法，即在$DFS$的同时把点按$SCC$（有相同的$low[]$值）分开。</p><p>以图2为例，其中有3个$SCC$，即$A$、$E$、$F$。假设从F中的一个点开始$DFS$，$DFS$过程可能会中途跳出$F$，转入$A$或者$E$，总之，最后会进入一个$SCC$。</p><ol><li><p>假设DFS过程是$F$-&gt;$E$-&gt;$A$，最后进入$A$。</p></li><li><p>在$A$这个$SCC$中将完成$A$内所有点的$DFS$过程，也就是说，最后的几步$DFS$会集中在A中的点$a$、$b$、$c$、$d$。这几个点会计算得到相同的$low[]$值，标记为一个$SCC$，这样就好了。</p></li><li><p>$DFS$递归从$A$回到$E$。并在E中完成$E$内部的$DFS$过程。</p></li><li><p>回到$F$，在$F$内完成递归过程。</p></li></ol><p>以上过程如何编程？那你可能想起来，$DFS$搜索是用递归实现的，而递归和栈这种数据结构在本质上是一致的。<strong>所以，可以用栈来帮助处理。</strong></p><ol><li><p>从$F$开始递归搜索，访问到的某些点进入栈；</p></li><li><p>$E$中的某些点进入栈；</p></li><li><p>在$DFS$的最底层，A的所有点将被访问到并进入栈，当前栈顶的几个元素就是$A$的点，标记为同一个$SCC$，并弹出栈；</p></li><li><p>$DFS$回到$E$，在$E$中完成所有点的搜索并且入栈，当前栈顶的元素就是$F$的点，标记为同一个$SCC$，并弹出栈；</p></li><li><p>回到$F$，完成$F$的所有点的搜索并且入栈，当前栈顶的几个元素就是$F$的点，标记为同一个$SCC$，并弹出栈、结束。</p></li></ol><p>为加深对上述过程中栈的理解，我们可以思考最先进入栈的点。每进入一个新的$SCC$，访问并进入栈的第一个点都是这个$SCC$的祖先，它的$num[]$值等于$low[]$值，这个$SCC$中所有点的$low[]$值都等于它。</p><h1 id="三、样例练习"><a href="#三、样例练习" class="headerlink" title="三、样例练习"></a>三、样例练习</h1><ul><li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1269">hdu 1269 迷宫城堡</a>：</li></ul><p>一道模板题。<a href="https://www.luogu.com.cn/paste/6u1aax1d">代码</a></p><ul><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1827">hdu 1827 Summer Holiday</a>: Tarjan 缩点模板题。</p></li><li><p><a href="https://www.luogu.com.cn/problem/P3387">P3387 【模板】缩点</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P2341">P2341 [USACO03FALL][HAOI2006]受欢迎的牛 G</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P2863">P2863 [USACO06JAN]The Cow Prom S</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P2746">P2746 [USACO5.3]校园网Network of Schools</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P1407">P1407 [国家集训队]稳定婚姻</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P2194">P2194 HXY烧情侣</a></p></li><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3072">hdu 3072 Intelligence System</a>: Tarjan+贪心。</p></li><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3836">hdu 3836 Equivalent Sets</a></p></li><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3639">hdu 3639 Hawk-and-Chicken</a>: 强连通分量+缩点。</p></li><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3861">hdu 3861 The King’s Problem</a>： 最小路径覆盖。</p></li><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1530">hdu 1530 Maximum Clique</a>: 最大团简单题目。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2020/09/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2020/09/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>线段树</p><p>线段树，OI中重要的数据结构，用于维护区间信息，也可以辅助维护。线段树的性能比树状数组强（但是码量大），普遍复杂度在 $O(\log n)$ 左右。</p><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><p>线段树是一种二叉树，也就是对于一个线段，我们会用一个二叉树来表示。比如说一个长度为4的线段，我们可以表示成这样：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/dvvdl05x.png" alt=""></p><p>这是什么意思呢？ 如果你要表示线段的和，那么最上面的根节点的权值表示的是这个线段 $1\sim 4$ 的和。根的两个儿子分别表示这个线段中 $1\sim 2$ 的和，与 $3\sim 4$ 的和。以此类推。</p><p>然后我们还可以的到一个性质：节点i的权值=她的左儿子权值+她的右儿子权值。因为 $1\sim 4$ 的和就是等于 $1\sim 2$ 的和加上 $3\sim 4$ 的和。</p><p>根据这个思路，我们就可以建树了，我们设一个结构体 <code>tree</code>，<code>tree[i].l</code> 和 <code>tree[i].r</code> 分别表示这个点代表的线段的左右下标， <code>tree[i].sum</code> 表示这个节点表示的线段和。</p><p>我们知道，一颗二叉树，她的左儿子和右儿子编号分别是 $p\times2$ 和 $p\times2+1$。</p><p>再根据刚才的性质，得到式子：<code>tree[i].sum=tree[i*2].sum+tree[i*2+1].sum</code> 就可以建一颗线段树了！</p><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//递归建树</span></span><br><span class="line">    tree[i].l=l;tree[i].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;<span class="comment">//如果这个节点是叶子节点</span></span><br><span class="line">        tree[i].sum=input[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(i*<span class="number">2</span>,l,mid);<span class="comment">//分别构造左子树和右子树</span></span><br><span class="line">    <span class="built_in">build</span>(i*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    tree[i].sum=tree[i*<span class="number">2</span>].sum+tree[i*<span class="number">2</span>+<span class="number">1</span>].sum;<span class="comment">//刚才我们发现的性质return ;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>嗯，这就是线段树的构建，你可能会问为什么要开好几倍的内存去储存一条线段。这是因为我们还没有让这个过大的数组干一些实事，那么什么是实事呢？让我们进入下一部（在你看懂这一部的情况下）</p><h1 id="二、简单的线段树"><a href="#二、简单的线段树" class="headerlink" title="二、简单的线段树"></a>二、简单的线段树</h1><h2 id="2-1-quad-单点修改，区间查询"><a href="#2-1-quad-单点修改，区间查询" class="headerlink" title="2.1$\quad$单点修改，区间查询"></a>2.1$\quad$单点修改，区间查询</h2><p>其实这一章开始才是真正的线段树，我们要用线段树干什么？答案是维护一个线段（或者区间），比如你想求出一个 $1\sim 100$ 区间中， $4\sim 67$ 这些元素的和，你会怎么做？朴素的做法是 <code>for(i=4;i&lt;=67;i++) sum+=a[i]</code>，这样固然好，但是算得太慢了。</p><p>我们想一种新的方法，先想一个比较好画图的数据，比如一个长度为4的区间，分别是1、2、3、4,我们想求出第 $1\sim 3$ 项的和。按照上一部说的，我们要建出一颗线段树，其中点权（也就是红色）表示和：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/vf6zzggf.png" alt=""></p><p>然后我们要求 $1\sim 3$ 的和，我们先从根节点开始查询，发现她的左儿子 $1\sim 2$ 这个区间和答案区间 $1\sim 3$ 有交集，那么我们跑到左儿子这个区间。</p><p>然后，我们发现这个区间 $1\sim 2$ 被完全包括在答案区间 $1\sim 3$ 这个区间里面，那就把她的值3返回。</p><p>我们回到了 $1\sim 4$ 区间，发现她的右儿子 $3\sim 4$ 区间和答案区间 $1\sim 3$ 有交集，那么我们走到 $3\sim 4$ 区间</p><p>到了 $3\sim 4$ 区间，我们发现她并没有完全包含在答案区间 $1\sim 3$ 里面，但发现她的左儿子 $3\sim 3$ 区间和 $1\sim 3$ 区间又交集，那么久走到 $3\sim 3$ 区间</p><p>到了 $3\sim 3$ 区间，发现其被答案区间完全包含，就返回她的值3一直到最开始</p><p>$3\sim 32$ 区间的 $3+1\sim 2$ 区间的3=6，我们知道了 $1\sim 3$ 区间和为6。</p><p>我们总结一下，线段树的查询方法：</p><ol><li>如果这个区间被完全包括在目标区间里面，直接返回这个区间的值</li><li>如果这个区间的左儿子和目标区间有交集，那么搜索左儿子</li><li>如果这个区间的右儿子和目标区间有交集，那么搜索右儿子</li></ol><p>写成代码，就会变成这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].l&gt;=l &amp;&amp; tree[i].r&lt;=r)<span class="comment">//如果这个区间被完全包括在目标区间里面，直接返回这个区间的值</span></span><br><span class="line">        <span class="keyword">return</span> tree[i].sum;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].r&lt;l || tree[i].l&gt;r)  <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果这个区间和目标区间毫不相干，返回0</span></span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>].r&gt;=l)  s+=<span class="built_in">search</span>(i*<span class="number">2</span>,l,r);<span class="comment">//如果这个区间的左儿子和目标区间又交集，那么搜索左儿子</span></span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>+<span class="number">1</span>].l&lt;=r)  s+=<span class="built_in">search</span>(i*<span class="number">2</span>+<span class="number">1</span>,l,r);<span class="comment">//如果这个区间的右儿子和目标区间又交集，那么搜索右儿子</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>关于那几个if的条件一定要看清楚，最好背下来，以防考场上脑抽推错。</p><p>然后,我们怎么修改这个区间的单点，其实这个相对简单很多，你要把区间的第 <code>dis</code> 位加上 $k$。</p><p>那么你从根节点开始，看这个 <code>dis</code> 是在左儿子还是在右儿子，在哪往哪跑，</p><p>然后返回的时候，还是按照 <code>tree[i].sum=tree[i*2].sum+tree[i*2+1].sum</code> 的原则，更新所有路过的点。</p><p>如果不理解，我还是画个图吧，其中紫色是去的路径，粉色是返回的路径，回来时候红色的+标记就是把这个点加上这个值。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/n4ptxjmh.png" alt=""></p><p>把这个过程变成代码，就是这个样子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> dis,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].l==tree[i].r)&#123;<span class="comment">//如果是叶子节点，那么说明找到了</span></span><br><span class="line">        tree[i].sum+=k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis&lt;=tree[i*<span class="number">2</span>].r)  <span class="built_in">add</span>(i*<span class="number">2</span>,dis,k);<span class="comment">//在哪往哪跑</span></span><br><span class="line">    <span class="keyword">else</span>  <span class="built_in">add</span>(i*<span class="number">2</span>+<span class="number">1</span>,dis,k);</span><br><span class="line">    tree[i].sum=tree[i*<span class="number">2</span>].sum+tree[i*<span class="number">2</span>+<span class="number">1</span>].sum;<span class="comment">//返回更新</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-2-quad-区间修改，单点查询"><a href="#2-2-quad-区间修改，单点查询" class="headerlink" title="2.2$\quad$区间修改，单点查询"></a>2.2$\quad$区间修改，单点查询</h2><p>区间修改和单点查询，我们的思路就变为：如果把这个区间加上 $k$，相当于把这个区间涂上一个 $k$ 的标记，然后单点查询的时候，就从上跑道下，把沿路的标记加起来就好。</p><p>这里面给区间贴标记的方式与上面的区间查找类似，原则还是那三条，只不过第一条：如果这个区间被完全包括在目标区间里面，直接返回这个区间的值变为了如果这个区间如果这个区间被完全包括在目标区间里面，讲这个区间标记 $k$。</p><p>具体做法很像，这里贴上代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].l&gt;=l &amp;&amp; tree[i].r&lt;=r)&#123;<span class="comment">//如果这个区间被完全包括在目标区间里面，讲这个区间标记k</span></span><br><span class="line">        tree[i].sum+=k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>].r&gt;=l)</span><br><span class="line">        <span class="built_in">add</span>(i*<span class="number">2</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>+<span class="number">1</span>].l&lt;=r)</span><br><span class="line">        <span class="built_in">add</span>(i*<span class="number">2</span>+<span class="number">1</span>,l,r,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后就是单点查询了，这个更好理解了，就是 <code>dis</code> 在哪往哪跑，把路径上所有的标价加上就好了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> dis)</span></span>&#123;</span><br><span class="line">    ans+=tree[i].num;<span class="comment">//一路加起来</span></span><br><span class="line">    <span class="keyword">if</span>(tree[i].l==tree[i].r)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(dis&lt;=tree[i*<span class="number">2</span>].r)</span><br><span class="line">        <span class="built_in">search</span>(i*<span class="number">2</span>,dis);</span><br><span class="line">    <span class="keyword">if</span>(dis&gt;=tree[i*<span class="number">2</span>+<span class="number">1</span>].l)</span><br><span class="line">        <span class="built_in">search</span>(i*<span class="number">2</span>+<span class="number">1</span>,dis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不知不觉，这第二章已经结束。这样的简单（原谅我用这个词）线段树，还可除了求和，还可以求区间最小最大值，还可以区间染色。</p><p>但是！这样的线段树展现不出来她的魅力，因为区间求和，树状数组比她少了一个很大的常熟。二区间最值，ST的那神乎其技的$O(n)$查询也能完爆她。这是为什么？因为线段树的魅力还没有展现出来，她最美丽的地方：$\text{pushdown}$ 还未展现于世，如果你已经对这一章充足的了解，并且能不看博客把洛谷上树状数组模板1、2都能写出来，那么请你进入下一部。</p><h1 id="三、进阶线段树"><a href="#三、进阶线段树" class="headerlink" title="三、进阶线段树"></a>三、进阶线段树</h1><p>区间修改、区间查询，你可能会认为，把上一章里面的这两个模块加在一起就好了，然后你就会发现你大错特错。</p><p>因为如果对于1~4这个区间，你把1~3区间+1，相当于把节点1~2和3标记，但是如果你查询2~4时，你会发现你加的时没有标记的2节点和没有标记的3~4节点加上去，结果当然是错的。</p><p>那么我们应该怎么办？这时候 $\text{pushdown}$ 的作用就显现出来了。</p><p>你会想到，我们只需要在查询的时候，如果我们要查的2节点在1~2区间的里面，那我们就可以把1~2区间标记的那个+1给推下去这样就能顺利地加上了。<br>怎么记录这个标记呢？我们需要记录一个“懒标记” $\text{lazytage}$，来记录这个区间</p><p>区间修改的时候，我们按照如下原则：</p><ol><li>如果当前区间被完全覆盖在目标区间里，讲这个区间的 <code>sum+k*(tree[i].r-tree[i].l+1)</code></li><li>如果没有完全覆盖，则先下传懒标记</li><li>如果这个区间的左儿子和目标区间有交集，那么搜索左儿子</li><li><p>如果这个区间的右儿子和目标区间有交集，那么搜索右儿子</p><p>然后查询的时候，将这个懒标记下传就好了，下面图解一下：</p></li></ol><p>如图，区间1~4分别是1、2、3、4，我们要把1~3区间+1。因为1~2区间被完全覆盖，所以将其+2，并将紫色的 $\text{lazytage}+1$，3区间同理<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/xcs9o21v.png" alt=""></p><p>注意我们处理完这些以后，还是要按照 <code>tree[i].sum=tree[i*2].sum+tree[i*2+1].sum</code> 的原则返回，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].r&lt;=r &amp;&amp; tree[i].l&gt;=l)<span class="comment">//如果当前区间被完全覆盖在目标区间里，讲这个区间的sum+k*(tree[i].r-tree[i].l+1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[i].sum+=k*(tree[i].r-tree[i].l+<span class="number">1</span>);</span><br><span class="line">        tree[i].lz+=k;<span class="comment">//记录lazytage</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(i);<span class="comment">//向下传递</span></span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>].r&gt;=l)</span><br><span class="line">        <span class="built_in">add</span>(i*<span class="number">2</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>+<span class="number">1</span>].l&lt;=r)</span><br><span class="line">        <span class="built_in">add</span>(i*<span class="number">2</span>+<span class="number">1</span>,l,r,k);</span><br><span class="line">    tree[i].sum=tree[i*<span class="number">2</span>].sum+tree[i*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中的 $\text{pushdown}$，就是把自己的 $\text{lazytage}$ 归零，并给自己的儿子加上，并让自己的儿子加上 $k\times(r-l+1)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].lz!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[i*<span class="number">2</span>].lz+=tree[i].lz;<span class="comment">//左右儿子分别加上父亲的lz</span></span><br><span class="line">        tree[i*<span class="number">2</span>+<span class="number">1</span>].lz+=tree[i].lz;</span><br><span class="line">        init mid=(tree[i].l+tree[i].r)/<span class="number">2</span>;</span><br><span class="line">        tree[i*<span class="number">2</span>].data+=tree[i].lz*(mid-tree[i*<span class="number">2</span>].l+<span class="number">1</span>);<span class="comment">//左右分别求和加起来</span></span><br><span class="line">        tree[i*<span class="number">2</span>+<span class="number">1</span>].data+=tree[i].lz*(tree[i*<span class="number">2</span>+<span class="number">1</span>].r-mid);</span><br><span class="line">        tree[i].lz=<span class="number">0</span>;<span class="comment">//父亲lz归零</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询的时候，和上一章的几乎一样，就是也要像修改一样加入 $\text{pushdown}$，这里用图模拟一下。我们要查询2~4区间的和，这是查询前的情况，所有紫色的代表 $\text{lazytage}$<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/ky84qvuc.png" alt=""></p><p>然后，我们查到区间1~2时，发现这个区间并没有被完全包括在目标区间里，于是我们就 $\text{pushdown}$，$\text{lazytage}$ 下传，并让每个区间 <code>sum</code> 加上 $(r-l)\text{lazytage}$。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/rbaq35e6.png" alt=""></p><p>然后查到2~2区间，发现被完全包含，所以就返3，再搜索到3~4区间，发现被完全包含，那么直接返回8，最后3+8=11就是答案</p><p>这里是代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].l&gt;=l &amp;&amp; tree[i].r&lt;=r)</span><br><span class="line">        <span class="keyword">return</span> tree[i].sum;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].r&lt;l || tree[i].l&gt;r)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">push_down</span>(i);</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>].r&gt;=l)  s+=<span class="built_in">search</span>(i*<span class="number">2</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>+<span class="number">1</span>].l&lt;=r)  s+=<span class="built_in">search</span>(i*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，到了这里，我们就学会了用线段树进行区间加减操作，大家可以完成洛谷的线段树模板1</p><h1 id="四、乘法（根号）线段树"><a href="#四、乘法（根号）线段树" class="headerlink" title="四、乘法（根号）线段树"></a>四、乘法（根号）线段树</h1><h2 id="4-1-quad-乘法线段树"><a href="#4-1-quad-乘法线段树" class="headerlink" title="4.1$\quad$乘法线段树"></a>4.1$\quad$乘法线段树</h2><p>如果这个线段树只有乘法，那么直接加入 $\text{lazytage}$ 变成乘，然后 <code>tree[i].sum*=k</code> 就好了。但是，如果我们是又加又乘，那就不一样了。</p><p>当 $\text{lazytage}$ 下标传递的时候，我们需要考虑，是先加再乘还是先乘再加。我们只需要对 $\text{lazytage}$ 做这样一个处理。</p><p>$\text{lazytage}$分为两种，分别是加法的 <code>plz</code> 和乘法的 <code>mlz</code>。</p><p>$mlz$很简单处理，$pushdown$时直接$\times$父亲的就可以了，那么加法呢？</p><p>我们需要把原先的 <code>plz</code> 乘上父亲的 <code>mlz</code> 再加上父亲的 <code>plz</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">long</span> <span class="type">long</span> i)</span></span>&#123;<span class="comment">//注意这种级别的数据一定要开long long</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k1=tree[i].mlz,k2=tree[i].plz;</span><br><span class="line">    tree[i&lt;&lt;<span class="number">1</span>].sum=(tree[i&lt;&lt;<span class="number">1</span>].sum*k1+k2*(tree[i&lt;&lt;<span class="number">1</span>].r-tree[i&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>))%p;<span class="comment">//</span></span><br><span class="line">    tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum=(tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum*k1+k2*(tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>))%p;</span><br><span class="line">    tree[i&lt;&lt;<span class="number">1</span>].mlz=(tree[i&lt;&lt;<span class="number">1</span>].mlz*k1)%p;</span><br><span class="line">    tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mlz=(tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mlz*k1)%p;</span><br><span class="line">    tree[i&lt;&lt;<span class="number">1</span>].plz=(tree[i&lt;&lt;<span class="number">1</span>].plz*k1+k2)%p;</span><br><span class="line">    tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].plz=(tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].plz*k1+k2)%p;</span><br><span class="line">    tree[i].plz=<span class="number">0</span>;</span><br><span class="line">    tree[i].mlz=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后加法和减法的函数同理，维护 $\text{lazytage}$ 的时候加法标记一定要记得现乘再加。</p><p>值得一提的是，计算$\times$2时一定要改成 $i&lt;&lt;1$ 这样能解决很多时间。</p><h2 id="4-2-quad-根号线段树"><a href="#4-2-quad-根号线段树" class="headerlink" title="4.2$\quad$根号线段树"></a>4.2$\quad$根号线段树</h2><p>其实，根号线段树和除法线段树一样。她们乍眼一看感觉直接用 <code>lazytage</code> 标记除了多少，但是实际上，会出现精度问题。</p><p>C++的除法是向下取整，很明显，$\dfrac{a+b}{k}!=\dfrac{a}{k}+\dfrac{b}{k}$（在向下取整的情况下），而根号，很明显$\sqrt{a}+\sqrt{b}!=\sqrt{a+b}$ 那么怎么办？</p><p>第一个想法就是暴力，对于每个要改动的区间l~r,把里面的每个点都单独除，但这样就会把时间复杂度卡得比大暴力都慢（因为多个常数），所以怎么优化？</p><p>我们对于每个区间，维护她的最大值和最小值，然后每次修改时，如果这个区间的最大值根号和最小值的根号一样，说明这个区间整体根号不会产生误差，就直接修改（除法同理）</p><p>其中， <code>lazytage</code> 把除法当成减法，记录的是这个区间里每个元素减去的值。</p><p>下面是根号线段树的修改过程：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Sqrt</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].l&gt;=l &amp;&amp; tree[i].r&lt;=r &amp;&amp; (tree[i].minn-(<span class="type">long</span> <span class="type">long</span>)<span class="built_in">sqrt</span>(tree[i].minn))==(tree[i].maxx-(<span class="type">long</span> <span class="type">long</span>)<span class="built_in">sqrt</span>(tree[i].maxx)))&#123;<span class="comment">//如果这个区间的最大值最小值一样</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> u=tree[i].minn-(<span class="type">long</span> <span class="type">long</span>)<span class="built_in">sqrt</span>(tree[i].minn);<span class="comment">//计算区间中每个元素需要减去的</span></span><br><span class="line">        tree[i].lz+=u;</span><br><span class="line">        tree[i].sum-=(tree[i].r-tree[i].l+<span class="number">1</span>)*u;</span><br><span class="line">        tree[i].minn-=u;</span><br><span class="line">        tree[i].maxx-=u;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].r&lt;l || tree[i].l&gt;r)  <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">push_down</span>(i);</span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>].r&gt;=l)  <span class="built_in">Sqrt</span>(i*<span class="number">2</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>+<span class="number">1</span>].l&lt;=r)  <span class="built_in">Sqrt</span>(i*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">    tree[i].sum=tree[i*<span class="number">2</span>].sum+tree[i*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">    tree[i].minn=<span class="built_in">min</span>(tree[i*<span class="number">2</span>].minn,tree[i*<span class="number">2</span>+<span class="number">1</span>].minn);<span class="comment">//维护最大值和最小值</span></span><br><span class="line">    tree[i].maxx=<span class="built_in">max</span>(tree[i*<span class="number">2</span>].maxx,tree[i*<span class="number">2</span>+<span class="number">1</span>].maxx);</span><br><span class="line">    <span class="comment">//cout&lt;&lt;&quot;i&quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;tree[i].sum&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后 <code>pushdown</code> 没什么变化，就是要记得 <code>tree[i].minn$、$tree[i].maxx</code> 也要记得 <code>-lazytage</code>。</p><h1 id="五、样例练习"><a href="#五、样例练习" class="headerlink" title="五、样例练习"></a>五、样例练习</h1><ul><li><p><a href="https://www.luogu.com.cn/problem/P3374">P3374 树状数组模板1</a>：单点修改，区间查询</p></li><li><p><a href="https://www.luogu.com.cn/problem/P3368">P3368 树状数组模板2</a>：区间修改，单点查询</p></li><li><p><a href="https://www.luogu.com.cn/problem/P3372">P3372 线段树模板1</a>区间加法：</p></li><li><p><a href="https://www.luogu.com.cn/problem/P3373">P3373 线段树模板2</a>区间乘法：</p></li><li><p><a href="https://www.luogu.com.cn/problem/P4588">P4588 [TJOI2018]数学计算</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P1502">P1502 窗口的星星</a>：离散化</p></li><li><p><a href="https://www.luogu.com.cn/problem/P2471">P2471 [SCOI2007]降雨量</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P3722">P3722 [AH2017/HNOI2017]影魔</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P4198">P4198 楼房重建</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P4513">P4513 小白逛公园</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P4145">P4145 上帝造题的七分钟 2 / 花神游历各国</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P2023">P2023 [AHOI2009] 维护序列</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
