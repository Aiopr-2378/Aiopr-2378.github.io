<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>有上下界的网络流</title>
      <link href="/post/20e971a77f0b.html"/>
      <url>/post/20e971a77f0b.html</url>
      
        <content type="html"><![CDATA[<p>有上下界的网络流</p><h1 id="一无源汇上下界网络可行流">一、无源汇上下界网络可行流</h1><blockquote><p> <strong>无源汇上下界网络可行流</strong>  给定 <spanclass="math inline">\(n\)</span> 个点，<spanclass="math inline">\(m\)</span> 条边，每条边 <spanclass="math inline">\(e\)</span> 有一个流量下界 <spanclass="math inline">\(l_e\)</span> 和流量上界 <spanclass="math inline">\(r_e\)</span>，求一种可行方案使得在所有点满足流量平衡条件的前提下，所有边满足流量限制。</p></blockquote><p>这是一个判定。不同于一般的网络流，这个模型中没有源点与汇点，而且增加了每条边的流量限制<spanclass="math inline">\([l_e,r_e]\)</span>，而一般的网络流只有最大流量限制，可以视为特殊的上下界网络流（<spanclass="math inline">\(l_e=0\)</span>）。</p><p>首先考虑消除下界流量带来的影响。因为下界流量是必须流到的，不妨先强制流满下界流量。而这也带来了影响——这样操作之后每个点的初始含流量不再为<spanclass="math inline">\(0\)</span>，可以理解成，操作之后，每个节点多余若干流量或缺少若干流量，<strong>这是由于强制流满下界而未保证流量守恒导致的</strong>。</p><p>这样，记 <span class="math inline">\(left_i\)</span> 表示节点 <spanclass="math inline">\(i\)</span> 经过上述操作所剩余（用正表示） /缺少（用负表示）的流量，并建立超级源点 <spanclass="math inline">\(s\)</span> 与超级汇点 <spanclass="math inline">\(t\)</span>：</p><ul><li>若 <spanclass="math inline">\(left_i&gt;0\)</span>，即该节点流满下界时剩余 <spanclass="math inline">\(left_i\)</span> 单位流量，应多补给 <spanclass="math inline">\(left_i\)</span>单位流量才能保证流满边的下界并流量守恒，所以需要<strong>从源点 <spanclass="math inline">\(s\)</span> 向 <spanclass="math inline">\(i\)</span> 连流量为 <spanclass="math inline">\(left_i\)</span> 的边</strong>；</li><li>若 <spanclass="math inline">\(left_i&lt;0\)</span>，即该节点流满下界时缺少 <spanclass="math inline">\(left_i\)</span> 单位流量，应少供给 <spanclass="math inline">\(left_i\)</span>单位流量才能保证流满边的下界并流量守恒，所以需要<strong>从 <spanclass="math inline">\(i\)</span> 向汇点 <spanclass="math inline">\(t\)</span> 连流量为 <spanclass="math inline">\(-left_i\)</span> 的边</strong>。</li></ul><p>上面两个连边方式容易记混淆，务必深刻理解。</p><p>然后正常从超级源点 <span class="math inline">\(s\)</span> 到超级汇点<span class="math inline">\(t\)</span>跑网络流。<strong>网络有可行流当且仅当从超级源点流出的边均流满。</strong></p><p>下面是算法流程：</p><ol type="1"><li>强制流满每条边的下界 <spanclass="math inline">\(l_e\)</span>，并根据流量记录每个点应剩余 /缺少的流量值 <span class="math inline">\(left_i\)</span>。</li><li>建立超级源点 <span class="math inline">\(s\)</span> 与超级汇点 <spanclass="math inline">\(t\)</span>，按上述方式进行连边。</li><li>从 <span class="math inline">\(s\)</span> 到 <spanclass="math inline">\(t\)</span> 进行常规网络流算法。</li><li>检验网络流量是否与超级源点 <span class="math inline">\(s\)</span>的出边流量和相等，相等则有可行流，否则没有。</li></ol><p>模板题 <a href="https://loj.ac/p/115">LOJ #155.无源汇有上下界可行流</a>，参考代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 50005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="type">int</span> n,m,lft[MAXN],s,t,total,ans,idx[MAXN];</span><br><span class="line"><span class="type">int</span> head[MAXN],to[MAXN],nxt[MAXN],edge[MAXN],tot=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> now[MAXN],dep[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,l,r;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    to[++tot]=y,edge[tot]=c,nxt[tot]=head[x],head[x]=tot;</span><br><span class="line">    to[++tot]=x,edge[tot]=<span class="number">0</span>,nxt[tot]=head[y],head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    dep[s]=<span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    now[s]=head[s];</span><br><span class="line">    <span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="type">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(edge[i]&amp;&amp;!dep[v])&#123;</span><br><span class="line">                dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                now[v]=head[v];</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">                <span class="keyword">if</span>(v==t) flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="type">int</span> rest=flow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=now[u];i;i=nxt[i],now[u]=i)&#123;</span><br><span class="line">        <span class="type">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(edge[i]&amp;&amp;dep[v]==dep[u]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> k=<span class="built_in">dinic</span>(v,<span class="built_in">min</span>(edge[i],rest));</span><br><span class="line">            <span class="keyword">if</span>(!k) dep[v]=<span class="number">0</span>;</span><br><span class="line">            edge[i]-=k;</span><br><span class="line">            edge[i^<span class="number">1</span>]+=k;</span><br><span class="line">            rest-=k;</span><br><span class="line">            <span class="keyword">if</span>(!rest) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow-rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    s=n+<span class="number">1</span>,t=n+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i].u&gt;&gt;a[i].v&gt;&gt;a[i].l&gt;&gt;a[i].r;</span><br><span class="line">        lft[a[i].u]-=a[i].l;</span><br><span class="line">        lft[a[i].v]+=a[i].l;</span><br><span class="line">        idx[i]=tot+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">add</span>(a[i].u,a[i].v,a[i].r-a[i].l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lft[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">add</span>(s,i,lft[i]);</span><br><span class="line">            total+=lft[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(i,t,-lft[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flow;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(flow=<span class="built_in">dinic</span>(s,inf)) ans+=flow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==total)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cout&lt;&lt;a[i].r-edge[idx[i]]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二有源汇上下界网络可行流">二、有源汇上下界网络可行流</h1><blockquote><p><strong>有源汇上下界网络可行流</strong>  给定 <spanclass="math inline">\(n\)</span> 个点，<spanclass="math inline">\(m\)</span> 条边，每条边 <spanclass="math inline">\(e\)</span> 有一个流量下界 <spanclass="math inline">\(l_e\)</span> 和流量上界 <spanclass="math inline">\(r_e\)</span>，给定源点 <spanclass="math inline">\(s\)</span> 和汇点 <spanclass="math inline">\(t\)</span>，求一种可行方案使得在所有点满足流量平衡条件的前提下，所有边满足流量限制。</p></blockquote><p>加入一条从汇点 <span class="math inline">\(t\)</span> 连向源点 <spanclass="math inline">\(s\)</span> 的流量上下界为 <spanclass="math inline">\([0,+\infty)\)</span>的边，转化成无源汇上下界网络可行流。之后新建超级源点 <spanclass="math inline">\(S\)</span> 与超级汇点 <spanclass="math inline">\(T\)</span>，按上节方式连边进行网络最大流算法进行判定即可。</p><p>另外，我们还可以根据残量网图中 <spanclass="math inline">\(t\rightarrow s\)</span>的边的剩余流量计算出网络可行流的大小。</p><h1 id="三有源汇上下界网络最大流">三、有源汇上下界网络最大流</h1><blockquote><p><strong>有源汇上下界网络最大流</strong>  给定 <spanclass="math inline">\(n\)</span> 个点，<spanclass="math inline">\(m\)</span> 条边，每条边 <spanclass="math inline">\(e\)</span> 有一个流量下界 <spanclass="math inline">\(l_e\)</span> 和流量上界 <spanclass="math inline">\(r_e\)</span>，给定源点 <spanclass="math inline">\(s\)</span> 和汇点 <spanclass="math inline">\(t\)</span>，求网络中的最大流，使得在所有点满足流量平衡条件的前提下，所有边满足流量限制。</p></blockquote><p>先进行有源汇上下界网络可行流算法，之后得到残量网图与可行流大小。删除额外建立的<span class="math inline">\(t\rightarrow s\)</span>边，重新在<strong>残量网图</strong>上以 <spanclass="math inline">\(s\)</span> 为源点，<spanclass="math inline">\(t\)</span> 为汇点进行最大流算法。</p><p>则网络中的最大流为可行流与残量网图最大流之和。</p><p>模板题 <a href="https://loj.ac/p/116">LOJ #116.有源汇有上下界最大流</a>，参考代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 50005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="type">int</span> n,m,s,t,res[MAXN],ans;</span><br><span class="line"><span class="type">int</span> head[MAXN],nxt[MAXN],to[MAXN],edge[MAXN],tot=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> now[MAXN],d[MAXN];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,l,r;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    to[++tot]=y,edge[tot]=w,nxt[tot]=head[x],head[x]=tot;</span><br><span class="line">    to[++tot]=x,edge[tot]=<span class="number">0</span>,nxt[tot]=head[y],head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">    d[s]=<span class="number">1</span>;</span><br><span class="line">    now[s]=head[s];</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="type">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(edge[i]&amp;&amp;!d[v])&#123;</span><br><span class="line">                d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line">                now[v]=head[v];</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">                <span class="keyword">if</span>(v==t) flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="type">int</span> rest=flow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=now[u];i;i=nxt[i],now[u]=i)&#123;</span><br><span class="line">        <span class="type">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(edge[i]&amp;&amp;d[v]==d[u]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> k=<span class="built_in">dinic</span>(v,<span class="built_in">min</span>(edge[i],rest));</span><br><span class="line">            <span class="keyword">if</span>(!k) d[v]=<span class="number">0</span>;</span><br><span class="line">            edge[i]-=k;</span><br><span class="line">            edge[i^<span class="number">1</span>]+=k;</span><br><span class="line">            rest-=k;</span><br><span class="line">            <span class="keyword">if</span>(!rest) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow-rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s0,t0;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s0&gt;&gt;t0;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;e[i].x&gt;&gt;e[i].y&gt;&gt;e[i].l&gt;&gt;e[i].r;</span><br><span class="line">        res[e[i].x]-=e[i].l;</span><br><span class="line">        res[e[i].y]+=e[i].l;</span><br><span class="line">        <span class="built_in">add</span>(e[i].x,e[i].y,e[i].r-e[i].l);</span><br><span class="line">    &#125;</span><br><span class="line">    s=n+<span class="number">1</span>,t=n+<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(res[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">add</span>(s,i,res[i]);</span><br><span class="line">            num+=res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(i,t,-res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(t0,s0,inf);</span><br><span class="line">    <span class="type">int</span> flow,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(flow=<span class="built_in">dinic</span>(s,inf)) cnt+=flow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt!=num)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;please go home to sleep&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s=s0,t=t0;</span><br><span class="line">    ans=edge[tot];</span><br><span class="line">    edge[tot]=edge[tot<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(flow=<span class="built_in">dinic</span>(s,inf)) ans+=flow;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四有源汇上下界网络最小流">四、有源汇上下界网络最小流</h1><blockquote><p><strong>有源汇上下界网络最小流</strong>  给定 <spanclass="math inline">\(n\)</span> 个点，<spanclass="math inline">\(m\)</span> 条边，每条边 <spanclass="math inline">\(e\)</span> 有一个流量下界 <spanclass="math inline">\(l_e\)</span> 和流量上界 <spanclass="math inline">\(r_e\)</span>，给定源点 <spanclass="math inline">\(s\)</span> 和汇点 <spanclass="math inline">\(t\)</span>，求网络中的最小流，使得在所有点满足流量平衡条件的前提下，所有边满足流量限制。</p></blockquote><p>与一般网络流不同，因为每条边添加了下界限制，所以网络最小流不一定为<span class="math inline">\(0\)</span>，另需算法计算。</p><p>这个算法与上节大致类似，唯一不同在于：在残量网图中，进行源点为 <spanclass="math inline">\(t\)</span>，汇点为 <spanclass="math inline">\(s\)</span>的最大流算法。答案就是可行流大小减去上述计算的最大流大小。</p><p>这个操作实际上是通过反向网络的最大值尽可能大地消去网络可行流，求出最小流。</p><p>模板题 <a href="https://loj.ac/p/117">LOJ #117.有源汇有上下界最小流</a>，参考代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="type">int</span> n,m,s,t,res[MAXN],ans;</span><br><span class="line"><span class="type">int</span> head[MAXN],nxt[MAXN],to[MAXN],edge[MAXN],tot=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> now[MAXN],d[MAXN];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,l,r;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    to[++tot]=y,edge[tot]=w,nxt[tot]=head[x],head[x]=tot;</span><br><span class="line">    to[++tot]=x,edge[tot]=<span class="number">0</span>,nxt[tot]=head[y],head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">    d[s]=<span class="number">1</span>;</span><br><span class="line">    now[s]=head[s];</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="type">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(edge[i]&amp;&amp;!d[v])&#123;</span><br><span class="line">                d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line">                now[v]=head[v];</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">                <span class="keyword">if</span>(v==t) flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="type">int</span> rest=flow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=now[u];i;i=nxt[i],now[u]=i)&#123;</span><br><span class="line">        <span class="type">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(edge[i]&amp;&amp;d[v]==d[u]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> k=<span class="built_in">dinic</span>(v,<span class="built_in">min</span>(edge[i],rest));</span><br><span class="line">            <span class="keyword">if</span>(!k) d[v]=<span class="number">0</span>;</span><br><span class="line">            edge[i]-=k;</span><br><span class="line">            edge[i^<span class="number">1</span>]+=k;</span><br><span class="line">            rest-=k;</span><br><span class="line">            <span class="keyword">if</span>(!rest) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow-rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s0,t0;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s0&gt;&gt;t0;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;e[i].x&gt;&gt;e[i].y&gt;&gt;e[i].l&gt;&gt;e[i].r;</span><br><span class="line">        res[e[i].x]-=e[i].l;</span><br><span class="line">        res[e[i].y]+=e[i].l;</span><br><span class="line">        <span class="built_in">add</span>(e[i].x,e[i].y,e[i].r-e[i].l);</span><br><span class="line">    &#125;</span><br><span class="line">    s=n+<span class="number">1</span>,t=n+<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(res[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">add</span>(s,i,res[i]);</span><br><span class="line">            num+=res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(i,t,-res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(t0,s0,inf);</span><br><span class="line">    <span class="type">int</span> flow,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(flow=<span class="built_in">dinic</span>(s,inf)) cnt+=flow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt!=num)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;please go home to sleep&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s=t0,t=s0;</span><br><span class="line">    ans=edge[tot];</span><br><span class="line">    edge[tot]=edge[tot<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(flow=<span class="built_in">dinic</span>(s,inf)) ans-=flow;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1id="五无源汇上下界网络最小费用可行流">五、无源汇上下界网络最小费用可行流</h1><blockquote><p><strong>无源汇上下界网络最小费用可行流</strong>  给定 <spanclass="math inline">\(n\)</span> 个点，<spanclass="math inline">\(m\)</span> 条边，每条边 <spanclass="math inline">\(e\)</span> 有一个流量下界 <spanclass="math inline">\(l_e\)</span> 、流量上界 <spanclass="math inline">\(r_e\)</span>，和单位流量花费 <spanclass="math inline">\(c_e\)</span>，求一种花费最小的可行方案使得在所有点满足流量平衡条件的前提下，所有边满足流量限制。</p></blockquote><p>与无源汇上下界网络可行流算法类似。唯一不同点在于将最大流算法替换为费用流算法。</p><p>需要注意的是，与超级源点与超级汇点连的边的费用为 <spanclass="math inline">\(0\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式乘法与快速傅里叶变换(FFT)</title>
      <link href="/post/a12cc0ec4a59.html"/>
      <url>/post/a12cc0ec4a59.html</url>
      
        <content type="html"><![CDATA[<p>多项式乘法与快速傅里叶变换(FFT)</p><h1 id="一前置知识">一、前置知识</h1><p>本节介绍多项式前置知识、复数及单位根的相关内容。</p><h2 id="多项式">1.1   多项式</h2><p>设 <span class="math inline">\(A(x)\)</span> 为一个 <spanclass="math inline">\(n\)</span> 次多项式，则可以表示为 <spanclass="math display">\[A(x)=\sum\limits_{i=0}^n a_ix^i\]</span> 其中，<span class="math inline">\(a_i\)</span> 为多项式第<span class="math inline">\(i\)</span> 项的系数。</p><p>一个多项式在 <span class="math inline">\(x_0\)</span> 处的取值 <spanclass="math inline">\(A(x_0)\)</span> 为其在 <spanclass="math inline">\(x_0\)</span> 上的一个<strong>点值</strong>。</p><p>一个 <span class="math inline">\(n\)</span> 次多项式可以用 <spanclass="math inline">\(n+1\)</span> 个点值表示出来。由 <spanclass="math inline">\(n+1\)</span>个对应位置上的点值能<strong>唯一表示一个多项式</strong>。</p><p>形式化地，一个多项式可以由 <span class="math inline">\(n+1\)</span>个点 <span class="math inline">\((x_i,y_i)\)</span>唯一确定，其中，<span class="math inline">\(y_i=\sum\limits_{j=0}^na_jx_i^j\)</span>。</p><h2 id="复数">1.2   复数</h2><p>设 <span class="math inline">\(a,b\in \mathbf R\)</span>，令 <spanclass="math inline">\(i^2=-1\)</span>，称形如 <spanclass="math inline">\(a+bi\)</span>的数为<strong>复数</strong>。其中，称 <spanclass="math inline">\(a\)</span> 为复数的<strong>实部</strong>，<spanclass="math inline">\(b\)</span> 为复数的<strong>虚部</strong>。<spanclass="math inline">\(a=0\)</span> 的数称为<strong>纯虚数</strong>。</p><p>在二维平面中，用横坐标表示实部，用纵坐标表示虚部，这样的平面为<strong>复平面</strong>。在复平面中，对于复数<span class="math inline">\(a+bi\)</span>，令其坐标为 <spanclass="math inline">\((a,b)\)</span>，定义其<strong>模长</strong>为<spanclass="math inline">\(r=\sqrt{a^2+b^2}\)</span>，即该点到坐标原点的距离。称<span class="math inline">\(\theta\)</span> 表示该连线与 <spanclass="math inline">\(x\)</span>轴非负半轴的正夹角为<strong>辐角</strong>，不难发现，一个复数可以用有序数对<span class="math inline">\((\theta,r)\)</span> 唯一表示。</p><p>称圆心在原点，半径为 <span class="math inline">\(1\)</span>的圆为<strong>单位圆</strong>，则单位圆上的复数可以唯一表示为 <spanclass="math inline">\((\cos\theta,\sin\theta)\)</span>，其中 <spanclass="math inline">\(\theta\)</span> 为辐角。</p><p><strong>复数的加法</strong>   对于两个复数 <spanclass="math inline">\(x=a+bi\)</span> 与 <spanclass="math inline">\(y=c+di\)</span>，定义 <spanclass="math inline">\(x+y=(a+c)+(b+d)i\)</span>。</p><p><strong>复数的乘法</strong>   对于两个复数 <spanclass="math inline">\(x=a+bi\)</span> 与 <spanclass="math inline">\(y=c+di\)</span>，定义 <spanclass="math inline">\(xy=(a+bi)(c+di)=(ac-bd)+(bc+ad)i\)</span>。其几何意义为辐角相加，模长相乘。</p><p>在 C++ 中给出了复数的标准库 <code>&lt;complex&gt;</code>，通过声明<code>#include&lt;complex&gt;</code> 引入头文件，通过<code>complex&lt;_type&gt; a;</code> 声明一个实部虚部为<code>_type</code> 类型的复数。该元素分别有两个值，即<code>a=&#123;_real,_imag&#125;</code>。其中，<code>_real</code>值为该复数的<strong>实部</strong>，<code>_imag</code>值为复数的<strong>虚部</strong>。通过调用 <code>a.real()</code> 与<code>a.imag()</code> 分别访问该复数的实部与虚部。</p><h2 id="单位根">1.3   单位根</h2><p>对于是 <span class="math inline">\(2\)</span> 的正整数幂次的整数<span class="math inline">\(n\)</span>，记单位辐角为 <spanclass="math inline">\(\frac{2\pi} n\)</span>，定义 <spanclass="math inline">\(\omega_n^k\)</span> 表示一个模长为 <spanclass="math inline">\(1\)</span>，辐角为 <spanclass="math inline">\(\frac{2k\pi}n\)</span> 的复数，其坐标为 <spanclass="math inline">\((\cos\frac{2k\pi}n,\sin\frac{2k\pi}n)\)</span>​。</p><p>单位根有以下性质：</p><ul><li><spanclass="math inline">\(\omega_{n}^{k}=\cos\frac{2k\pi}n+i\sin\frac{2k\pi}n\)</span>。根据定义可知。</li><li><spanclass="math inline">\(\omega_{n}^{k+n}=\omega_{n}^{k}\)</span>。相当于辐角多转<spanclass="math inline">\(2\pi\)</span>，根据诱导公式可知三角函数值相等。</li><li><spanclass="math inline">\(\omega_{2n}^{2k}=\omega_{n}^{k}\)</span>。根据定义可知。</li><li><span class="math inline">\(\omega_{n}^{k+\fracn2}=-\omega_{n}^{k}\)</span>，相当于辐角多转 <spanclass="math inline">\(\pi\)</span>​，根据诱导公式可知三角函数值为相反数。</li><li><spanclass="math inline">\((\omega_{n}^{k})^m=\omega_{n}^{mk}\)</span>，可以由复数乘法的几何意义推得。</li></ul><h1 id="二快速傅里叶变换fft">二、快速傅里叶变换(FFT)</h1><p><strong>接下来只讨论多项式项数 <span class="math inline">\(n\)</span>为 <span class="math inline">\(2\)</span>的正整数幂次的多项式函数。</strong></p><p>对于 <span class="math inline">\(n\)</span> 项多项式函数 <spanclass="math inline">\(A(x)=\sum\limits_{i=0}^{n-1}a_ix^i\)</span>，定义向量 <spanclass="math inline">\((a_0,a_1,\cdots,a_{n-1})\)</span>为其系数。按照每项次数进行奇偶分类，有 <span class="math display">\[A(x)=(a_0+a_2x^2+a_4x^4+\cdots+a_{n-2}x^{n-2})+x(a_1+a_3x^3+\cdots+a_{n-1}x^{n-1})\]</span> 分别定义 <span class="math display">\[\begin{aligned}A_1(x)&amp;=a_0+a_2x+a_4x^2+\cdots+a_{n-2}x^{\frac n 2 -1} \\A_2(x)&amp;=a_1+a_3x+a_5x^2+\cdots+a_{n-1}x^{\frac n 2 -1}\end{aligned}\]</span> 不难有 <span class="math display">\[A(x)=A_1(x^2)+xA_2(x^2)\]</span> 分别求其在 <span class="math inline">\(\omega_{n}^{k}(0\le k&lt;\frac n2)\)</span> 上的点值，有 <span class="math display">\[\begin{aligned}A(\omega_{n}^{k})&amp;=A_1(\omega_{n}^{2k})+\omega_{n}^{k}A_2(\omega_{n}^{2k})\\&amp;=A_1(\omega_{n/2}^{k})+\omega_{n}^{k}A_2(\omega_{n/2}^{k})\end{aligned}\tag 1\]</span> 与 <span class="math display">\[\begin{aligned}A(\omega_{n}^{k+n/2})&amp;=A_1(\omega_{n}^{2k+n})+\omega_{n}^{k+n/2}A_2(\omega_{n}^{2k+n})\\&amp;=A_1(\omega_{n/2}^{k})-\omega_{n}^{k}A_2(\omega_{n/2}^{k})\end{aligned}\tag 2\]</span> 发现上两式的形式类似，而我们将问题从 <spanclass="math inline">\(n\)</span> 的范围递归地划分到 <spanclass="math inline">\(\frac n 2\)</span> 的范围内。这帮助我们在 <spanclass="math inline">\(O(n\log n)\)</span> 的时间复杂度内求出 <spanclass="math inline">\(n\)</span> 个点的点值，这 <spanclass="math inline">\(n\)</span> 个点为 <spanclass="math inline">\(\omega_{n-1}^{0}\sim\omega_{n-1}^{n-1}\)</span>。</p><p>上述过程称为<strong>快速傅里叶变换</strong>。</p><p>这时候我们已经可以通过递归的办法实现，但由于递归实现常数较大，下面介绍迭代实现的办法。</p><p>因为每一次递归都要奇偶分组，下图展示的原始系数数列下标与分组后的序列下标的关系。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=TZWVkjBu" alt="1101696-20180212074250859-1560811086.png" style="zoom: 80%;" /></p><p>发现后序列的二进制表示是原序列的二进制表示的反串（高低位颠倒）。我们可以按照这个性质对系数数列重新排序后迭代地计算。</p><p>即 <span class="math inline">\(trans_i\)</span> 表示后序列第 <spanclass="math inline">\(i\)</span> 个位置上对应的原序列下标，可以通过<span class="math inline">\(trans_i=trans_{\lfloor n/2\rfloor}\times2+(i\bmod 2)^{n-1}\)</span> 得到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typedef complex&lt;double&gt; cd;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(cd *a)</span></span>&#123; <span class="comment">// a为多项式的系数向量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;i++) <span class="keyword">if</span>(i&lt;trans[i]) <span class="built_in">swap</span>(a[i],a[trans[i]]); <span class="comment">//下标置换</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;lim;k&lt;&lt;=<span class="number">1</span>)&#123; <span class="comment">//枚举段长，合并两个 n&#x27;=k 的区间</span></span><br><span class="line">        cd e=&#123;<span class="built_in">cos</span>(pi/k),<span class="built_in">sin</span>(pi/k)&#125;; <span class="comment">//定义单位根</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;i+=k*<span class="number">2</span>)&#123;</span><br><span class="line">            cd w=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;; <span class="comment">//当前的复数幂</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">                cd x=a[i+j],y=w*a[i+j+k];</span><br><span class="line">                a[i+j]=x+y;</span><br><span class="line">                a[i+j+k]=x-y;</span><br><span class="line">                w*=e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三快速傅里叶逆变换ifft">三、快速傅里叶逆变换(IFFT)</h1><p>对于多项式 <spanclass="math inline">\(A(x)=\sum\limits_{i=0}^{n-1}a_ix^i\)</span>，其中<span class="math inline">\((a_0,a_1,\cdots,a_{n-1})\)</span>为其系数向量。对其进行快速傅里叶变换后得到 <spanclass="math inline">\((y_0,y_1,y_2,\cdots,y_{n-1})\)</span>，称为其 FFT向量。通过 FFT向量反解出系数向量的过程是<strong>快速傅里叶逆变换(IFFT)</strong>。</p><p>考虑多项式 <spanclass="math inline">\(B(x)=\sum\limits_{i=0}^{n-1}y_ix^i\)</span>，即系数为FFT 向量的新多项式。对于其在 <spanclass="math inline">\(\omega_{n}^{-k}\)</span> 处的点值 <spanclass="math display">\[c_k=\sum\limits_{i=0}^{n-1}y_i(\omega_{n}^{-k})^i\]</span> 我们试图找到 <span class="math inline">\(c_k\)</span> 与 <spanclass="math inline">\(a_k\)</span> 之间的关系，则可反解出 <spanclass="math inline">\(a_k\)</span>。对上面式子进行求解： <spanclass="math display">\[\begin{aligned}c_k&amp;=\sum_{i=0}^{n-1}y_i\left(\omega_{n}^{-k} \right)^i \\&amp;=\sum_{i=0}^{n-1}\left(\sum_{j=0}^{n-1}a_j(\omega_{n}^{i})^j\right)\left(\omega_{n}^{-k} \right)^i \\&amp;=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_j\left(\omega_{n}^{j}\right)^i\left(\omega_{n}^{-k} \right)^i \\&amp;=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_j\left(\omega_{n}^{j-k}\right)^i \\&amp;=\sum_{j=0}^{n-1}a_j\left(\sum_{i=0}^{n-1}\left(\omega_{n}^{j-k}\right)^i \right)\end{aligned}\tag 3\]</span> 令 <spanclass="math inline">\(S(x)=\sum\limits_{i=0}^{n-1}x^i\)</span>，有 <spanclass="math display">\[\begin{aligned}S(\omega_{n}^{k})&amp;=1+\omega_{n}^{k}+(\omega_{n}^{k})^2+\cdots+(\omega_{n}^{k})^{n-1}\\\omega_{n}^{k}S(\omega_{n}^{k})&amp;=\omega_{n}^{k}+(\omega_{n}^{k})^2+(\omega_{n}^{k})^2+\cdots+(\omega_{n}^{k})^n\end{aligned}\]</span> 两式相减得到 <span class="math display">\[S(\omega_{n}^{k})=\dfrac{(\omega_{n}^{k})^n-1}{\omega_{n}^{k}-1}=\dfrac{1-1}{\omega_{n}^{k}-1}\]</span> 当 <spanclass="math inline">\(\omega_{n}^{k}\not=1\)</span>，即 <spanclass="math inline">\(k\not=0\)</span> 时，<spanclass="math inline">\(S(\omega_{n}^{k})=0\)</span>；</p><p>当 <span class="math inline">\(\omega_{n}^{k}=1\)</span>，即 <spanclass="math inline">\(k=0\)</span> 时，根据定义有 <spanclass="math inline">\(S(\omega_{n}^{k})=n\)</span>。</p><p>对于 <span class="math inline">\((3)\)</span> 式，用 <spanclass="math inline">\(S(\omega_{n}^{j-k})\)</span> 表示 <spanclass="math inline">\(\sum\limits_{i=0}^{n-1}(\omega_{n}^{j-k})^i\)</span>，因为其在<span class="math inline">\(\omega_{n}^{0}\)</span> 处才有值，所以 <spanclass="math display">\[\begin{aligned}c_k&amp;=\sum_{j=0}^{n-1}a_jS(\omega_{n}^{j-k}) \\&amp;=na_k\end{aligned}\]</span> 即 <span class="math display">\[a_k=\dfrac {c_k} n\tag 4\]</span> 这样，我们再次利用 FFT 求出多项式 <spanclass="math inline">\(B(x)\)</span> 在 <spanclass="math inline">\(\omega_{n}^{-k}\)</span> 上的点值 <spanclass="math inline">\(c_k\)</span>，可以反解出 <spanclass="math inline">\(a_k\)</span>，时间复杂度 <spanclass="math inline">\(O(n\log n)\)</span>。</p><p>不难发现 IFFT 与 FFT 有许多相同之处，并且需要利用 FFT 求出点值 <spanclass="math inline">\(c_k\)</span>，于是求解 IFFT 的时候直接更改 <spanclass="math inline">\(\omega_{n}^{k}\)</span> 为 <spanclass="math inline">\(\omega_{n}^{-k}\)</span> 即可利用 FFT 求解出 <spanclass="math inline">\(c_k\)</span>，再除以 <spanclass="math inline">\(n\)</span> 得到 <spanclass="math inline">\(a_k\)</span>。</p><h1 id="四多项式乘法">四、多项式乘法</h1><p>对于两个多项式 <span class="math inline">\(A(x)=\sum\limits_{i=0}^na_ix^i\)</span> 和 <span class="math inline">\(B(x)=\sum\limits_{i=0}^mb_ix^i\)</span>，定义<strong>多项式乘法</strong> <spanclass="math inline">\(C(x)=A(x)\times B(x)\)</span> 为 <spanclass="math display">\[c_{i}=\sum_{j=0}^{i}a_jb_{i-j}\]</span> 其中 <span class="math inline">\(c_i\)</span> 为多项式 <spanclass="math inline">\(C(x)\)</span> 的第 <spanclass="math inline">\(i\)</span> 项系数。所得的多项式 <spanclass="math inline">\(C(x)\)</span> 是一个 <spanclass="math inline">\(n+m\)</span> 次多项式，共有 <spanclass="math inline">\(n+m+1\)</span> 项。</p><p>朴素的多项式乘法时间复杂度为 <spanclass="math inline">\(O(n^2)\)</span> 级别，利用 FFT 可以在 <spanclass="math inline">\(O(n\log n)\)</span>的复杂度内求解，大致思路如下图所示。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=QFtPBYKS" /></p><p>算法流程如下：</p><ol type="1"><li>分别对 <span class="math inline">\(A(x),B(x)\)</span> 多项式求出其在<span class="math inline">\(\omega_{n}^{k}\)</span> 处的点值，利用 FFT做到时间复杂度 <span class="math inline">\(O(n\log n)\)</span>；</li><li>每个位置上的点值对应相乘，所得点值就是多项式 <spanclass="math inline">\(C(x)\)</span> 在对应位置上的点值；</li><li>根据点值利用 IFFT 反解出 <spanclass="math inline">\(c_k\)</span>，时间复杂度 <spanclass="math inline">\(O(n\log n)\)</span>。</li></ol><p>关键点在于将系数表示转换为点值表示，这样在对应位置上的点值只与当前位置有关，做到了位置分离，进而便于求解。</p><p>需要注意的是，在求解 FFT 与 IFFT 中，多项式项数 <spanclass="math inline">\(n\)</span> 需要是 <spanclass="math inline">\(2\)</span>的<strong>正整数次幂</strong>，这要求我们在计算的时候需要将下标上届扩展到大于<span class="math inline">\(n+m\)</span> 的 <spanclass="math inline">\(2\)</span> 的幂次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Luogu P3803 【模板】多项式乘法（FFT）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 4000005</span></span><br><span class="line"><span class="keyword">typedef</span> complex&lt;<span class="type">double</span>&gt; cd;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.</span>);</span><br><span class="line"><span class="type">int</span> n,m,lim,trans[MAXN];</span><br><span class="line">cd a[MAXN],b[MAXN],c[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(cd *a,<span class="type">int</span> op)</span></span>&#123; <span class="comment">//通过添加系数 op 将 FFT 与 IFFT 的前半部分合二为一</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;i++) <span class="keyword">if</span>(i&lt;trans[i]) <span class="built_in">swap</span>(a[i],a[trans[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;lim;k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        cd e=&#123;<span class="built_in">cos</span>(pi/k),<span class="built_in">sin</span>(pi/k)*op&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;i+=k*<span class="number">2</span>)&#123;</span><br><span class="line">            cd w=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">                cd x=a[i+j],y=w*a[i+j+k];</span><br><span class="line">                a[i+j]=x+y;</span><br><span class="line">                a[i+j+k]=x-y;</span><br><span class="line">                w*=e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> w=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;</span><br><span class="line">        w=w*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) cin&gt;&gt;b[i];</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    lim=<span class="number">1</span>;<span class="keyword">while</span>(lim&lt;=n+m) lim&lt;&lt;=<span class="number">1</span>,len++; <span class="comment">//扩展 lim 到 2 的幂次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;i++) trans[i]=((trans[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(len<span class="number">-1</span>)));</span><br><span class="line">    <span class="built_in">FFT</span>(a,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(b,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;i++) c[i]=a[i]*b[i];</span><br><span class="line">    <span class="built_in">FFT</span>(c,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;i++) c[i]/=lim; <span class="comment">// IFFT 的最后一步</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n+m;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="built_in">int</span>(c[i].<span class="built_in">real</span>()+<span class="number">0.5</span>)); <span class="comment">// 避免精度误差</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三角恒等变换</title>
      <link href="/post/b58f72002ca0.html"/>
      <url>/post/b58f72002ca0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>微积分学习笔记 - 05 三角恒等变换</p><p>进入 <ahref="/categories/微积分学习笔记/">传送门</a>，阅读刊载在专栏《微积分学习笔记》下的全部文章。</p></blockquote><h1 id="九三角恒等变换">九、三角恒等变换</h1><p>本节作为数学基础，为后面章节做铺垫且<strong>与微积分暂时无关</strong>。三角公式只涉及三个三角函数<span class="math inline">\(\sin,\cos,\tan\)</span>，剩余三个三角函数<span class="math inline">\(\cot,\sec,\csc\)</span>的公式可自行扩展，因不常用而略去。</p><p>本节公式大多为高一内容，稍作补充完善。基本公式不作证明，拓展内容部分有公式证明。</p><h2 id="和角公式">9.1   和角公式</h2><p>下面给出三角函数的和角公式。</p><p><strong>和角公式</strong>   给定两角 <spanclass="math inline">\(A,B\)</span>，则有： <span class="math display">\[\begin{aligned}\sin(A+B)&amp;=\sin(A)\cos(B)+\cos(A)\sin(B)\\\cos(A+B)&amp;=\cos(A)\cos(B)-\sin(A)\sin(B)\\\tan(A+B)&amp;=\dfrac{\tan(A)+\tan(B)}{1-\tan(A)\tan(B)}\end{aligned}\]</span></p><h2 id="差角公式">9.2   差角公式</h2><p>下面给出三角函数的差角公式。</p><p><strong>差角公式</strong>   给定两角 <spanclass="math inline">\(A,B\)</span>，则有： <span class="math display">\[\begin{aligned}\sin(A-B)&amp;=\sin(A)\cos(B)-\cos(A)\sin(B)\\\cos(A-B)&amp;=\cos(A)\cos(B)+\sin(A)\sin(B)\\\tan(A-B)&amp;=\dfrac{\tan(A)-\tan(B)}{1+\tan(A)\tan(B)}\end{aligned}\]</span></p><h2 id="倍角公式">9.3   倍角公式</h2><p>下面给出三角函数的倍角公式。</p><p><strong>倍角公式</strong>   给定角 <spanclass="math inline">\(A\)</span>，则有： <span class="math display">\[\begin{aligned}\sin(2A)&amp;=2\sin(A)\cos(A) \\\cos(2A)&amp;=\cos^2(A)-\sin^2(A)=2\cos^2(A)-1=1-2\sin^2(A) \\\tan(2A)&amp;=\dfrac{2\tan(A)}{1-\tan^2(A)}\end{aligned}\]</span> 上述公式可直接由和角公式推得。</p><h2 id="降幂公式">9.4   降幂公式</h2><p>下面给出三角函数的降幂公式。</p><p><strong>降幂公式</strong>   给定角 <spanclass="math inline">\(A\)</span>，则有： <span class="math display">\[\begin{aligned}    \sin(A)\cos(A)&amp;=\dfrac12\sin(2A)\\    \sin^2(A)&amp;=\dfrac{1-\cos(2A)}{2} \\    \cos^2(A)&amp;=\dfrac{1+\cos(2A)}{2}\end{aligned}\]</span> 降幂公式由正弦函数和余弦函数的倍角公式推得。</p><h2 id="辅助角公式">9.5   辅助角公式</h2><p>下面给出三角函数的辅助角公式。</p><p><strong>辅助角公式</strong>   给定角 <spanclass="math inline">\(\alpha\)</span>，实数 <spanclass="math inline">\(a,b\)</span> 为常数，则有： <spanclass="math display">\[a\sin\alpha+b\cos\alpha=\sqrt{a^2+b^2}\sin(\alpha+\varphi)\]</span> 其中，<span class="math inline">\(\tan\varphi=\dfrac ba\)</span>。</p><blockquote><p><strong>证明</strong>   将原式进行如下变形： <spanclass="math display">\[  \begin{aligned}  a\sin\alpha+b\cos\alpha&amp;=\sqrt{a^2+b^2}(\sin\alpha\cdot\dfrac{a}{\sqrt{a^2+b^2}}+\cos\alpha\cdot\dfrac{b}{\sqrt{a^2+b^2}})\\  &amp;=\sqrt{a^2+b^2}(\sin \alpha \cdot \cos \varphi+\cos\alpha\cdot\sin\varphi) \\  &amp;=\sqrt{a^2+b^2}\sin(\alpha+\varphi)  \end{aligned}  \]</span> 其中 <span class="math inline">\(\varphi\)</span> 满足 <spanclass="math inline">\(\tan\varphi=\dfrac ba,\varphi\in[-\pi,\pi)\)</span>。</p><p><strong>证毕。</strong></p></blockquote><h2 id="万能公式">9.6   万能公式</h2><p>下面给出三角函数万能公式，<del>很遗憾没有找到更加文雅一点的名字</del>。</p><p><strong>万能公式</strong>   给定角 <spanclass="math inline">\(\alpha\)</span>，记 <spanclass="math inline">\(t=\tan \dfrac{\alpha}2\)</span>，则有： <spanclass="math display">\[\begin{aligned}\sin\alpha &amp;=\dfrac{2t}{1+t^2}\\\cos\alpha &amp;=\dfrac{1-t^2}{1+t^2}\\\tan\alpha &amp;=\dfrac{2t}{1-t^2}\end{aligned}\]</span></p><blockquote><p><strong>证明</strong>   令 <span class="math inline">\(t=\tan \dfrac\alpha 2\)</span>，则根据二倍角公式有 <span class="math display">\[  \tan \alpha = \dfrac{2\tan \dfrac \alpha 2}{1-\tan ^2 \dfrac \alpha2}=\dfrac {2t}{1-t^2}  \]</span> 根据三角函数几何意义，令一点坐标为 <spanclass="math inline">\((1-t^2,2t)\)</span>，则该点到原点的距离 <spanclass="math inline">\(r=1+t^2\)</span>，显然有 <spanclass="math display">\[  \sin \alpha =\dfrac{2t}{1+t^2}\quad ,\quad \cos \alpha=\dfrac{1-t^2}{1+t^2}  \]</span> <strong>证毕</strong>。</p></blockquote><h2 id="和差化积公式">9.7   和差化积公式</h2><p>下面给出三角函数的和差化积公式。</p><p><strong>和差化积公式</strong>   给定角 <spanclass="math inline">\(\alpha\)</span> 与 <spanclass="math inline">\(\beta\)</span>，则有： <spanclass="math display">\[\begin{aligned}\sin\alpha +\sin\beta&amp;=2\sin\dfrac{\alpha +\beta} 2\cos\dfrac{\alpha -\beta} 2 \\\sin\alpha -\sin\beta&amp;=2\cos\dfrac{\alpha +\beta} 2\sin\dfrac{\alpha -\beta} 2 \\\cos\alpha +\cos\beta&amp;=2\cos\dfrac{\alpha +\beta} 2\cos\dfrac{\alpha -\beta} 2 \\\cos\alpha -\cos\beta&amp;=-2\sin\dfrac{\alpha+\beta} 2\sin\dfrac{\alpha -\beta} 2\end{aligned}\]</span> 上面四个公式可以由倍角公式推得，证明不再赘述。</p><h2 id="积化和差公式">9.8   积化和差公式</h2><p>下面给出三角函数的积化和差公式。</p><p><strong>积化和差公式</strong>   给定角 <spanclass="math inline">\(\alpha\)</span> 与 <spanclass="math inline">\(\beta\)</span>，则有： <spanclass="math display">\[\begin{aligned}\sin\alpha\cos\beta&amp;=\dfrac 12[\sin(\alpha+\beta)+\sin(\alpha-\beta)] \\\cos\alpha\sin\beta&amp;=\dfrac 12[\sin(\alpha+\beta)-\sin(\alpha-\beta)] \\\cos\alpha\cos\beta&amp;=\dfrac 12[\cos(\alpha+\beta)+\cos(\alpha-\beta)] \\\sin\alpha\cos\beta&amp;=-\dfrac 12[\cos(\alpha+\beta)-\cos(\alpha-\beta)] \\\end{aligned}\]</span> 上面四个公式可以由和角公式与差角公式推得，证明不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> 微积分学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二项式反演</title>
      <link href="/post/169f0aee837e.html"/>
      <url>/post/169f0aee837e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>组合数学学习笔记 02 二项式反演</p><p>进入<ahref="/categories/组合数学学习笔记/">分类索引</a>，阅读该专题下的往期笔记。</p></blockquote><h1 id="二二项式反演">二、二项式反演</h1><h2 id="基本形式">2.1   基本形式</h2><p>对于定义在域 <span class="math inline">\(X\)</span> 上的实值函数<span class="math inline">\(F(n)\)</span> 与 <spanclass="math inline">\(G(n)\)</span>，若由如下递推关系 <spanclass="math display">\[G(n)=\sum\limits_{i=0}^n\binom n i F(i) \tag{1}\]</span> 得到 <span class="math inline">\(G(n)\)</span> 关于 <spanclass="math inline">\(F(i)\)</span>的表达式，则可以通过如下的递推关系通过 <spanclass="math inline">\(G(i)\)</span> 反解 <spanclass="math inline">\(F(n)\)</span>： <span class="math display">\[\boxed{F(n)=\sum\limits_{i=0}^n\binom n i (-1)^{n-i} G(i) \tag{2}}\]</span> 上述通过 <span class="math inline">\(G\)</span> 反解 <spanclass="math inline">\(F\)</span>的过程称为<strong>二项式反演</strong>。</p><p>要证明二项式反演，下面引入两个二项式系数引理。</p><p><strong>引理 1</strong>   <span class="math inline">\(\dbinom ni\dbinom i k=\dbinom n k \dbinom {n-k} {i-k}\)</span>。</p><blockquote><p><strong>证明</strong>   考虑组合意义：在 <spanclass="math inline">\(n\)</span> 个元素中先取出 <spanclass="math inline">\(i\)</span> 个元素，再在 <spanclass="math inline">\(i\)</span> 个元素中取出 <spanclass="math inline">\(k\)</span> 个元素的方案数，显然等价于，在 <spanclass="math inline">\(n\)</span> 个元素中直接取出 <spanclass="math inline">\(k\)</span> 个元素，而后在剩下 <spanclass="math inline">\(n-k\)</span> 个元素中再选出来 <spanclass="math inline">\(i-k\)</span> 个元素的方案数。</p></blockquote><p><strong>引理 2</strong>   <spanclass="math inline">\(\sum\limits_{i=0}^n(-1)^{i}\dbinom nk=[n=0]\)</span>。</p><blockquote><p><strong>证明</strong>   考虑二项式定理在 <spanclass="math inline">\(x=1,y=-1\)</span>​ 时的特殊情况，有 <spanclass="math inline">\(\sum\limits_{i=0}^n\dbinom n i(-1)^i1^{n-i}=0^n=[n=0]\)</span>。</p></blockquote><p>下面给出二项式反演的证明。</p><p><strong>证明</strong>   将 <span class="math inline">\((1)\)</span>式直接代入 <span class="math inline">\((2)\)</span>式，应用引理 1，有<span class="math display">\[\begin{aligned}F(n)&amp;=\sum\limits_{i=0}^n\binom n i(-1)^{n-i}\sum\limits_{j=0}^i\binom i j F(j) \\&amp;=\sum\limits_{i=0}^n\sum\limits_{j=0}^i\binom n i \binom i j(-1)^{n-i}F(j)\\&amp;=\sum\limits_{i=0}^n\sum\limits_{j=0}^i\binom n j \binom {n-j}{i-j} (-1)^{n-i}F(j)\\&amp;=\sum\limits_{j=0}^n\binom n j F(j)\sum_{i=j}^n(-1)^{n-i}\binom{n-j} {i-j}\end{aligned}\]</span> 令 <span class="math inline">\(t=i-j\)</span>，则 <spanclass="math inline">\(i=t+j\)</span>，应用引理 2，继续推上面的式子，有<span class="math display">\[\begin{aligned}F(n)&amp;=\sum\limits_{j=0}^n\binom n j F(j)\sum_{i=j}^n(-1)^{n-i}\binom{n-j} {i-j} \\&amp;=\sum\limits_{j=0}^n\binom n jF(j)\sum\limits_{t=0}^{n-j}(-1)^{n-t-j}\binom {n-j}{t} \\&amp;=\sum\limits_{j=0}^n\binom n j F(j)[n-j=0] \\&amp;=\binom n n F(n) \\&amp;=F(n)\end{aligned}\]</span> <strong>证毕</strong>。</p><h2 id="第二种形式">2.2   第二种形式</h2><p>还是对于定义在域 <span class="math inline">\(X\)</span> 上的实值函数<span class="math inline">\(F(n)\)</span> 与 <spanclass="math inline">\(G(n)\)</span>，若由如下递推关系 <spanclass="math display">\[G(n)=\sum\limits_{i=n}^m\binom i n F(i) \tag{3}\]</span> 则可以通过下面的递推关系利用 <spanclass="math inline">\(G(i)\)</span> 反解 <spanclass="math inline">\(F(n)\)</span>： <span class="math display">\[\boxed{F(n)=\sum\limits_{i=n}^m\binom i n (-1)^{i-n}G(i) \tag{4}}\]</span> 下面给出这种形式的证明。</p><p><strong>证明</strong>   将 <span class="math inline">\((3)\)</span>式直接代入 <span class="math inline">\((4)\)</span>式，再次利用上述引理，有 <span class="math display">\[\begin{aligned}F(n)&amp;=\sum\limits_{i=n}^m\binom i n(-1)^{i-n}\sum\limits_{j=i}^m\binom j iF(j) \\&amp;=\sum\limits_{i=n}^m\sum\limits_{j=i}^m\binom j i \binom i n(-1)^{i-n}F(j) \\&amp;=\sum\limits_{i=n}^m\sum\limits_{j=i}^m\binom j n \binom {j-n}{i-n} (-1)^{i-n}F(j) \\&amp;=\sum\limits_{j=n}^m\binom j n F(j)\sum\limits_{i=n}^j\binom{j-n}{i-n}(-1)^{i-n}\end{aligned}\]</span> 令 <span class="math inline">\(t=i-n\)</span>，则 <spanclass="math inline">\(i=t+n\)</span>，继续推上面的式子，有 <spanclass="math display">\[\begin{aligned}F(n)&amp;=\sum\limits_{j=n}^m\binom j n F(j)\sum\limits_{i=n}^j\binom{j-n}{i-n}(-1)^{i-n} \\&amp;=\sum\limits_{j=n}^m\binom j n F(j)\sum\limits_{t=0}^{j-n}(-1)^{t}\binom {j-n}{t} \\&amp;=\sum\limits_{j=n}^m\binom j n F(j) [j-n=0] \\&amp;=\binom n n F(n) \\&amp;=F(n)\end{aligned}\]</span> <strong>证毕</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 组合数学学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二项式定理与二项式系数</title>
      <link href="/post/25bc084a1f5a.html"/>
      <url>/post/25bc084a1f5a.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>组合数学学习笔记 01 二项式定理与二项式系数</p><p>进入<ahref="/categories/组合数学学习笔记/">分类索引</a>，阅读该专题下的往期笔记。</p></blockquote><p>本章节介绍二项式定理与相关推论定理，在组合数学中有重要作用。</p><h1 id="一二项式定理与二项式系数">一、二项式定理与二项式系数</h1><h2 id="二项式定理">1.1   二项式定理</h2><p><strong>定理 1（二项式定理）</strong>   设 <spanclass="math inline">\(n\)</span> 是正整数。对所有的 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span>，有 <span class="math display">\[(x+y)^n=\sum\limits_{k=0}^n\binom nk x^{n-k}y^k\tag 1\]</span></p><blockquote><p><strong>证明</strong>   考虑把 <spanclass="math inline">\((x+y)^n\)</span> 展开，结果有 <spanclass="math inline">\(2^n\)</span> 项，每一项都可以写成 <spanclass="math inline">\(x^{n-k}y^k\)</span> 的形式。对于每个形式，相当于在<span class="math inline">\(n\)</span> 个因子中选择 <spanclass="math inline">\(k\)</span> 个选择 <spanclass="math inline">\(x\)</span>，故其系数为 <spanclass="math inline">\(\binom n k\)</span>​。</p></blockquote><h2 id="组合相关推论">1.2   组合相关推论</h2><p>如果对于二项式定理，取 <spanclass="math inline">\(y=1\)</span>，则有如下特殊形式。</p><p><strong>定理 2</strong>   设 <span class="math inline">\(n\)</span>为正整数。对于所有的 <span class="math inline">\(x\)</span>，有 <spanclass="math display">\[(1+x)^n=\sum\limits_{k=0}^n \binom n k x^k\tag{2}\]</span> 证明略去。</p><p><strong>定理 3</strong>   对于正整数 <spanclass="math inline">\(n,k\)</span>，有 <span class="math display">\[k\binom n k =n\binom {n-1}{k-1}\tag{3}\]</span></p><blockquote><p><strong>证明</strong>   如果 <spanclass="math inline">\(k&gt;n\)</span>，则 <spanclass="math inline">\(\binom n k=0\)</span>。否则，有 <spanclass="math display">\[k\binom n k =\dfrac{n(n-1)\cdots (n-k+1)}{k(k-1)\cdots 1}\timesk=\dfrac{n(n-1)\cdots (n-k+1)}{(k-1)(k-2)\cdots 1}\]</span> 而又有 <span class="math display">\[n\binom {n-1}{k-1}=\dfrac{(n-1)(n-2)\cdots (n-k+1)}{(k-1)(k-2)\cdots1}\times n=\dfrac{n(n-1)\cdots (n-k+1)}{(k-1)(k-2)\cdots 1}=k\binom n k\]</span> 得证。</p></blockquote><p>显然根据组合意义，有 <span class="math display">\[\sum\limits_{k=0}^n\binom n k=2^n\tag{4}\]</span> 下面给出另一有关定理。</p><p><strong>定理 4</strong>   对于正整数 <spanclass="math inline">\(n&gt;1\)</span>，有如下二式成立 <spanclass="math display">\[\begin{aligned}\binom n 0 +\binom n 2 +\binom n 4 + \cdots &amp;= 2^{n-1} \\\binom n 1 +\binom n 3 +\binom n 5 + \cdots &amp;= 2^{n-1}\end{aligned}\tag{5}\]</span></p><blockquote><p><strong>证明</strong>   对于二项式定理 <spanclass="math inline">\(\sum\limits_{k=0}^n\binom n kx^{n-k}y^k\)</span>，取 <span class="math inline">\(x=1,y=-1\)</span>时可以得到 <span class="math display">\[\binom n 0 -\binom n 1+\binom n 2-\cdots +(-1)^n\binom n n =0\]</span> 移项可得 <span class="math display">\[\binom n 0+\binom n 2+\cdots =\binom n 1+\binom n 3+\cdots\\]</span> 根据 <span class="math inline">\((4)\)</span>式可以得到上式左右两边加和为 <spanclass="math inline">\(2^n\)</span>，故可知左右两边分别等于 <spanclass="math inline">\(2^{n-1}\)</span>。</p><p>得证。</p></blockquote><p><strong>定理 5</strong>   对于任意正整数 <spanclass="math inline">\(n\)</span>，有 <span class="math display">\[nx(1+x)^{n-1}=\sum\limits_{k=1}^n k\binom n k x^k\tag 6\]</span></p><blockquote><p><strong>证明</strong>   对 <span class="math inline">\((2)\)</span>式两边关于 <span class="math inline">\(x\)</span> 求导，得到 <spanclass="math display">\[n(1+x)^{n-1}=\sum\limits_{k=1}^nk\binom n k x^{k-1}\]</span> 两边同乘 <span class="math inline">\(x\)</span> 即可得证。</p></blockquote><p>对于上述定理还有一个特殊形式，当 <spanclass="math inline">\(x=1\)</span> 时，有 <span class="math display">\[n2^{n-1}=\sum\limits_{k=1}^nk\binom nk \tag 7\]</span> 如果对上述定理再同时关于 <spanclass="math inline">\(x\)</span> 求导，可以得到 <spanclass="math display">\[n(n+1)2^{n-2}=\sum\limits_{k=1}^n k^2\binom nk\tag 8\]</span> <strong>定理 6</strong>  关于帕斯卡三角形各行上的数字的平方和，有如下等式 <spanclass="math display">\[\sum\limits_{k=0}^n \binom nk^2=\binom {2n} n\tag 9\]</span></p><blockquote><p><strong>证明</strong>   设 <span class="math inline">\(S\)</span>为一个大小为 <span class="math inline">\(2n\)</span> 的集合，将其分为<span class="math inline">\(A,B\)</span> 两个大小均为 <spanclass="math inline">\(n\)</span> 的不交集合。考虑选出 <spanclass="math inline">\(S\)</span> 的每一个 <spanclass="math inline">\(n\)</span> 子集，设其中元素在 <spanclass="math inline">\(A\)</span> 集合中的有 <spanclass="math inline">\(k\)</span> 个，则在 <spanclass="math inline">\(B\)</span> 集合中的有 <spanclass="math inline">\(n-k\)</span> 个，其中 <spanclass="math inline">\(0\le k\le n\)</span>。</p><p>按照 <span class="math inline">\(k\)</span> 的大小建立 <spanclass="math inline">\(k+1\)</span> 个集合 <spanclass="math inline">\(\mathscr{C}_k\)</span>，表示由包含 <spanclass="math inline">\(k\)</span> 个 <spanclass="math inline">\(A\)</span> 集合中的元素与 <spanclass="math inline">\(n-k\)</span> 个 <spanclass="math inline">\(B\)</span> 集合组成的 <spanclass="math inline">\(n\)</span> 子集的集合。显然有 <spanclass="math display">\[\binom {2n} n=\sum\limits_{i=0}^n | \mathscr C_i|\]</span> 考虑每一个 <span class="math inline">\(\mathscr C_i\)</span>的元素个数，其中每个 <span class="math inline">\(n\)</span> 子集包含的<span class="math inline">\(k\)</span> 个 <spanclass="math inline">\(A\)</span> 中元素有 <spanclass="math inline">\(\binom n k\)</span> 种，<spanclass="math inline">\(B\)</span> 中元素有 <spanclass="math inline">\(\binom n {n-k}\)</span> 中，故有 <spanclass="math display">\[\sum\limits_{i=0}^n |\mathscr C_i|=\sum\limits_{i=0}^n \binom n k\binomn {n-k}=\sum\limits _{i=0}^n \binom n k^2=\binom {2n} n\]</span> 得证。</p></blockquote><p><strong>定理 7</strong>   对于正整数 <spanclass="math inline">\(n,k\)</span>，有 <span class="math display">\[\binom {n+1}{k+1}=\sum\limits_{i=0}^n\binom i k\]</span></p><blockquote><p><strong>证明</strong>   对于二项式 <span class="math inline">\(\binomn k\)</span> 不断应用基本公式 <span class="math inline">\(\binom nk=\binom {n-1} k+\binom {n-1}{k-1}\)</span>，可以得到 <spanclass="math display">\[\binom nk=\binom 0k+\binom 0{k-1}+\cdots +\binom {n-2}{k-1}+\binom{n-1}{k-1}\]</span> 根据 <span class="math inline">\(\binom 0k=0\)</span>消去该项，并用 <span class="math inline">\(n+1\)</span> 取代 <spanclass="math inline">\(n\)</span>，用 <spanclass="math inline">\(k+1\)</span> 取代 <spanclass="math inline">\(k\)</span> 得证。</p></blockquote><h2 id="二项式系数的单峰性">1.3   二项式系数的单峰性</h2><p>通过考察帕斯卡三角的某一行，不难发现单峰性 <spanclass="math display">\[\binom n1&lt;\binom n2&lt;\cdots &lt;\binom nt,\binom nt&gt;\binomn{t+1}&gt;\cdots&gt;\binom nn\]</span> 当 <span class="math inline">\(n\)</span> 为奇数时，最大值点<span class="math inline">\(t=\lfloor\dfrac n2\rfloor\)</span>。</p><p>当 <span class="math inline">\(n\)</span> 为偶数时，有两个最大值点<span class="math inline">\(\dfrac n2\)</span> 和 <spanclass="math inline">\(\dfrac n2+1\)</span>。</p><h2 id="sperner-定理">1.4   Sperner 定理</h2><p>对于一个 <span class="math inline">\(n\)</span> 元素集合 <spanclass="math inline">\(S\)</span>，定义 <spanclass="math inline">\(S\)</span> 的子集的集合 <spanclass="math inline">\(\mathscr C\)</span>是一条<strong>链</strong>，当且仅当对于 <spanclass="math inline">\(\mathscr C\)</span>​​的每一对子集，总有包含与被包含关系。</p><p>定义 <span class="math inline">\(S\)</span>的一条<strong>最大链</strong>为元素个数最多的子集集合 <spanclass="math inline">\(\mathscr C\)</span>。</p><p>定义 <span class="math inline">\(S\)</span> 的子集的集合 <spanclass="math inline">\(\mathscr C\)</span>是一条<strong>反链</strong>，当且仅当 <spanclass="math inline">\(\mathscr C\)</span>的每对元素都没有包含与被包含关系。</p><p><strong>定理 8（Sperner 定理）</strong>   设 <spanclass="math inline">\(S\)</span> 为 <spanclass="math inline">\(n\)</span> 元素集合，则 <spanclass="math inline">\(S\)</span> 的一个反链上至多包含 <spanclass="math inline">\(\dbinom n{\lfloor\frac n2\rfloor}\)</span>个集合。</p><blockquote><p><strong>证明</strong>   考虑什么样的集合 <spanclass="math inline">\(\mathscr C\)</span>会成为<strong>最大链</strong>。不难发现，当形如 <spanclass="math inline">\(\mathscrC=\{\{a_1\},\{a_1,a_2\},\cdots,\{a_1,a_2,\cdots a_n\}\}\)</span>的时候会成为最大链，最大链长度为 <spanclass="math inline">\(n\)</span>，其中 <spanclass="math inline">\(a_1,a_2\cdots a_n\)</span> 为一个 <spanclass="math inline">\(1\sim n\)</span>的<strong>排列</strong>，最大链个数为 <spanclass="math inline">\(n!\)</span>。</p><p>当我们考虑一个 <span class="math inline">\(S\)</span> 的子集 <spanclass="math inline">\(A\)</span> 的时候，固定 <spanclass="math inline">\(|A|=k\)</span> 时，发现<strong>包含集合 <spanclass="math inline">\(A\)</span> 的最大链的个数</strong>为 <spanclass="math display">\[k!(n-k)!\]</span> 在构成的最大链中，其中有 <spanclass="math inline">\(k!\)</span> 个是包含于 <spanclass="math inline">\(A\)</span> 的集合数目，<spanclass="math inline">\((n-k)!\)</span> 是包含 <spanclass="math inline">\(A\)</span>​ 的集合数目。</p><p>同时不难发现：<strong>每条链至多能包含任意一个反链的一个成员</strong>，反证不难。</p><p>现在要求反链的最大长度，根据上述引理，可以唯一转化为求包含反链成员的不同最大链长度。</p><p>设 <span class="math inline">\(\mathscr A\)</span> 是反链，<spanclass="math inline">\(A\)</span> 是反链中的一个元素，<spanclass="math inline">\(\mathscr C\)</span> 是包含 <spanclass="math inline">\(A\)</span> 的最大链。设 <spanclass="math inline">\(\beta=|\mathscr A|\)</span> 同时等于合法的最大链<span class="math inline">\(\mathscr C\)</span> 的个数。根据上述论证，有<span class="math inline">\(\beta\le n!\)</span>。如果 <spanclass="math inline">\(|A|=k\)</span>，则有 <spanclass="math inline">\(k!(n-k)!\)</span> 个包含 <spanclass="math inline">\(A\)</span> 的最大链 <spanclass="math inline">\(\mathscr C\)</span>。</p><p>设 <span class="math inline">\(\alpha _k\)</span> 是反链 <spanclass="math inline">\(\mathscr A\)</span> 中大小为 <spanclass="math inline">\(k\)</span> 的元素个数，有 <spanclass="math inline">\(|\mathscr A|=\sum\limits_{k=0}^n\alpha_k\)</span>，于是 <span class="math display">\[\beta=\sum\limits_{k=0}^n \alpha_k k!(n-k)!\le n!\]</span> 通过化简得到 <span class="math display">\[\sum\limits_{k=0}^n\dfrac{\alpha_k}{\dbinom nk}\le 1\]</span> 根据二项式系数的单峰性，当 <spanclass="math inline">\(k=\lfloor \dfrac n2 \rfloor\)</span> 的时候 <spanclass="math inline">\(\dbinom nk\)</span> 最大，于是有 <spanclass="math display">\[|\mathscr A|\le \sum\limits_{k=0}^n\alpha _k\le \binom n {\lfloor \dfracn2 \rfloor}\]</span> 得证。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 组合数学学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指数、对数、双曲函数的导数与极限</title>
      <link href="/post/cb74d1c1ba84.html"/>
      <url>/post/cb74d1c1ba84.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>微积分学习笔记 - 04 指数、对数、双曲函数的导数与极限</p><p>进入 <ahref="/categories/微积分学习笔记/">传送门</a>，阅读刊载在专栏《微积分阅读笔记》下的全部文章。</p></blockquote><h1 id="六指数函数与对数函数的导数">六、指数函数与对数函数的导数</h1><p>本节通过对自然常数 <span class="math inline">\(\mathrm{e}\)</span>的探究推出指数与对数函数的导数。请务必在阅读本节前了解指数与对数的基本运算性质。</p><h2 id="mathrme-的定义与相关极限">6.1   <spanclass="math inline">\(\mathrm{e}\)</span> 的定义与相关极限</h2><p><strong><span class="math inline">\(\mathrm{e}\)</span>的定义</strong>   对于极限，定义 <span class="math display">\[\mathrm{e}=\lim\limits_{h\to 0^+}(1+h)^{\frac1h}\]</span> 关于它的求解与证明暂时略去。通过上述极限可以推出许多性质。</p><p>考虑极限 <span class="math display">\[L=\lim\limits_{n\to \infty}(1+\dfrac rn)^n\]</span> 令 <span class="math inline">\(h=\dfrac rn\)</span>，这样<span class="math inline">\(n=\dfrac rh\)</span>，对上述极限变形，有<span class="math display">\[L=\lim\limits_{h\to 0^+}(1+h)^{\frac rh}=\lim\limits_{h\to0^+}((1+h)^{\frac 1h})^r=\mathrm{e}^r\]</span> 注意此时变成了 <span class="math inline">\(h\to 0^+\)</span>处的极限。这样，就有重要极限 <span class="math display">\[\boxed{\lim\limits_{n\to \infty}(1+\dfrac xn)^n=\mathrm{e}^x}\tag{1}\]</span> 特殊地，当 <span class="math inline">\(x=1\)</span> 时，有<span class="math display">\[\boxed{\lim\limits_{n\to \infty}(1+\dfrac 1n)^n=\mathrm{e}}\]</span> 对于极限 <span class="math inline">\((1)\)</span>，令 <spanclass="math inline">\(h=\dfrac 1n\)</span>，有 <spanclass="math display">\[\lim\limits_{h\to 0^+}(1+rh)^{\frac 1h}=\mathrm{e}^r\]</span> 注意极限位置。得出另一个重要极限 <span class="math display">\[\boxed{\lim\limits_{h\to 0^+}(1+xh)^{\frac 1h}=\mathrm{e}^x}\]</span> 特殊地，当 <span class="math inline">\(x=1\)</span> 时，有<span class="math display">\[\boxed{\lim\limits_{h\to 0^+}(1+h)^{\frac 1h}=\mathrm{e}}\]</span></p><h2 id="对数函数与指数函数的导数">6.2   对数函数与指数函数的导数</h2><p>使用导数的定义，令 <spanclass="math inline">\(f(x)=\log_bx\)</span>，则有 <spanclass="math display">\[\begin{aligned}f&#39;(x)&amp;=\lim\limits_{h\to0}\dfrac{f(x+h)-f(x)}{h}=\lim\limits_{h\to 0}\dfrac{\log_b(x+h)-\log_bx}h\\&amp;=\lim\limits_{h\to 0}\dfrac 1h\log_b(\dfrac{x+h}x)\\&amp;=\lim\limits_{h\to 0}\log_b(1+\dfrac hx)^{\frac 1h}\end{aligned}\]</span> 上一节中，我们证明了 <span class="math display">\[\lim\limits_{h\to 0^+}(1+rh)^{\frac 1h}=\mathrm{e}^r\]</span> 不妨令 <span class="math inline">\(r=\dfrac 1x\)</span>，则有<span class="math display">\[\begin{aligned}f&#39;(x)&amp;=\lim\limits_{h\to 0}\log_b(1+\dfrac hx)^{\frac1h}=\log_b(\mathrm{e}^\frac1x)\\&amp;=\dfrac{\ln \mathrm{e}^\frac 1x}{\ln b}\\&amp;=\dfrac 1{x\ln b}\end{aligned}\]</span> 这就证明了<strong>对数函数的导数</strong>为 <spanclass="math display">\[\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\log_bx=\dfrac 1{x\ln b}}\]</span> 特殊地，自然对数的导数为 <span class="math display">\[\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\ln x=\dfrac 1x}\]</span> 接下来推导指数函数的导数。对于指数函数 <spanclass="math inline">\(y=a^x\)</span>，等价于 <spanclass="math inline">\(x=\log_ay\)</span>。现在关于 <spanclass="math inline">\(y\)</span> 求导，有： <spanclass="math display">\[\dfrac{\mathrm{d}x}{\mathrm{d}y}=\dfrac1{x\ln a}\]</span> 根据链式求导法则，<spanclass="math inline">\(\dfrac{\mathrm{d}x}{\mathrm{d}x}=\dfrac{\mathrm{d}y}{\mathrm{d}x}\dfrac{\mathrm{d}x}{\mathrm{d}y}=1\)</span>，可以上下颠倒得到：<span class="math display">\[\dfrac{\mathrm{d}y}{\mathrm{d}x}=y\ln a=a^x\ln a\]</span> 这就证明了<strong>指数函数的导数</strong>为 <spanclass="math display">\[\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}a^x=a^x\ln a}\]</span> 特殊地，以自然常数为底数的指数，导数为 <spanclass="math display">\[\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\mathrm{e}^x=\mathrm{e}^x}\]</span> 这是一个独特的公式。发现它的导数还是它自己。</p><h2 id="伸缩函数的导数">6.3   伸缩函数的导数</h2><p>这里的<strong>伸缩函数</strong>，定义为：对于函数 <spanclass="math inline">\(y=f(x)\)</span>，则其伸缩函数为 <spanclass="math inline">\(y&#39;=f(ax)\)</span>，其中，<spanclass="math inline">\(a\)</span> 为常数。</p><p>对伸缩函数求导，即 <spanclass="math inline">\(\dfrac{\mathrm{d}}{\mathrm{d}x}f(ax)\)</span>，根据链式求导法则，令 <spanclass="math inline">\(u=ax\)</span>，则 <spanclass="math inline">\(y=f(u)\)</span>，有 <span class="math display">\[\dfrac{\mathrm{d}y}{\mathrm{d}x}=\dfrac{\mathrm{d}y}{\mathrm{d}u}\dfrac{\mathrm{d}u}{\mathrm{d}x}=af&#39;(u)=af&#39;(ax)\]</span> 可以发现，伸缩函数的导数与原本函数的导数相比，前面多了 <spanclass="math inline">\(a\)</span> 的常数。</p><p>这个规律对指数对数函数、三角函数同样适用，例如，<spanclass="math inline">\(y=\mathrm{e}^{-3x}\)</span>，则其导数为 <spanclass="math inline">\(\dfrac{\mathrm{d}y}{\mathrm{d}x}=-3\mathrm{e}^{-3x}\)</span>。</p><h2 id="取对数求导法">6.4   取对数求导法</h2><p>对于类似 <span class="math inline">\(y=f(x)^{g(x)}\)</span>一类指数与底数均为 <span class="math inline">\(x\)</span>的函数的导数问题，通常使用取对数求导法，具体地：</p><ul><li>对等号两边取自然对数，使指数移下来成为系数得到类似 <spanclass="math inline">\(\ln y=g(x)\ln f(x)\)</span> 的式子；</li><li>对等号两边进行隐函数求导，有 <span class="math inline">\(\dfrac1y\dfrac{\mathrm{d}y}{\mathrm{d}x}=\dfrac{\mathrm{d}}{\mathrm{d}x}g(x)\lnf(x)\)</span>；</li><li>对等式化简，完成求解。</li></ul><blockquote><p><strong>例子</strong>   求解导数 <spanclass="math inline">\(\dfrac{\mathrm{d}}{\mathrm{d}x}x^{\sin(x)}\)</span>。</p></blockquote><p>令 <spanclass="math inline">\(y=x^{\sin(x)}\)</span>，对等式两边取对数得到 <spanclass="math inline">\(\ln y=\sin(x)\ln x\)</span>，对隐函数求导有 <spanclass="math display">\[\dfrac 1y \dfrac{\mathrm{d}y}{\mathrm{d}x}=\cos(x)\ln x+\dfrac{\sin(x)}x\]</span> 化简得到 <span class="math display">\[\dfrac{\mathrm{d}y}{\mathrm{d}x}x^{\sin(x)}=(\cos(x)\ln x+\dfrac{\sin(x)}x)x^{\sin(x)}\]</span></p><h1 id="七指数函数与对数函数的极限">七、指数函数与对数函数的极限</h1><p>本节将借助指数函数与对数函数的导数，求解二者在特殊位置的极限与变化率。将其变化率与其他初等函数比较，会有重要的性质。</p><h2 id="涉及-mathrm-e-的极限">7.1   涉及 <spanclass="math inline">\(\mathrm e\)</span> 的极限</h2><p>涉及 <span class="math inline">\(\mathrm e\)</span>的极限，通常借助重要结论求解： <span class="math display">\[\lim\limits_{h\to 0^+}(1+h)^{\frac 1h}=\mathrm{e}\tag{2}\]</span></p><blockquote><p><strong>例子</strong>   求解极限 <spanclass="math inline">\(\lim\limits_{h\to0}(1+h^2)^{\frac1{3h^2}}\)</span>。</p></blockquote><p>容易发现，这个式子形式很像 <span class="math inline">\((2)\)</span>式，不妨就通过这个突破点思考。令 <spanclass="math inline">\(x=h^2\)</span>，则原极限等价于 <spanclass="math display">\[\lim\limits_{x\to 0}(1+x^2)^{\frac 1{x}\cdot \frac 13}=\mathrm e ^{\frac13}\]</span> 便可求解。</p><h2 id="指数函数的行为">7.2   指数函数的行为</h2><p>下面是指数函数 <span class="math inline">\(y=\mathrm e^x\)</span>的图像。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=OEon7oi0" style="zoom:67%;" /></p><p>根据指数函数图像，不难发现指数函数 <spanclass="math inline">\(y=a^x(a&gt;1)\)</span> 有两个重要极限 <spanclass="math display">\[\lim\limits_{x\to \infty}a^x=\infty\quad,\quad \lim\limits_{x\to-\infty}a^x=0\]</span> 当 <span class="math inline">\(0&lt;a&lt;1\)</span>是有相反的性质 <span class="math display">\[\lim\limits_{x\to \infty}a^x=0\quad,\quad \lim\limits_{x\to-\infty}a^x=\infty\]</span> <strong>指数函数增长迅速</strong>：对于任意多项式函数 <spanclass="math inline">\(f(x)\)</span>，都有 <spanclass="math inline">\(\boxed{\lim\limits_{x\to\infty}\dfrac{f(x)}{\mathrm e^x}=0}\)</span>。</p><p>下面分析指数函数在 <span class="math inline">\(0\)</span>附近的行为。</p><p>根据函数过定点，显然有 <span class="math inline">\(\lim\limits_{x\to0}\mathrm e^x=1\)</span>。</p><p>设 <span class="math inline">\(f(x)=\mathrm e^x\)</span>，其导数为<span class="math inline">\(\mathrm e^x\)</span>，在 <spanclass="math inline">\(x=0\)</span> 时为 <spanclass="math inline">\(1\)</span>。换一种方式分析，根据导数定义有： <spanclass="math display">\[\begin{aligned}\lim\limits_{h\to 0}\dfrac{\mathrm e^{x+h}+\mathrm e^x}h=\mathrm e^x\end{aligned}\]</span> 在 <span class="math inline">\(x\to 0\)</span> 时有 <spanclass="math display">\[\lim\limits_{h\to 0}\dfrac{\mathrm e^h-1}h=1\]</span></p><h2 id="对数函数的行为">7.3   对数函数的行为</h2><p>下面是对数函数 <span class="math inline">\(y=\ln x\)</span>的图像。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=wRfD30Hf" style="zoom: 67%;" /></p><p>根据指数函数图像，不难发现指数函数 <span class="math inline">\(y=\log_ax(a&gt;1)\)</span> 有两个重要极限 <span class="math display">\[\lim\limits_{x\to 0^+}\log_ax=-\infty\quad,\quad \lim\limits_{x\to\infty}\log_ax=\infty\]</span> 当 <span class="math inline">\(0&lt;a&lt;1\)</span>是有相反的性质 <span class="math display">\[\lim\limits_{x\to 0^+}a^x=\infty\quad,\quad \lim\limits_{x\to-\infty}\log_ax=-\infty\]</span> <strong>对数函数增长缓慢</strong>：对于任意多项式函数 <spanclass="math inline">\(f(x)\)</span>，都有 <spanclass="math inline">\(\boxed{\lim\limits_{x\to \infty}\dfrac{\lnx}{f(x)}=0}\)</span></p><p>对于极限 <span class="math inline">\(\lim\limits_{x\to 0^+}x\lnx\)</span>，令 <span class="math inline">\(t=\dfrac 1x\)</span>，则有：<span class="math display">\[\lim\limits_{x\to 0^+}x\ln x=\lim\limits_{t\to \infty}\dfrac 1t\ln\dfrac 1t=\lim\limits_{t\to \infty}\dfrac{-\ln t}t=0\]</span> 得到结论，<strong>对数函数在 <spanclass="math inline">\(0\)</span> 附近增长缓慢</strong>：<spanclass="math inline">\(\forall a&gt;0,\boxed{\lim\limits_{x\to 0^+}x^a\lnx=0}\)</span>。</p><h1 id="八双曲函数的导数">八、双曲函数的导数</h1><p>下面探究一下<strong>双曲函数</strong>。双曲函数与三角函数有比较相似的性质。</p><h2 id="双曲正弦函数与双曲余弦函数">8.1  双曲正弦函数与双曲余弦函数</h2><p>下面给出定义：</p><ul><li><strong>双曲正弦函数</strong>：<spanclass="math inline">\(\sinh(x)=\dfrac{\mathrm e^x-\mathrme^{-x}}2\)</span>；</li><li><strong>双曲余弦函数</strong>：<spanclass="math inline">\(\cosh(x)=\dfrac{\mathrm e^x+\mathrme^{-x}}2\)</span>。</li></ul><p>会发现，<spanclass="math inline">\(\cosh^2(x)-\sinh^2(x)=\dfrac{\mathrme^{2x}+\mathrm e^{-2x}+2}4-\dfrac{\mathrm e^{2x}+\mathrme^{-2x}2}4=1\)</span>，得出与三角函数很像的结论： <spanclass="math display">\[\cosh^2(x)-\sinh^2(x)=1\]</span> 接下来对两式求导： <span class="math display">\[\dfrac{\mathrm{d}}{\mathrm{d}x}\sinh(x)=\dfrac{\mathrm{d}}{\mathrm{d}x}(\dfrac{\mathrme^x-\mathrm e^{-x}}2)=\dfrac{\mathrm e^x+\mathrm e^{-x}}2=\cosh(x)\]</span></p><p><span class="math display">\[\dfrac{\mathrm{d}}{\mathrm{d}x}\cosh(x)=\dfrac{\mathrm{d}}{\mathrm{d}x}(\dfrac{\mathrme^x+\mathrm e^{-x}}2)=\dfrac{\mathrm e^x-\mathrm e^{-x}}2=\sinh(x)\]</span></p><p>发现二者互为导数，即： <span class="math display">\[\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\sinh(x)=\cosh(x)}\quad,\quad\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\cosh(x)=\sinh(x)}\]</span> 下面是两函数的图像。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=kC7j0DFk" style="zoom:67%;" /></p><h2 id="其他双曲函数">8.2   其他双曲函数</h2><p>借助双曲正弦与双曲余弦函数的定义，推出下面四种双曲函数的定义与导数：</p><ul><li><strong>双曲正切函数</strong>：<spanclass="math inline">\(\tanh(x)=\dfrac{\sinh(x)}{\cosh(x)}=\dfrac{\mathrme^x-\mathrm e^{-x}}{\mathrm e^x+\mathrm e^{-x}}\)</span>；</li><li><strong>双曲余切函数</strong>：<spanclass="math inline">\(\coth(x)=\dfrac{\cosh(x)}{\sinh(x)}=\dfrac{\mathrme^x+\mathrm e^{-x}}{\mathrm e^x-\mathrm e^{-x}}\)</span>；</li><li><strong>双曲正割函数</strong>：<spanclass="math inline">\(\text{sech}(x)=\dfrac1{\cosh(x)}=\dfrac2{\mathrme^x+\mathrm e^{-x}}\)</span>；</li><li><strong>双曲余割函数</strong>：<spanclass="math inline">\(\text{csch}(x)=\dfrac1{\sinh(x)}=\dfrac2{\mathrme^x-\mathrm e^{-x}}\)</span>。</li></ul><p>从 <span class="math inline">\(\cosh^2(x)-\sinh^2(x)=1\)</span>可以推出： <span class="math display">\[1-\tanh^2(x)=\text{sech}^2(x)\]</span> 与双曲正弦与双曲正切函数类似，它们的导数为： <spanclass="math display">\[\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\tanh(x)=\text{sech}^2(x)}\quad,\quad\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\coth(x)=-\text{csch}^2(x)}\]</span></p><p><span class="math display">\[\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\text{sech}(x)=-\text{sech}(x)\tanh(x)}\quad,\quad\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\text{csch}(x)=-\text{csch}(x)\coth(x)}\]</span></p><p>下面是这四个函数的图像。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=O08RO95A" style="zoom:67%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 微积分学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隐函数求导</title>
      <link href="/post/daf7d27a167b.html"/>
      <url>/post/daf7d27a167b.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>微积分学习笔记 - 03 隐函数求导</p><p>进入 <ahref="/categories/微积分学习笔记/">传送门</a>，阅读刊载在专栏《微积分阅读笔记》下的全部文章。</p></blockquote><h1 id="五隐函数求导">五、隐函数求导</h1><p>这一节与其他节相关很少，但后面也要经常用到，所以只好单拎出来。</p><h2 id="隐函数求导">5.1   隐函数求导</h2><p>考虑两个导数 <span class="math display">\[\dfrac{\mathrm{d}}{\mathrm{d}x}(x^2) \quad,\quad\dfrac{\mathrm{d}}{\mathrm{d}x}(y^2)\]</span> 前者显然为 <spanclass="math inline">\(2x\)</span>，但后者却不一定。这主要取决于变量<span class="math inline">\(y\)</span> 与变量 <spanclass="math inline">\(x\)</span> 间的变化关系。</p><p>那怎样求它的导数呢？参考链式求导法则，变量 <spanclass="math inline">\(x\)</span> 的改变会导致变量 <spanclass="math inline">\(y\)</span> 的改变，而变量 <spanclass="math inline">\(y\)</span> 的改变又会导致 <spanclass="math inline">\(y^2\)</span> 的改变。</p><p>令 <span class="math inline">\(u=y^2\)</span>，则 <spanclass="math inline">\(\dfrac{\mathrm{d}u}{\mathrm{d}y}=2y\)</span>，则：<span class="math display">\[\dfrac{\mathrm{d}}{\mathrm{d}x}(y^2)=\dfrac{\mathrm{d}u}{\mathrm{d}y}\dfrac{\mathrm{d}y}{\mathrm{d}x}=2y\dfrac{\mathrm{d}y}{\mathrm{d}x}\]</span> 这就求出了它的导数。显然，若 <spanclass="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span> 毫不相干的时候，导数就为 <spanclass="math inline">\(0\)</span>。</p><blockquote><p><strong>例子</strong>   对于圆的方程 <spanclass="math inline">\(x^2+y^2=4\)</span>，求圆上各点的切线的斜率。</p></blockquote><p>对于这个例子，因为 <span class="math inline">\(y\)</span> 并不是<span class="math inline">\(x\)</span>的函数，并不能直接求导，可以通过在等式两边同时加上 <spanclass="math inline">\(\dfrac{\mathrm{d}}{\mathrm{d}x}\)</span>对隐函数求导，即： <span class="math display">\[\begin{aligned}\dfrac{\mathrm{d}}{\mathrm{d}x}(x^2+y^2)&amp;=\dfrac{\mathrm{d}}{\mathrm{d}x}4\\\dfrac{\mathrm{d}}{\mathrm{d}x}(x^2)+\dfrac{\mathrm{d}}{\mathrm{d}x}(y^2)&amp;=0\\2x+2y\dfrac{\mathrm{d}y}{\mathrm{d}x}&amp;=0\\\dfrac{\mathrm{d}y}{\mathrm{d}x}&amp;=-\dfrac xy\end{aligned}\]</span> 只需要对圆上的每个点 <spanclass="math inline">\((x,y)\)</span> 对应求导即可。</p><p>对于求隐函数导数的问题，通常采用以下方法：</p><ul><li>对原方程进行简化；</li><li>对等式两边同时对一个变量求导，即同时乘上 <spanclass="math inline">\(\dfrac{\mathrm{d}}{\mathrm{d}x}\)</span>，并化简；</li><li>若需求出曲线上某点的切线方程，则需代入对应 <spanclass="math inline">\(x,y\)</span> 求解。</li></ul><h2 id="隐函数求二阶导">5.2   隐函数求二阶导</h2><p>隐函数求二阶导的方法和普通函数类似——在一阶导的基础上求导。</p><blockquote><p><strong>例子</strong>   求函数 <spanclass="math inline">\(2y+\sin(y)=\dfrac{x^2}\pi +1\)</span> 的二阶导<spanclass="math inline">\(\dfrac{\mathrm{d}^2y}{\mathrm{d}x^2}\)</span>。</p></blockquote><p>对隐函数先求一阶导，有：</p><p><span class="math display">\[2\dfrac{\mathrm{d}y}{\mathrm{d}x}+\cos(y)\dfrac{\mathrm{d}y}{\mathrm{d}x}=\dfrac{2x}\pi\tag{1}\]</span> 在 <span class="math inline">\((1)\)</span>上进而对其求二阶导： <span class="math display">\[\begin{aligned}\dfrac{\mathrm{d}}{\mathrm{d}x}(2\dfrac{\mathrm{d}y}{\mathrm{d}x})+\dfrac{\mathrm{d}}{\mathrm{d}x}(\cos(y)\dfrac{\mathrm{d}y}{\mathrm{d}x})&amp;=\dfrac{\mathrm{d}}{\mathrm{d}x}(\dfrac{2x}\pi)\\2\dfrac{\mathrm{d}^2y}{\mathrm{d}x^2}-\sin(y)(\dfrac{\mathrm{d}y}{\mathrm{d}x})^2+\cos(y)\dfrac{\mathrm{d}^2y}{\mathrm{d}x^2}&amp;=\dfrac2\pi\\\end{aligned}\]</span> 化简得到 <span class="math display">\[2\dfrac{\mathrm{d}^2y}{\mathrm{d}x^2}=(\dfrac{\mathrm{d}y}{\mathrm{d}x})^2+\dfrac2\pi\]</span> 下面解决 <spanclass="math inline">\(\dfrac{\mathrm{d}y}{\mathrm{d}x}\)</span>的求解，根据 <span class="math inline">\((1)\)</span> 得： <spanclass="math display">\[\dfrac{\mathrm{d}y}{\mathrm{d}x}=\dfrac{2x}{\pi(2+\cos(y))}\]</span> 代入得 <span class="math display">\[\begin{aligned}\dfrac{\mathrm{d}^2y}{\mathrm{d}x^2}&amp;=\dfrac{(\dfrac{2x}{\pi(2+\cos(y))})^2+\dfrac2\pi}{2}\\&amp;=\dfrac{2x^2}{\pi^2(2+\cos(y))^2}+\frac1\pi\end{aligned}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 微积分学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三角函数的极限和导数</title>
      <link href="/post/9b5899dde65e.html"/>
      <url>/post/9b5899dde65e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>微积分学习笔记 - 02 三角函数的极限和导数</p><p>进入 <ahref="/categories/微积分学习笔记/">传送门</a>，阅读刊载在专栏《微积分阅读笔记》下的全部文章。</p></blockquote><h1 id="三三角函数的极限">三、三角函数的极限</h1><p>本节简短记录几个比较重要的三角函数极限，对后文推出三角函数的导数有重要作用。</p><h2 id="正弦函数的极限">3.1   正弦函数的极限</h2><p>首先考虑一个重要极限 <span class="math display">\[\lim\limits_{x\to 0}\dfrac{\sin(x)}{x}\]</span> 这个极限的求解将借助单位圆完成。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=4CRL3xmn" /></p><p>三角形 OAC、扇形 OAB、三角形 ODB 的面积分别等于 <spanclass="math inline">\(\dfrac{\sin(x)}{2}\)</span>，<spanclass="math inline">\(\dfrac x 2\)</span>，<spanclass="math inline">\(\dfrac{\tan(x)} 2\)</span>，有不等关系 <spanclass="math display">\[\sin(x)&lt;x&lt;\tan(x)\]</span> 对于 <span class="math inline">\(x&gt;0\)</span>的情况进一步转化可得 <span class="math display">\[\cos(x)&lt;\dfrac{\sin(x)}x&lt;1\]</span> 使用三明治定理，在 <span class="math inline">\(x=0\)</span>的位置，<span class="math inline">\(\cos(x)=1\)</span>，所以得到右极限<span class="math display">\[\lim\limits_{x\to 0^+}\dfrac{\sin(x)}{x}=1\]</span> 由于上述函数是奇函数，不难得到双侧极限 <spanclass="math display">\[\boxed{\lim\limits_{x\to 0}\dfrac{\sin(x)}{x}=1}\]</span> 求解正弦函数的极限，通常利用正弦函数的值域特征 <spanclass="math inline">\(-1\le \sin(x)\le 1\)</span> 简化问题。</p><h2 id="余弦函数的极限">3.2   余弦函数的极限</h2><p>显然，我们有极限 <span class="math display">\[\lim \limits_{x\to 0}\cos(x)=1\]</span> 接下来考虑极限 <span class="math display">\[\lim \limits_{x\to 0}\dfrac{1-\cos(x)}{x}\]</span> 尝试让分子出现 <spanclass="math inline">\(1-\cos^2(x)\)</span>，从而出现 <spanclass="math inline">\(\sin^2(x)\)</span>，借助正弦函数极限求解。 <spanclass="math display">\[\begin{aligned}\lim \limits_{x\to 0}\dfrac{1-\cos(x)}{x}&amp;=\lim\limits_{x\to0}\dfrac{1-\cos(x)}{x}\times \dfrac{1+\cos(x)}{1+\cos(x)} \\&amp;=\lim \limits_{x\to 0}\dfrac{1-\cos^2(x)}{x(1+\cos(x))}\\&amp;=\lim \limits_{x\to 0}\dfrac{\sin^2(x)}{x}\times\dfrac{1}{1+\cos(x)}\\&amp;=\lim \limits_{x\to 0}\sin(x)\times \dfrac{\sin(x)}{x}\times\dfrac{1}{1+\cos(x)}\\&amp;=0\times 1\times \dfrac{1}{1+1}\\&amp;=0\end{aligned}\]</span> 所以得到重要结论 <span class="math display">\[\boxed{\lim \limits_{x\to 0}\dfrac{1-\cos(x)}{x}=0}\]</span> 考虑另一个极限 <span class="math display">\[\lim \limits_{x\to 0}\dfrac{1-\cos(x)}{x^2}\]</span> 借助上面的思路，不难得到 <span class="math display">\[\begin{aligned}\lim \limits_{x\to 0}\dfrac{1-\cos(x)}{x^2}&amp;=\lim \limits_{x\to0}\dfrac{1-\cos(x)}{x^2}\times \dfrac{1+\cos(x)}{1+\cos(x)}\\&amp;=\lim \limits_{x\to 0}\dfrac{1-\cos^2(x)}{x^2}\times\dfrac{1}{1+cos(x)}\\&amp;=\lim \limits_{x\to 0}(\dfrac{\sin(x)}{x})^2\times\dfrac{1}{1+\cos(x)}\\&amp;=1^2\times \dfrac{1}{1+1}\\&amp;=\dfrac12\end{aligned}\]</span></p><h2 id="正切函数的极限">3.3   正切函数的极限</h2><p>考虑极限 <span class="math display">\[\lim \limits_{x\to 0}\dfrac{\tan(x)}{x}\]</span> 作变换 <spanclass="math inline">\(\tan(x)=\dfrac{\sin(x)}{\cos(x)}\)</span> 可得<span class="math display">\[\begin{aligned}\lim \limits_{x\to 0}\dfrac{\tan(x)}{x}&amp;=\lim \limits_{x\to0}\dfrac{\dfrac{\sin(x)}{\cos(x)}}{x}\\&amp;=\lim \limits_{x\to 0}\dfrac{sin(x)}{x}\times \dfrac1{cos(x)}\\&amp;=1\times \dfrac11\\&amp;=1\end{aligned}\]</span> 这也就证明了 <span class="math display">\[\boxed{\lim \limits_{x\to 0}\dfrac{\tan(x)}{x}=1}\]</span></p><h1 id="四三角函数的导数">四、三角函数的导数</h1><p>借助第三节的推论，可以推出六种三角函数的导数。本节将对它们分别推出与证明。</p><p>下面是六种三角函数的导数对照表： <span class="math display">\[\begin{array}{|c|c|}f(x)=&amp;f&#39;(x)=\\\sin(x)&amp;\cos(x)\\\cos(x)&amp;-\sin(x)\\\tan(x)&amp;\sec^2(x)\\\cot(x)&amp;-\csc^2(x)\\\sec(x)&amp;\sec(x)\tan(x)\\\csc(x)&amp;-\csc(x)\cot(x)\end{array}\]</span></p><h2 id="正弦函数的导数">4.1   正弦函数的导数</h2><p>借助第三节中的两个极限 <span class="math display">\[\lim \limits_{h\to 0}\dfrac{\sin(h)}{h}=1\quad,\quad \lim \limits_{h\to0}\dfrac{1-\cos(h)}{h}=0\]</span> 直接使用导数定义与和角公式，令 <spanclass="math inline">\(f(x)=\sin(x)\)</span>，推出： <spanclass="math display">\[\begin{aligned}f&#39;(x)&amp;=\lim \limits_{h\to 0}\dfrac{f(x+h)-f(x)}{h}=\lim\limits_{h\to 0}\dfrac{\sin(x+h)-\sin(h)}{h}\\&amp;=\lim \limits_{h\to0}\dfrac{\sin(x)\cos(h)+\cos(x)\sin(h)-\sin(x)}h\\&amp;=\lim \limits_{h\to 0}\dfrac{\sin(x)(\cos(h)-1)+\cos(x)\sin(h)}h\\&amp;=\lim \limits_{h\to 0}(\sin(x)\times\dfrac{\cos(h)-1}h+\cos(x)\times \dfrac{\sin(h)}h)\\&amp;=\sin(x)\times 0+\cos(x)\times 1\\&amp;=\cos(x)\end{aligned}\]</span> 得出其导数为 <span class="math display">\[\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\sin(x)=\cos(x)}\]</span></p><h2 id="余弦函数的导数">4.2   余弦函数的导数</h2><p>令 <spanclass="math inline">\(f(x)=\cos(x)\)</span>，借助和角公式可得得到：<span class="math display">\[\begin{aligned}f&#39;(x)&amp;=\lim \limits_{h\to 0}\dfrac{f(x+h)-f(x)}h=\lim\limits_{h\to 0}\dfrac{\cos(x+h)-\cos(x)}h\\&amp;=\lim \limits_{h\to0}\dfrac{\cos(x)\cos(h)-\sin(x)\sin(h)-\cos(x)}h\\&amp;=\lim \limits_{h\to 0}\cos(x)\times\dfrac{\cos(h)-1}h-\sin(x)\times \dfrac{\sin(h)}h\\&amp;=\cos(x)\times 0-\sin(x)\times 1\\&amp;=-\sin(x)\end{aligned}\]</span> 得出其导数为 <span class="math display">\[\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\cos(x)=-\sin(x)}\]</span></p><h2 id="正切函数的导数">4.3   正切函数的导数</h2><p>令 <spanclass="math inline">\(y=\tan(x)=\dfrac{\sin(x)}{\cos(x)}\)</span>，再令<spanclass="math inline">\(u=\sin(x),v=\cos(x)\)</span>，使用商法则得到：<span class="math display">\[\begin{aligned}\dfrac{\mathrm{d}y}{\mathrm{d}x}&amp;=\dfrac{v\dfrac{\mathrm{d}u}{\mathrm{d}x}-u\dfrac{\mathrm{d}v}{\mathrm{d}x}}{v^2}=\dfrac{\cos(x)\cos(x)-\sin(x)(-\sin(x))}{\cos^2(x)}\\&amp;=\dfrac{1}{\cos^2(x)}\\&amp;=\sec^2(x)\end{aligned}\]</span> 得出其导数为 <span class="math display">\[\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\tan(x)=\sec^2(x)}\]</span></p><h2 id="余切函数的导数">4.4   余切函数的导数</h2><p>令 <spanclass="math inline">\(y=\cot(x)=\dfrac{\cos(x)}{\sin(x)}\)</span>，再令<spanclass="math inline">\(u=\cos(x),v=\sin(x)\)</span>，使用商法则得到：<span class="math display">\[\begin{aligned}\dfrac{\mathrm{d}y}{\mathrm{d}x}&amp;=\dfrac{v\dfrac{\mathrm{d}u}{\mathrm{d}x}-u\dfrac{\mathrm{d}v}{\mathrm{d}x}}{v^2}=\dfrac{\sin(x)(-\sin(x))-\cos(x)\cos(x)}{\sin^2(x)}\\&amp;=\dfrac{-1}{\sin^2(x)}\\&amp;=-\csc^2(x)\end{aligned}\]</span> 得到其导数为 <span class="math display">\[\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\cot(x)=\csc^2(x)}\]</span></p><h2 id="正割函数的导数">4.5   正割函数的导数</h2><p>令 <spanclass="math inline">\(y=\sec(x)=\dfrac1{\cos(x)}\)</span>，再令 <spanclass="math inline">\(u=\cos(x)\)</span>，则 <spanclass="math inline">\(y=\dfrac1{u}\)</span>，使用链式求导法则得到：<span class="math display">\[\begin{aligned}\dfrac{\mathrm{d}y}{\mathrm{d}x}&amp;=\dfrac{\mathrm{d}y}{\mathrm{d}u}\dfrac{\mathrm{d}u}{\mathrm{d}x}=-\dfrac1{\cos^2(x)}(-\sin(x))\\&amp;=\dfrac1{\cos(x)}\times\dfrac{\sin(x)}{\cos(x)}\\&amp;=\sec(x)\tan(x)\end{aligned}\]</span> 得出其导数为 <span class="math display">\[\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\sec(x)=\sec(x)\tan(x)}\]</span></p><h2 id="余割函数的导数">4.6   余割函数的导数</h2><p>令 <spanclass="math inline">\(y=\csc(x)=\dfrac1{\sin(x)}\)</span>，再令 <spanclass="math inline">\(u=\sin(x)\)</span>，则 <spanclass="math inline">\(y=\dfrac1{u}\)</span>，使用链式求导法则得到：<span class="math display">\[\begin{aligned}\dfrac{\mathrm{d}y}{\mathrm{d}x}&amp;=\dfrac{\mathrm{d}y}{\mathrm{d}u}\dfrac{\mathrm{d}u}{\mathrm{d}x}=-\dfrac1{\sin^2(x)}\cos(x)\\&amp;=-\dfrac1{\sin(x)}\times\dfrac{\cos(x)}{\sin(x)}\\&amp;=-\csc(x)\cot(x)\end{aligned}\]</span> 得出其导数为 <span class="math display">\[\boxed{\dfrac{\mathrm{d}}{\mathrm{d}x}\csc(x)=-\csc(x)\cot(x)}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 微积分学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>极限导论与微分</title>
      <link href="/post/449b1b41ce2d.html"/>
      <url>/post/449b1b41ce2d.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>微积分学习笔记 - 01 极限导论与微分</p><p>进入 <ahref="/categories/微积分学习笔记/">传送门</a>，阅读刊载在专栏《微积分阅读笔记》下的全部文章。</p></blockquote><h1 id="一极限导论">一、极限导论</h1><h2 id="极限的定义">1.1   极限的定义</h2><p><strong>极限</strong>：对于函数 <spanclass="math inline">\(f(x)\)</span>，任选 <spanclass="math inline">\(\epsilon&gt;0\)</span>，可以任选 <spanclass="math inline">\(\delta&gt;0\)</span>，使得：对于所有满足 <spanclass="math inline">\(0&lt;|x-a|&lt;\delta\)</span> 的 <spanclass="math inline">\(x\)</span>，有 <spanclass="math inline">\(|f(x)-L|&lt;\epsilon\)</span>，则称函数 <spanclass="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\(a\)</span> 处的极限为 <spanclass="math inline">\(L\)</span>，记作： <span class="math display">\[\lim\limits_{x\rightarrow a}=L\]</span> 上述定义可以简单理解成，在变量 <spanclass="math inline">\(x\)</span> 接近于 <spanclass="math inline">\(a\)</span> 时，函数值无限接近于 <spanclass="math inline">\(L\)</span>。</p><p>例如，对于函数 <spanclass="math inline">\(f(x)=x+1\)</span>，通过分析函数图像可知，有 <spanclass="math inline">\(\lim\limits_{x\rightarrow 2}=3\)</span>。</p><p>再例如，对于函数 <spanclass="math inline">\(g(x)=\begin{cases}x-1&amp;\text{如果}x\not=2\\3&amp;\text{如果}x=2\end{cases}\)</span>，事实上<span class="math inline">\(\lim\limits_{x\rightarrow2}=1\)</span>。这是因为只有那些在 <span class="math inline">\(x\)</span>接近于 <span class="math inline">\(2\)</span> 时的 <spanclass="math inline">\(g(x)\)</span> 的值，才是它的极限。</p><p><strong>左极限</strong>：与极限的定义类似地，只考虑 <spanclass="math inline">\(x&lt;a\)</span>的部分，函数在这部分中，自变量接近于 <spanclass="math inline">\(a\)</span> 的时候，函数值的接近值，记作： <spanclass="math display">\[\lim\limits_{x\rightarrow a^{-}} = L\]</span> <strong>右极限</strong>：只考虑 <spanclass="math inline">\(x&gt;a\)</span>的部分，函数在这部分中，之变量接近于 <spanclass="math inline">\(a\)</span> 的时候，函数值的接近值，记作： <spanclass="math display">\[\lim\limits_{x\rightarrow a^{+}}=L\]</span> 例如，函数 <span class="math inline">\(f(x)=x^{-1}\)</span>，在 <span class="math inline">\(0\)</span> 附近的极限为：<spanclass="math inline">\(\lim\limits_{x\rightarrow0^{-}}=-\infty,\lim\limits_{x\rightarrow 0^{+}}=\infty\)</span>。发现<span class="math inline">\(0\)</span> 附近的左极限和右极限不相等，所以<span class="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\(0\)</span> 附近的极限不存在。</p><p>通过总结发现，极限存在当且仅当此处的<strong>左极限和右极限存在且相等</strong>。也就是说，<span class="math display">\[\lim\limits_{x\rightarrow a^{-}}=\lim\limits_{x\rightarrow a^{+}}=L\]</span> 等价于 <span class="math display">\[\lim\limits_{x\rightarrow a}=L\]</span> 相反的，<strong>极限不存在</strong>，记作 <spanclass="math display">\[\lim\limits_{x\rightarrow a}\text{DNE}\]</span></p><h2 id="三明治定理夹逼定理">1.2   三明治定理(夹逼定理)</h2><p>如果对于所有在 <span class="math inline">\(a\)</span> 附近的 <spanclass="math inline">\(x\)</span> 都有 <spanclass="math inline">\(g(x)\leq f(x)\leq h(x)\)</span>，且 <spanclass="math inline">\(\lim\limits_{x\rightarrowa}g(x)=\lim\limits_{x\rightarrow a}h(x)=L\)</span>，则 <spanclass="math display">\[\lim\limits_{x\rightarrow a}f(x)=L\]</span></p><h2 id="求解-xrightarrow-a-时多项式的极限问题">1.3   求解 <spanclass="math inline">\(x\rightarrow a\)</span> 时多项式的极限问题</h2><p><strong>例题1</strong>：求解极限 <span class="math display">\[\lim\limits_{x\rightarrow -1}\frac{x^2-3x+2}{x-2}\]</span> 因为函数定义域包含 <spanclass="math inline">\(-1\)</span>，可以将 <spanclass="math inline">\(x=-1\)</span> 带入表达式中，得到这个极限为 <spanclass="math inline">\(-2\)</span>。</p><p><strong>例题2</strong>：求解极限 <span class="math display">\[\lim\limits_{x\rightarrow 2}\frac{x^2-3x+2}{x-2}\]</span> 我们发现直接将 <span class="math inline">\(x=2\)</span>带入，分母为 <spanclass="math inline">\(0\)</span>，不能这样求解。考虑对其因式分解，有<span class="math display">\[\lim\limits_{x\rightarrow2}\frac{x^2-3x+2}{x-2}=\lim\limits_{x\rightarrow2}\frac{(x-2)(x-1)}{x-2}=\lim\limits_{x\rightarrow 2}(x-1)=1\]</span> <strong>例题3</strong>：求解极限 <span class="math display">\[\lim\limits_{x\rightarrow 1}\frac{2x^2-x-6}{x(x-1)^3}\]</span> 我们不能直接带入 <spanclass="math inline">\(x=1\)</span>，尝试进行<strong>符号分析</strong>。其关键因子是<span class="math inline">\((x-1)^3\)</span>，当 <spanclass="math inline">\(x\rightarrow 1^+\)</span>时，其为正，并代入整个式子分析符号，有<spanclass="math inline">\(\frac{(-)}{(+)(+)}=(-)\)</span>；当 <spanclass="math inline">\(x\rightarrow 1^-\)</span>时，其为负，分析式子的符号，有<spanclass="math inline">\(\frac{(-)}{(+)(-)}=(+)\)</span>。因此，这个极限<strong>不存在</strong>，但是存在左极限和右极限：<span class="math display">\[\lim\limits_{x\rightarrow 1^-}\frac{2x^2-x-6}{x(x-1)^3}=-\infty \qquad\lim\limits_{x\rightarrow 1+}\frac{2x^2-x-6}{x(x-1)^3}=\infty\]</span> <strong>例题4</strong>：求解极限 <span class="math display">\[\lim\limits_{x\rightarrow 5}\frac{\sqrt{x^2-9}-4}{x-5}\]</span> 不能直接带入 <spanclass="math inline">\(x=5\)</span>，考虑进行<strong>分子有理化</strong>，即分子分母共同乘上<span class="math inline">\(\sqrt{x^2-9}-4\)</span>的<strong>共轭表达式</strong>，有 <span class="math display">\[\begin{aligned}\lim\limits_{x\rightarrow5}\frac{\sqrt{x^2-9}-4}{x-5}&amp;=\lim\limits_{x\rightarrow5}\frac{\sqrt{x^2-9}-4}{x-5}\times\frac{\sqrt{x^2-9}+4}{\sqrt{x^2-9}+4}\\&amp;=\lim\limits_{x\rightarrow 5}\frac{x^2-25}{(x-5)(\sqrt{x^2-9}+4)}\\&amp;=\lim\limits_{x\rightarrow 5}\frac{x+5}{\sqrt{x^2-9}+4}\\&amp;=\frac{5}{4}\end{aligned}\]</span></p><h2 id="求解-xrightarrow-infty-时多项式的极限问题">1.4   求解 <spanclass="math inline">\(x\rightarrow \infty\)</span>时多项式的极限问题</h2><p>对于一个有理函数的极限 <span class="math display">\[\lim\limits_{x\rightarrow \infty}\frac{p(x)}{q(x)}\]</span> 令 <span class="math inline">\(p_L(x)\)</span> 为函数 <spanclass="math inline">\(p(x)\)</span> 的最高次项，我们有 <spanclass="math display">\[\lim\limits_{x\rightarrow \infty}\frac{p(x)}{p_L(x)}=1\]</span> 事实上，对于任意的 <spanclass="math inline">\(n&gt;0\)</span>，<spanclass="math inline">\(C\)</span> 为常数，有 <spanclass="math display">\[\lim\limits_{x\rightarrow \infty}\frac{C}{x^n}=0\]</span> <strong>例题5</strong>：求解极限 <span class="math display">\[\lim\limits_{x\rightarrow \infty}\frac{x-8x^4}{7x^4+5x^3+2000x^2-6}\]</span> 我们找到分子的首项 <spanclass="math inline">\(-8x^4\)</span>，分母的首项 <spanclass="math inline">\(7x^4\)</span>，有 <span class="math display">\[\begin{aligned}\lim\limits_{x\rightarrow\infty}\frac{x-8x^4}{7x^4+5x^3+2000x^2-6}&amp;=\lim\limits_{x\rightarrow\infty}\frac{\dfrac{x-8x^4}{-8x^4}\times(-8x^4)}{\dfrac{7x^4+5x^3+2000x^2-6}{7x^4}\times 7x^4}\\&amp;=\lim\limits_{x\rightarrow\infty}\frac{-\dfrac{1}{8x^3}+1}{1+\dfrac{5}{7x}+\dfrac{2000}{7x^2}-\dfrac{6}{7x^4}}\times  \dfrac{-8x^4}{7x^4}\\&amp;=\frac{0+1}{1+0+0-0}\times \frac{-8}{7}\\&amp;=-\frac{8}{7}\end{aligned}\]</span> 一般地，考虑极限 <span class="math display">\[\lim\limits_{x\rightarrow \infty}\frac{p(x)}{q(x)}\]</span> 其中 <span class="math inline">\(p,q\)</span>为多项式，我们有：</p><ol type="1"><li>如果 <span class="math inline">\(p\)</span> 的次数等于 <spanclass="math inline">\(q\)</span>的次数，则极限是<strong>有限的且非零</strong>；</li><li>如果 <span class="math inline">\(p\)</span> 的次数大于 <spanclass="math inline">\(q\)</span> 的次数，则极限是 <spanclass="math inline">\(\infty\)</span> <strong>或</strong> <spanclass="math inline">\(-\infty\)</span>；</li><li>如果 <span class="math inline">\(p\)</span> 的次数等于 <spanclass="math inline">\(q\)</span> 的次数，则极限是 <spanclass="math inline">\(0\)</span>。</li></ol><h2 id="求解-xrightarrow--infty-时多项式的极限问题">1.5   求解 <spanclass="math inline">\(x\rightarrow -\infty\)</span>时多项式的极限问题</h2><p>求解 <span class="math inline">\(x\rightarrow -\infty\)</span>时的极限，答题思路和上面相仿，特殊地，需要考虑被开方数的<strong>正负性</strong>。</p><p><strong>例题6</strong>：求解极限 <span class="math display">\[\lim\limits_{x\rightarrow -\infty}\frac{\sqrt{4x^6+8}}{2x^3+6x+1}\]</span> 可以找到分母的首项 <spanclass="math inline">\(2x^3\)</span>，分子的首项 <spanclass="math inline">\(\sqrt{4x^6}\)</span>，特别注意 <spanclass="math inline">\(x&lt;0\)</span> 时，<spanclass="math inline">\(\sqrt{4x^6}=-2x^3\)</span>。有 <spanclass="math display">\[\begin{aligned}\lim\limits_{x\rightarrow-\infty}\frac{\sqrt{4x^6+8}}{2x^3+6x+1}&amp;=\lim\limits_{x\rightarrow\infty}\frac{\dfrac{\sqrt{4x^6+8}}{\sqrt{4x^6}}\times\sqrt{4x^6}}{\dfrac{2x^3+6x+1}{2x^3}\times 2x^3}\\&amp;=\lim\limits_{x\rightarrow\infty}\frac{\sqrt{\dfrac{4x^6+8}{4x^6}}}{\dfrac{2x^3+6x+1}{2x^3}}\times\frac{\sqrt{4x^6}}{2x^3}\\&amp;=\lim\limits_{x\rightarrow\infty}\frac{\sqrt{1+\dfrac{8}{4x^6}}}{1+\dfrac{6x}{2x^3}+\dfrac{1}{2x^3}}\times\frac{-2x^3}{2x^3}\\&amp;=\frac{\sqrt{1+0}}{1+0+0}\times (-1)\\&amp;=-1\end{aligned}\]</span></p><h1 id="二求解微分问题">二、求解微分问题</h1><h2 id="幂函数的导数">2.1   幂函数的导数</h2><p>事实上，当 <span class="math inline">\(a\)</span> 是任意实数时，<span class="math display">\[\frac{\mathrm{d}}{\mathrm{d}x}(x^a)=ax^{a-1}\]</span> 特殊地，如果 <span class="math inline">\(C\)</span>是常数，那么 <spanclass="math inline">\(\dfrac{\mathrm{d}}{\mathrm{d}x}(C)=0\)</span>。</p><p>如果 <span class="math inline">\(a=1\)</span>，有 <spanclass="math inline">\(\dfrac{\mathrm{d}}{\mathrm{d}x}(x)=1\)</span>。</p><p><strong>例子</strong>   <spanclass="math inline">\(\dfrac{\mathrm{d}}{\mathrm{d}x}(x^\frac{1}{3})=\dfrac{1}{3}x^{-\frac{2}{3}}\)</span>。</p><h2 id="求导法则">2.2   求导法则</h2><p>下面内容默认 <span class="math inline">\(f&#39;(x)\)</span> 为函数<span class="math inline">\(f(x)\)</span> 的导数，<spanclass="math inline">\(a\)</span> 为任意实数。</p><h3 id="函数的常数倍">2.2.1   函数的常数倍</h3><p>若 <span class="math inline">\(k\)</span> 为任意实数，<spanclass="math inline">\(f(x)=kx^a\)</span>，其导数为 <spanclass="math display">\[f&#39;(x)=kax^{a-1}\]</span></p><h3 id="函数的和与差">2.2.2   函数的和与差</h3><p>若 <span class="math inline">\(f(x)=g(x)\pm h(x)\)</span>，其导数为<span class="math display">\[f&#39;(x)=g&#39;(x)\pm h&#39;(x)\]</span></p><h3 id="乘积法则">2.2.3   乘积法则</h3><p><strong>乘积法则</strong>   若 <spanclass="math inline">\(h(x)=f(x)g(x)\)</span>，则其导数为 <spanclass="math display">\[h&#39;(x)=f&#39;(x)g(x)+f(x)g&#39;(x)\]</span> 用微分的形式表示，若 <spanclass="math inline">\(y=uv\)</span>，则 <span class="math display">\[\dfrac{\mathrm{d}y}{\mathrm{d}x}=v\dfrac{\mathrm{d}u}{\mathrm{d}x}+u\dfrac{\mathrm{d}v}{\mathrm{d}x}\]</span> 乘积法则可推广。若 <spanclass="math inline">\(y=uvw\)</span>，则 <span class="math display">\[\dfrac{\mathrm{d}y}{\mathrm{d}x}=\dfrac{\mathrm{d}u}{\mathrm{d}x}vw+u\dfrac{\mathrm{d}v}{\mathrm{d}x}w+uv\dfrac{\mathrm{d}w}{\mathrm{d}x}\]</span></p><h3 id="商法则">2.2.4   商法则</h3><p><strong>商法则</strong>   若函数 <spanclass="math inline">\(h(x)=\dfrac{f(x)}{g(x)}\)</span>，则其导数为 <spanclass="math display">\[h&#39;(x)=\dfrac{f&#39;(x)g(x)-f(x)g&#39;(x)}{(g(x))^2}\]</span> 用微分的形式表示，若 <span class="math inline">\(y=\dfracuv\)</span>，则 <span class="math display">\[\dfrac{\mathrm{d}y}{\mathrm{d}x}=\dfrac{v\dfrac{\mathrm{d}u}{\mathrm{d}x}-u\dfrac{\mathrm{d}v}{\mathrm{d}x}}{v^2}\]</span></p><h3 id="链式求导法则">2.2.5   链式求导法则</h3><p><strong>链式求导法则</strong>   若函数 <spanclass="math inline">\(h(x)=f(g(x))\)</span>，则其导数为 <spanclass="math display">\[h&#39;(x)=f&#39;(g(x))g&#39;(x)\]</span> 用微分的形式表示，若 <span class="math inline">\(y\)</span> 是<span class="math inline">\(u\)</span> 的函数，<spanclass="math inline">\(u\)</span> 是 <spanclass="math inline">\(x\)</span> 的函数，则 <spanclass="math display">\[\dfrac{\mathrm{d}y}{\mathrm{d}x}=\dfrac{\mathrm{d}y}{\mathrm{d}u}\dfrac{\mathrm{d}u}{\mathrm{d}x}\]</span> 链式求导法则可以推广，若 <spanclass="math inline">\(y\)</span> 是 <spanclass="math inline">\(u\)</span> 的函数，<spanclass="math inline">\(u\)</span> 是 <spanclass="math inline">\(v\)</span> 的函数，<spanclass="math inline">\(v\)</span> 是 <spanclass="math inline">\(x\)</span> 的函数，则 <spanclass="math display">\[\dfrac{\mathrm{d}y}{\mathrm{d}x}=\dfrac{\mathrm{d}y}{\mathrm{d}u}\dfrac{\mathrm{d}u}{\mathrm{d}v}\dfrac{\mathrm{d}v}{\mathrm{d}x}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 微积分学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>做题笔记[AGC002]</title>
      <link href="/post/2eaf91bf2ff2.html"/>
      <url>/post/2eaf91bf2ff2.html</url>
      
        <content type="html"><![CDATA[<p>做题笔记[AGC002]</p><h1 id="a---range-product">A - Range Product</h1><blockquote><p>标签：数学</p><p>难度：★☆☆☆☆</p></blockquote><h2 id="题目大意">题目大意</h2><p>给你两个整数 <span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> (<spanclass="math inline">\(a≤b\)</span>)。</p><p>判断 <span class="math inline">\(\prod\limits_{i=a}^b i\)</span>是正、负还是零。</p><h2 id="数据范围">数据范围</h2><p><span class="math inline">\(-10^9\le a\le b\le 10^9\)</span>。</p><h2 id="解题思路">解题思路</h2><p>判断正负性，经过 <span class="math inline">\(0\)</span> 的乘积为<span class="math inline">\(0\)</span>，再判断负数个数即可。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;=<span class="number">0</span>&amp;&amp;b&gt;=<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;Zero&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a&gt;<span class="number">0</span>||(b-a+<span class="number">1</span>)%<span class="number">2</span>==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;Positive&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Negative&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="b---box-and-ball">B - Box and Ball</h1><blockquote><p>标签：思维</p><p>难度：★★☆☆☆</p></blockquote><h2 id="题目大意-1">题目大意</h2><p>我们有<span class="math inline">\(N\)</span>个盒子，一开始，<spanclass="math inline">\(1\)</span>号盒子里有一个红球，其他每个盒子里都有一个白球。</p><p>逐一执行给定的 <span class="math inline">\(M\)</span> 操作。在第<span class="math inline">\(i\)</span> 次操作中，他会从 <spanclass="math inline">\(x_i\)</span> 盒子中随机选取一个球，然后将其放入<span class="math inline">\(y_i\)</span> 盒子中。</p><p>求所有操作完成后，可能装有红球的盒子数。</p><h2 id="数据范围-1">数据范围</h2><p><span class="math inline">\(2\le N,M\le 10^5,1\le x_i,y_i\leN\)</span>。</p><h2 id="解题思路-1">解题思路</h2><p>判断 <span class="math inline">\(1\)</span>号球可能到达的位置，每次移动将 <span class="math inline">\(y\)</span>盒子打上“可能”的标记，如果 <span class="math inline">\(x\)</span>盒子空了，就撤销 <span class="math inline">\(x\)</span>的“可能”标记即可。</p><h2 id="参考代码-1">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="type">int</span> n,m,sz[MAXN];</span><br><span class="line"><span class="type">bool</span> f[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sz[i]=<span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x,y,i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        sz[x]--;</span><br><span class="line">        sz[y]++;</span><br><span class="line">        f[y]|=f[x];</span><br><span class="line">        <span class="keyword">if</span>(!sz[x]) f[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans+=f[i];</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c---knot-puzzle">C - Knot Puzzle</h1><blockquote><p>标签：贪心、构造</p><p>难度：★★★☆☆</p></blockquote><h2 id="题目大意-2">题目大意</h2><p>我们有 <span class="math inline">\(N\)</span> 根绳子，第 <spanclass="math inline">\(i\)</span> 段的长度是 <spanclass="math inline">\(a_i\)</span>。起初，每条和相邻的绳子打上结，形成一条有<span class="math inline">\(N-1\)</span>个结的长绳。尝试通过重复执行以下操作来解开所有绳结：</p><ul><li>选择一条总长度至少为 <span class="math inline">\(L\)</span>的（相连）绳子，然后解开其中一个绳结。</li></ul><p>通过正确的操作是否可以解开所有的 <spanclass="math inline">\(N-1\)</span>个绳结？如果答案是肯定的，请找出一种可能的解结顺序。</p><h2 id="数据范围-2">数据范围</h2><p><span class="math inline">\(2\le N\le 10^5,1\le L,a_i\le10^9\)</span>。</p><h2 id="解题思路-2">解题思路</h2><p>考虑贪心。如果全部能解开，则最后解开的那一对相邻的绳子长度一定大于等于<spanclass="math inline">\(L\)</span>。我们找到这对绳子，从两边开始解开所有的绳子。</p><p>如果没有这样一对相邻的绳子，则判断无解。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="type">int</span> n,len,a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;len;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]+a[i<span class="number">-1</span>]&gt;=a[s]+a[s<span class="number">-1</span>]) s=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[s]+a[s<span class="number">-1</span>]&lt;len)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Possible&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s<span class="number">-1</span>;i++) cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=s;i--) cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;s<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="d---stamp-rally">D - Stamp Rally</h1><blockquote><p>标签：图论、kruskal 重构树</p><p>难度：★★★★☆</p></blockquote><h2 id="题目大意-3">题目大意</h2><p>有一个 <span class="math inline">\(N\)</span> 个顶点和 <spanclass="math inline">\(M\)</span> 条边的无向连通图。一共有 <spanclass="math inline">\(Q\)</span> 此询问，每次询问给定两个点 <spanclass="math inline">\(x,y\)</span>，要求是同这两个点开始走，一共走 <spanclass="math inline">\(z\)</span>个点，最小化所经过的边的权值最大值。</p><h2 id="数据范围-3">数据范围</h2><p><span class="math inline">\(3\le N,Q\le 10^5,N−1\le M\le 10^5,1\lea_i&lt;b_i\le N\)</span>。</p><h2 id="解题思路-3">解题思路</h2><p>因为要最小化路径最大权值，想到构建最小生成树，这样能保证连通图的最大边权最小。</p><p>因为要从两个顶点开始，一共走 <span class="math inline">\(z\)</span>条边，考虑构建 kruskal 重构树，利用其<strong>一条路径的最大边权在两点的LCA 位置处</strong>的性质，找到 <span class="math inline">\(x,y\)</span>的最近公共祖先，再判断 <span class="math inline">\(z\)</span>是否满足即可。</p><p>判断 <span class="math inline">\(z\)</span>是否满足，只需要再重构树上往祖先走的时候判断子树叶子节点个数即可。可利用倍增加速。时间复杂度<span class="math inline">\(O(Q\log n)\)</span>。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="type">int</span> n,m,dsu[MAXN],w[MAXN],f[MAXN][<span class="number">30</span>],tot,root,lim,dep[MAXN],sz[MAXN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">&#125;edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.z&lt;y.z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dsu[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> dsu[x]=<span class="built_in">find</span>(dsu[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>]=fa;</span><br><span class="line">    dep[u]=dep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(g[u].<span class="built_in">size</span>()==<span class="number">1</span>) sz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=lim;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[f[x][i]]&lt;=c) x=f[x][i];</span><br><span class="line">        <span class="keyword">if</span>(w[f[y][i]]&lt;=c) y=f[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> sz[x];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> sz[x]+sz[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;edge[i].x&gt;&gt;edge[i].y;</span><br><span class="line">        edge[i].z=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edge+<span class="number">1</span>,edge+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++) dsu[i]=i;</span><br><span class="line">    tot=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>,i=<span class="number">1</span>;t&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=edge[i].x,y=edge[i].y;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(x)!=<span class="built_in">find</span>(y))&#123;</span><br><span class="line">            t++,tot++;</span><br><span class="line">            g[<span class="built_in">find</span>(x)].<span class="built_in">push_back</span>(tot);</span><br><span class="line">            g[tot].<span class="built_in">push_back</span>(<span class="built_in">find</span>(x));</span><br><span class="line">            g[<span class="built_in">find</span>(y)].<span class="built_in">push_back</span>(tot);</span><br><span class="line">            g[tot].<span class="built_in">push_back</span>(<span class="built_in">find</span>(y));</span><br><span class="line">            w[tot]=edge[i].z;</span><br><span class="line">            dsu[<span class="built_in">find</span>(x)]=tot;</span><br><span class="line">            dsu[<span class="built_in">find</span>(y)]=tot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root=tot;</span><br><span class="line">    <span class="built_in">dfs</span>(root,<span class="number">0</span>);</span><br><span class="line">    lim=<span class="built_in">log2</span>(n*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=lim;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)&#123;</span><br><span class="line">            f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> Q;</span><br><span class="line">    cin&gt;&gt;Q;</span><br><span class="line">    w[<span class="number">0</span>]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=m;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(x,y,mid)&gt;=z) r=mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="e---candy-piles">E - Candy Piles</h1><blockquote><p>标签：博弈论、思维</p><p>难度：★★★★★</p></blockquote><h2 id="题目大意-4">题目大意</h2><p>桌子上有 <span class="math inline">\(N\)</span> 堆糖果，第 <spanclass="math inline">\(i\)</span> 堆里有 <spanclass="math inline">\(a_i\)</span> 颗糖果。</p><p>两个人轮流玩游戏，在每个回合中，当前玩家必须执行以下两个操作中的一个：</p><ol type="1"><li>选择剩余糖果数量最多的一堆，然后吃掉这一堆中的所有糖果。</li><li>从每堆糖果中吃掉一颗或多颗糖果。</li></ol><p>吃掉桌上最后一颗糖果的玩家输掉游戏。如果双方都以最佳方式玩游戏，请确定哪一方会获胜。</p><h2 id="数据范围-4">数据范围</h2><p><span class="math inline">\(1\le N\le 10^5,1\le a_i\le10^9\)</span>。</p><h2 id="解题思路-4">解题思路</h2><p>很巧妙的人类智慧题！</p><p>我们考虑将这个棋局表示为一个二维平面，第 <spanclass="math inline">\(i\)</span> 列表示第 <spanclass="math inline">\(i\)</span> 堆糖果，每列从下到上有 <spanclass="math inline">\(j\)</span> 个添上的格子，表示第 <spanclass="math inline">\(i\)</span> 堆糖果有 <spanclass="math inline">\(j\)</span>个。如下图：左图表示拿走最多的一堆（操作 1），右图表示每堆拿走一颗（操作2）。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=2b5yyZIi" /></p><p>实际上，我们将问题转化成了：每次从左或下消除一列或一行，直到无法消去。问谁会赢。</p><p>将消去一列操作视为向右走一格，消去一行操作视为向上走一格，可以表示成下图。双方交替进行，红色表示先手，蓝色表示后手。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=22cFH3sJ" /></p><p>可以看到，只要走到边界，就会失败，所以给边界上的点一个“必败”的标记，考虑其他的点：</p><ul><li>如果这个点上方或右方有必胜点，则此点必胜（对于先手而言，下同）；</li><li>否则此点必败。</li></ul><p>如下图所示，红点为必败点，蓝点为必胜点。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=yRKKGDNu" /></p><p>不难发发现，<strong>一个点和其右上方的点属性相同</strong>。利用这个性质，我们可以从起点一直向右上方走，直到不能走，判断这个点的胜负性。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=cIGm5e6V" /></p><p>发现，对于靠近边界，不能向右上方走的点，如果其上方或右方能延伸的格子数有一个为奇数，则为必胜点，否则先手必败。</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="type">int</span> n,a[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="type">int</span> p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[p+<span class="number">1</span>]&gt;=p+<span class="number">1</span>) p++;</span><br><span class="line">    <span class="type">int</span> p1=<span class="number">0</span>,p2=a[p]-p;</span><br><span class="line">    <span class="keyword">while</span>(a[p+p1+<span class="number">1</span>]&gt;=p) p1++;</span><br><span class="line">    <span class="keyword">if</span>((p1|p2)&amp;<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;First&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Second&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="f---leftmost-ball">F - Leftmost Ball</h1><blockquote><p>标签：组合数学、动态规划</p><p>难度：★★★★★</p></blockquote><h2 id="题目大意-5">题目大意</h2><p>一共有 <span class="math inline">\(N×K\)</span> 个球，每种他喜欢的<span class="math inline">\(N\)</span> 种颜色有<spanclass="math inline">\(K\)</span>个。他会把所有的球从左到右任意排成一排。然后，对于每种颜色的球，他都会把最左边的那个颜色的球涂成<span class="math inline">\(0\)</span> 号颜色（一种不同于 <spanclass="math inline">\(N\)</span> 种原始颜色的颜色）。</p><p>求涂色后，球的颜色可能有多少个序列（取模）。</p><h2 id="数据范围-5">数据范围</h2><p><span class="math inline">\(1\le N,K\le 000\)</span>。</p><h2 id="解题思路-5">解题思路</h2><p>组合问题考虑动态规划。我们设状态 <spanclass="math inline">\(f_{i,j}\)</span> 表示我们放置了 <spanclass="math inline">\(i\)</span> 个白球和 <spanclass="math inline">\(j\)</span> 个<strong>类</strong>颜色的球，显然<span class="math inline">\(i\ge j\)</span>。考虑转移：</p><ul><li>若当前位置放一个白球，则有转移方程：</li></ul><p><span class="math display">\[f_{i-1,j} \to f_{i,j}\]</span></p><ul><li>若当前位置放一个有颜色的球。根据定义，我们一次安排一类 <spanclass="math inline">\(k-1\)</span>个同颜色的球的位置，那么这个位置是一个<strong>没有出现过的颜色的球</strong>。因为是从<span class="math inline">\(f_{i,j-1}\)</span>转移过来，所以这个球的颜色有 <span class="math inline">\(n-j+1\)</span>种。当前位置放一个，前面有一个此颜色转换成的白球，后面此种颜色共安排<span class="math inline">\(k-2\)</span> 个，则可以安排在后面 <spanclass="math inline">\(nk-i-(j-i)(k-1)-1\)</span> 个空位种的 <spanclass="math inline">\(k-2\)</span> 个位置，则有转移方程：</li></ul><p><span class="math display">\[f_{i,j-1}\times (n-j+1)\times {nk-i-(j-1)(k-1)-1\choose k-2}\to f_{i,j}\]</span></p><p>边界：<span class="math inline">\(f_{0,0}=1\)</span>，答案：<spanclass="math inline">\(f_{n,n}\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(nk)\)</span>。</p><h2 id="参考代码-5">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 2005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll f[MAXN][MAXN],mul[MAXN*MAXN],inv[MAXN*MAXN];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) w=w*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;<span class="number">0</span>||n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> mul[n]*inv[m]%mod*inv[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mul[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k*n;i++) mul[i]=mul[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[n*k]=<span class="built_in">qpow</span>(mul[n*k],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k*n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) inv[i]=inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=j) f[i][j]+=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j) f[i][j]+=f[i][j<span class="number">-1</span>]*(n-j+<span class="number">1</span>)%mod*<span class="built_in">C</span>(n*k-i-(j<span class="number">-1</span>)*(k<span class="number">-1</span>)<span class="number">-1</span>,k<span class="number">-2</span>)%mod;</span><br><span class="line">            f[i][j]%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 做题笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>做题笔记[AGC001]</title>
      <link href="/post/887b839b27ed.html"/>
      <url>/post/887b839b27ed.html</url>
      
        <content type="html"><![CDATA[<p>做题笔记[AGC001]</p><h1 id="a---bbq-easy">A - BBQ Easy</h1><blockquote><p>标签：贪心</p><p>难度：★☆☆☆☆</p></blockquote><h2 id="题目大意">题目大意</h2><p>将 <span class="math inline">\(2n\)</span> 个数分为 <spanclass="math inline">\(n\)</span> 组，每个数有值 <spanclass="math inline">\(L_i\)</span>，每组两个数，每个数都被且只被分到一组。一组的权值是两个数值的最小值，分组方案的值就是每组值之和，求分组方案的最大值。</p><h2 id="数据范围">数据范围</h2><p><span class="math inline">\(1\le n\le 100,1\le L_i\le100\)</span>。</p><h2 id="解题思路">解题思路</h2><p>考虑贪心。将数组排序后按顺序两两分组即可。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 205</span></span><br><span class="line"><span class="type">int</span> n,a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    n*=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i+=<span class="number">2</span>) ans+=a[i];</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="b---mysterious-light">B - Mysterious Light</h1><blockquote><p>标签：思维</p><p>难度：★★★☆☆</p></blockquote><h2 id="题目大意-1">题目大意</h2><p>有一个边长为 <span class="math inline">\(N\)</span>的三枚镜子构成的正三角形，顶点为 <span class="math inline">\(A, B,C\)</span>。有一束光线，放在 <span class="math inline">\(AB\)</span>段的 <span class="math inline">\(P\)</span> 点上，使得 <spanclass="math inline">\(AP=X\)</span>。这个步枪将会沿着平行于 <spanclass="math inline">\(BC\)</span> 的方向发射一道光。</p><p>光以直线传播，以镜子的形式反射，也会被自己的轨迹反射，当光回到初始点的时候，光被吸收。</p><p>下面的图显示了当 <span class="math inline">\(N=5, x=2\)</span>时的光轨迹。</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=2CMCJl5q" /></p><p>给定 <span class="math inline">\(N\)</span> 和 <spanclass="math inline">\(x\)</span>，求出光线的总长度。</p><h2 id="数据范围-1">数据范围</h2><p><span class="math inline">\(2≤N≤10^{12}\)</span>，<spanclass="math inline">\(1≤x≤N-1\)</span>。</p><h2 id="解题思路-1">解题思路</h2><p>把这个三角形看成被对角线分割的正方形，手动模拟长度，可以发现每一段的长度是一个辗转相减的过程，最后剩下的那一段就是<span class="math inline">\((N,x)\)</span>。可以得到答案就是 <spanclass="math inline">\(3(N-(N,x))\)</span>。</p><h2 id="参考代码-1">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n,x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    cout&lt;&lt;<span class="number">3ll</span>*(n-__gcd(x,n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c---shorten-diameter">C - Shorten Diameter</h1><blockquote><p>标签：树论、枚举</p><p>难度：★★☆☆☆</p></blockquote><h2 id="题目大意-2">题目大意</h2><p>给你一棵 <span class="math inline">\(N\)</span> 个点的无向树，定义点<span class="math inline">\(u\)</span> 和 <spanclass="math inline">\(v\)</span> 之间的距离是从 <spanclass="math inline">\(u\)</span> 到 <spanclass="math inline">\(v\)</span> 的简单路径上的边数。</p><p>你需要删除一些点，使树的直径小于等于 <spanclass="math inline">\(K\)</span>，当且仅当删除某点不会对树的联通性产生影响时才可以删除。</p><p>问至少删除多少点才可以满足要求。</p><h2 id="数据范围-2">数据范围</h2><p><span class="math inline">\(2≤N≤2000\)</span>，<spanclass="math inline">\(1≤K≤N-1\)</span>。</p><h2 id="解题思路-2">解题思路</h2><p>因为 <span class="math inline">\(N\)</span>比较小，我们考虑枚举每个点，计算以这个点为中心时，最少删去多少个点才能满足要求，具体地：</p><ul><li>若 <span class="math inline">\(N\)</span>为偶数，我们设这个点为中心，遍历整张图，删去距离这个点超过 <spanclass="math inline">\(k/2\)</span> 的点。</li><li>若 <span class="math inline">\(N\)</span>为奇数，我们设这个点连接的某一条边为中心（枚举），遍历整张图，删去距离这个点超过<span class="math inline">\(\lfloor k/2 \rfloor\)</span>。</li></ul><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 2005</span></span><br><span class="line"><span class="type">int</span> n,k,cnt,ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> dis)</span></span>&#123;</span><br><span class="line">    cnt+=(dis&gt;k/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u,dis+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x,y,i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">                cnt=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(v,u,<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">dfs</span>(u,v,<span class="number">0</span>);</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v,u,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="d---arrays-and-palindrome">D - Arrays and Palindrome</h1><blockquote><p>标签：构造、回文串</p><p>难度：★★★★☆</p></blockquote><h2 id="题目大意-3">题目大意</h2><p>给定一个长 <span class="math inline">\(m\)</span> 的序列 <spanclass="math inline">\(A\)</span>，和参数 <spanclass="math inline">\(n=\sum\limits_{i=1}^mA_i\)</span>，构造两个正整数数列 <spanclass="math inline">\(a,b\)</span>，满足：</p><ul><li><span class="math inline">\(a\)</span> 数列的数字总和是 <spanclass="math inline">\(N\)</span> 且是 <spanclass="math inline">\(A\)</span> 序列的一个排列；</li><li><span class="math inline">\(b\)</span> 数列的数字总和是 <spanclass="math inline">\(N\)</span>；</li><li>如果存在某个数列 <span class="math inline">\(s\)</span>满足以下两个条件， 则 <span class="math inline">\(s\)</span>的所有元素必定相同：<ul><li>对于 <span class="math inline">\(s\)</span> 的最开始的 <spanclass="math inline">\(a_1\)</span> 个元素，接下来的 <spanclass="math inline">\(a_2\)</span> 个元素，更后面的 <spanclass="math inline">\(a_3\)</span> 个，等等，都构成回文串；</li><li>对于 <span class="math inline">\(s\)</span> 的最开始的 <spanclass="math inline">\(b_1\)</span> 个元素，接下来的 <spanclass="math inline">\(b_2\)</span> 个元素，更后面的 <spanclass="math inline">\(b_3\)</span> 个，等等，都构成回文串。</li></ul></li></ul><h2 id="数据范围-3">数据范围</h2><p><span class="math inline">\(1\le N,A_i\le 10^5,1\le M\le100\)</span>。</p><h2 id="解题思路-3">解题思路</h2><p>一道很好的构造题。</p><p>考虑构成一个长度为 <span class="math inline">\(n\)</span>的回文串，会有 <span class="math inline">\(n/2\)</span>个相等关系。而让所有元素相等，必须交叉安排两个数组，使得串首尾都留出一个接口，如下图：</p><p><img src="https://sy.hhwdd.com/RequireFile.do?fid=Dm0o2AWB" /></p><p>不难发现，如果 <span class="math inline">\(A\)</span>中有大于两个长度为奇数的串，就无法满足制约关系。对于合法的解，不妨将长度为奇数的串转到两边，然后让<span class="math inline">\(b\)</span> 数组差 <spanclass="math inline">\(a\)</span> 的空子安排就好。</p><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="type">int</span> n,m,a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        cnt+=(a[i]&amp;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="keyword">if</span>(a[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>) <span class="built_in">swap</span>(a[i],a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;<span class="number">1</span>;i--) <span class="keyword">if</span>(a[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=m) <span class="built_in">swap</span>(a[i],a[m]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="number">1</span>) cout&lt;&lt;<span class="number">2</span>&lt;&lt;endl&lt;&lt;a[<span class="number">1</span>]<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">1</span>]==<span class="number">1</span>) cout&lt;&lt;m<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;a[<span class="number">1</span>]<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;m;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;a[m]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="e---bbq-hard">E - BBQ Hard</h1><blockquote><p>标签：组合计数、动态规划</p><p>难度：★★★★☆</p></blockquote><h2 id="题目大意-4">题目大意</h2><p>有 <span class="math inline">\(n\)</span> 个数对 <spanclass="math inline">\((a_i, b_i)\)</span>，求</p><p><span class="math display">\[\sum_{i=1}^{n}\sum_{j=i + 1}^{n}{a_i+b_i+a_j+b_j \choose a_i+a_j}\]</span></p><p>答案对 <span class="math inline">\(10 ^ 9 + 7\)</span> 取模。</p><h2 id="数据范围-4">数据范围</h2><p><span class="math inline">\(2\le N\le 2\times 10^5,1\le A_i,B_i\le2000\)</span>。</p><h2 id="解题思路-4">解题思路</h2><p>首先考虑一个组合式 <span class="math inline">\(x+y\choose x\)</span>的几何意义，就是从点 <span class="math inline">\((0,0)\)</span> 走到<spanclass="math inline">\((x,y)\)</span>，每一步只能向右或向上走的方案数。这个式子是可以转移的：<span class="math display">\[{x+y\choose x }={x+y-1\choose x}+{x+y\choose x-1}\]</span> 单独求一次可以在 <spanclass="math inline">\(O(A_iB_i)\)</span>的时间求出来。现在考虑题目中的式子，也就是说对于每个 <spanclass="math inline">\(1\le i&lt;j\le n\)</span>，求从 <spanclass="math inline">\((0,0)\)</span> 按照上述方案走到 <spanclass="math inline">\((a_i+a_j,b_i+b_j)\)</span> 的方案数。</p><p>为了简化思考，我们现在改变一下表述方式：对于每个 <spanclass="math inline">\(1\le i&lt;j\le n\)</span>，求从 <spanclass="math inline">\((-a_j,-b_j)\)</span> 走到 <spanclass="math inline">\((a_i,b_i)\)</span>，即向左下平移，但是大小不变。我们以<span class="math inline">\((a_i,a_j)\)</span>为主元，求解其他点（负的）到这个点的方案和即可。</p><p>我们考虑动态规划。开始给每个负点 <spanclass="math inline">\((-a_i,-b_i)\)</span> <spanclass="math inline">\(1\)</span> 的权值，设计 <spanclass="math inline">\(f_{i,j}\)</span>表示从左下角走到这个点的方案数，求解即可。</p><p>注意上述状态求解了所有的 <span class="math inline">\(i,j\)</span>的解，我们需要删去 <span class="math inline">\(i,i\)</span>的解，通过组合计数可得这部分要删去的解的个数是 <spanclass="math inline">\(\sum\limits_{i=1}^n{2a_i+2b_2\choose2a_i}\)</span>。因为<span class="math inline">\(i,j\)</span> 和 <spanclass="math inline">\(j,i\)</span> 算重，需要将答案数除以 <spanclass="math inline">\(2\)</span>。</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXA 2005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll f[MAXA&lt;&lt;<span class="number">1</span>][MAXA&lt;&lt;<span class="number">1</span>],n,a[MAXN],b[MAXN];</span><br><span class="line">ll maxa,maxb,ans;</span><br><span class="line">ll mul[MAXA&lt;&lt;<span class="number">2</span>],inv[MAXA&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mul[n]*inv[m]%mod*inv[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) w=w*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mul[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4009</span>*<span class="number">2</span>;i++) mul[i]=mul[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[<span class="number">4009</span>*<span class="number">2</span>]=<span class="built_in">qpow</span>(mul[<span class="number">4009</span>*<span class="number">2</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4009</span>*<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) inv[i]=inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">        f[<span class="number">2005</span>-a[i]][<span class="number">2005</span>-b[i]]++;</span><br><span class="line">        maxa=<span class="built_in">max</span>(maxa,a[i]);</span><br><span class="line">        maxb=<span class="built_in">max</span>(maxb,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2005</span>-maxa;i&lt;=<span class="number">2005</span>+maxa;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2005</span>-maxb;j&lt;=<span class="number">2005</span>+maxb;j++)&#123;</span><br><span class="line">            f[i][j]=(f[i][j]+f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=(ans+f[<span class="number">2005</span>+a[i]][<span class="number">2005</span>+b[i]])%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=(ans-<span class="built_in">C</span>((a[i]+b[i])&lt;&lt;<span class="number">1</span>,a[i]&lt;&lt;<span class="number">1</span>))%mod;</span><br><span class="line">    ans=<span class="number">1ll</span>*ans*inv[<span class="number">2</span>]%mod;</span><br><span class="line">    ans=(ans%mod+mod)%mod;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="f---wide-swap">F - Wide Swap</h1><blockquote><p>标签：思维、拓扑排序、线段树</p><p>难度：★★★★★</p></blockquote><h2 id="题目大意-5">题目大意</h2><p>给出一个元素集合为 <spanclass="math inline">\(\{1,2,\dots,N\}\)</span> 的排列 <spanclass="math inline">\(P\)</span>，当有 <spanclass="math inline">\(i,j\)</span> <span class="math inline">\((1\leqi&lt;j\leq N)\)</span> 满足 <span class="math inline">\(j-i\geqK\)</span> <span class="math inline">\((1\leq K\leq N-1)\)</span> 且<span class="math inline">\(|P_{i}-P_{j}|=1\)</span>时，可以交换 <spanclass="math inline">\(P_{i}\)</span> 和 <spanclass="math inline">\(P_{j}\)</span>。</p><p>求：可能排列中字典序最小的排列。</p><h2 id="数据范围-5">数据范围</h2><p><span class="math inline">\(1\leq N\leq 5\times10^5\)</span> 。</p><h2 id="解题思路-5">解题思路</h2><p>考虑按照上述方式交换元素有什么特殊性质。</p><p>我们建立 <span class="math inline">\(P\)</span> 的反置换 <spanclass="math inline">\(Q\)</span>，即 <spanclass="math inline">\(P_{Q_i}=i\)</span>，将 <spanclass="math inline">\(P_i\)</span> 的值作为 <spanclass="math inline">\(Q\)</span> 的下标，<spanclass="math inline">\(i\)</span> 作为 <spanclass="math inline">\(Q\)</span> 的值。不难发现，可以交换 <spanclass="math inline">\(Q_i\)</span> 和 <spanclass="math inline">\(Q_{i+1}\)</span> 的条件是 <spanclass="math inline">\(|Q_i-Q_{i+1}|\le K\)</span>。</p><p>通过人类的智慧思考发现，若存在一组 <span class="math inline">\(1\lei&lt;j\le N\)</span>，满足 <spanclass="math inline">\(|Q_i-Q_j|&gt;K\)</span>，不管怎样交换，这两个数的<strong>相对位置不会改变</strong>。</p><p>这个性质放回到 <span class="math inline">\(P\)</span>中，等价于：<span class="math inline">\(\forall 1\le i \leN,j\in(i-K,i+k),i\not=j\)</span>，若 <spanclass="math inline">\(P_i\)</span> 和 <spanclass="math inline">\(P_j\)</span> 满足偏序关系 <spanclass="math inline">\(P_i&lt;P_j\)</span>，则无论怎样交换，最后在 <spanclass="math inline">\(i,j\)</span> 位置上的数仍满足偏序关系 <spanclass="math inline">\(P_i&lt;P_j\)</span>。</p><blockquote><p>例子 <span class="math inline">\(\quad\)</span> 对于排列 <spanclass="math inline">\(P=\{4,5,7,8,3,1,2,6\}\)</span>，有 <spanclass="math inline">\(P_2=5,P_3=7\)</span>，在 <spanclass="math inline">\(K=3\)</span>的情况下，无论怎样交换，两个位置上的数仍满足小于关系。例如交换成 <spanclass="math inline">\(P&#39;=\{1,2,6,7,5,3,4,8\}\)</span>，满足 <spanclass="math inline">\(2&lt;6\)</span>。</p></blockquote><p>这样，我们可以找出所有的偏序关系，建图后通过拓扑排序，就可以知道这些数的最小排列。</p><p>例如，我们按照大于关系见图，即找到下标 <spanclass="math inline">\((i-K,i+K)\)</span> 内比 <spanclass="math inline">\(P_i\)</span> 小的数连边，按照拓扑顺序给下标从<span class="math inline">\(N\)</span> 到 <spanclass="math inline">\(1\)</span> 赋值。</p><p>但是这个图是 <span class="math inline">\(O(NK)\)</span>大小的，无法建图，我们利用这道题的特殊性质：每个点可能连出边的节点范围是<spanclass="math inline">\((i-K,i+K)\)</span>。一开始没有入度的点就是这个范围内的最大值，可以利用线段树查找。然后在左右子区间找区间最大值，再检查是否合法即可（见代码）。</p><p>时间复杂度 <span class="math inline">\(O(N\log N)\)</span>。</p><h2 id="参考代码-5">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 500005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((tree[p].l+tree[p].r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (p&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (p&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">int</span> n,k,a[MAXN],ans[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,maxx,pos;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[ls].maxx&gt;tree[rs].maxx)&#123;</span><br><span class="line">        tree[p].maxx=tree[ls].maxx;</span><br><span class="line">        tree[p].pos=tree[ls].pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tree[p].maxx=tree[rs].maxx;</span><br><span class="line">        tree[p].pos=tree[rs].pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].l=l,tree[p].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[p].maxx=a[l];</span><br><span class="line">        tree[p].pos=l;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,ls);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pii <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> &#123;-inf,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r) <span class="keyword">return</span> &#123;tree[p].maxx,tree[p].pos&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(l,r,rs);</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(l,r,ls);</span><br><span class="line">    pii lc=<span class="built_in">query</span>(l,r,ls),rc=<span class="built_in">query</span>(l,r,rs),c;</span><br><span class="line">    <span class="keyword">if</span>(lc.first&gt;rc.first) c=lc;</span><br><span class="line">    <span class="keyword">else</span> c=rc;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> goal,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].l==tree[p].r)&#123;</span><br><span class="line">        tree[p].maxx=-inf;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(goal&lt;=mid) <span class="built_in">modify</span>(goal,ls);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(goal,rs);</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chk</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    pii now=<span class="built_in">query</span>(<span class="built_in">max</span>(<span class="number">1</span>,p-k+<span class="number">1</span>),<span class="built_in">min</span>(p+k<span class="number">-1</span>,n),<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(now.second==p&amp;&amp;now.first!=-inf) q.<span class="built_in">push</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">chk</span>(i);</span><br><span class="line">    <span class="type">int</span> now=n;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        ans[u]=now--;</span><br><span class="line">        <span class="built_in">modify</span>(u,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> lpos=<span class="built_in">query</span>(<span class="built_in">max</span>(<span class="number">1</span>,u-k+<span class="number">1</span>),u<span class="number">-1</span>,<span class="number">1</span>).second;</span><br><span class="line">        <span class="type">int</span> rpos=<span class="built_in">query</span>(u+<span class="number">1</span>,<span class="built_in">min</span>(u+k<span class="number">-1</span>,n),<span class="number">1</span>).second;</span><br><span class="line">        <span class="built_in">chk</span>(lpos);<span class="built_in">chk</span>(rpos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 做题笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟退火</title>
      <link href="/post/cfd51e5a3eb8.html"/>
      <url>/post/cfd51e5a3eb8.html</url>
      
        <content type="html"><![CDATA[<p>模拟退火</p><h1 id="一模拟退火">一、模拟退火</h1><p>模拟退火算法用于计算运算量大或随机概率较高的多峰函数最值问题，在多次退火下，正确的概率表现的还是非常出色的。</p><h2 id="quad-劣解的接受与-metropolis-准则">1.1 <spanclass="math inline">\(\quad\)</span> 劣解的接受与 Metropolis 准则</h2><p>爬山算法只能应用于单峰函数，因为它每次只在附近只寻找更加优秀的解。放在多峰函数下容易陷入局部最大值，而无法找到全局最大值。</p><p>不同于爬山算法，在模拟退火算法中，我们在当前位置的一定范围内随机一个位置进行决策。如果这个决策比现在的决策更加优秀，我们无条件地接受；如果这个决策不如当前的决策我们以<strong>某种概率接受</strong>这个劣解。</p><p>具体地，我们像冶金工业退火一样，一开始，我们有一个<strong>温度</strong><spanclass="math inline">\(T\)</span>，表示当前的活跃性。这个温度随着随机次数的增加而降低，当最终小于某一个温度<span class="math inline">\(t_0\)</span> 时就终止退火。</p><p>我们设接受一个比当前解劣 <span class="math inline">\(\DeltaE\)</span> 的劣解的概率为 <span class="math inline">\(P(\DeltaE)\)</span>。根据 Metropolis准则，我们划定这个概率，并让其与当前温度有关。即表示：随机次数较小时，我们有更大概率接受劣解；随机次数过多时，我们有较小的概率接受劣解。这样既能保证向着最大值的方向查找，又能避免陷入局部最大值。</p><p><strong>Metropolis 准则</strong> <spanclass="math inline">\(\quad\)</span> 当前温度为 <spanclass="math inline">\(T\)</span> 时，对于新状态 <spanclass="math inline">\(S&#39;\)</span> 与当前最优状态 <spanclass="math inline">\(S\)</span> 的关于最优值的差为 <spanclass="math inline">\(\Delta E\ge0\)</span>，则发生状态转移（接受新状态）的概率为： <spanclass="math display">\[P(\Delta E)=\begin{cases}1,&amp;S&#39;\text{比} S \text{更优,} \\e^{\frac{-\Delta E}{T}}, &amp; \text{otherwise.}\end{cases}\]</span></p><p><imgsrc="https://oi-wiki.org/misc/images/simulated-annealing.gif" /></p><h2 id="quad-算法的实现">1.2 <span class="math inline">\(\quad\)</span>算法的实现</h2><p>一开始，我们有三个参数：</p><ul><li>初始温度 <span class="math inline">\(T_0\)</span>；</li><li>降温系数 <spanclass="math inline">\(d\)</span>，即每经过依次随机，温度变为 <spanclass="math inline">\(T_0d\)</span>，<spanclass="math inline">\(d\)</span> 一般为趋近于 <spanclass="math inline">\(1\)</span> 的小数；</li><li>终止温度 <span class="math inline">\(T_k\)</span>。</li></ul><p>对于每次随机，我们在当前最优解的附近随机新状态（随机范围也与当前温度有关），经计算后依靠Metropolis 准则决定是否接受。</p><p>在依靠 Metropolis 准则决策时需要注意：</p><ul><li>在 C++ 语言中，我们可以用 <code>cmath</code> 库中的 <code>exp</code>函数计算以 <span class="math inline">\(e\)</span>为底的指数函数。具体地，可以用 <code>exp(-E/T)</code> 表示 <spanclass="math inline">\(e^{\frac{-\Delta E}{T}}\)</span>；</li><li>注意计算接受劣解的概率时 <span class="math inline">\(e\)</span>的指数是<strong>负数</strong>；</li><li>根据函数图像可知，对于函数 <spanclass="math inline">\(f(x)=e^x(x&lt;0)\)</span> 的值域是 <spanclass="math inline">\((0,1)\)</span>。所以我们可以将 <spanclass="math inline">\(e^{\frac{-\Delta E}{T}}\)</span> 与一个在 <spanclass="math inline">\((0,1)\)</span>范围内的随机数比较。需要注意的是，因为随机次数越多，<spanclass="math inline">\(T\)</span> 越小，<spanclass="math inline">\(\frac{-\Delta E}{T}\)</span> 也越小，<spanclass="math inline">\(f(x)\)</span> 的函数值也越趋近于 <spanclass="math inline">\(0\)</span>，接受的概率也应该越低。所以，<strong>无论求最大值还是最小值，都只能依靠<code>exp(-E/T) &gt;= randFromRange(0,1)</code>或其他单调判断</strong>来决策，<strong>注意不等号方向和随机值范围，否则有概率退化成爬山算法</strong>。其中<code>randFromRange</code> 函数是在 <spanclass="math inline">\((l,r)\)</span> 范围内生成随机数。</li></ul><p>一般利用模拟退火解决问题，通常有如下设置：</p><ul><li><span class="math inline">\(T_0\)</span> 一般取 <spanclass="math inline">\([2000,3000]\)</span> 中的数；</li><li><span class="math inline">\(d\)</span> 通常取 <spanclass="math inline">\(0.999\)</span>，这个值取决于不同题目；</li><li><span class="math inline">\(T_k\)</span> 通常取 <spanclass="math inline">\([10^{-16},10^{-5}]\)</span> 之间；</li><li>通常情况下会进行多轮退火。每轮结束后不必要清空最优值，只需要重置温度等参数即可。</li></ul><h1 id="二例题练习">二、例题练习</h1><h2 id="quad-分金币">2.1 <span class="math inline">\(\quad\)</span>分金币</h2><p>题目来源：<ahref="https://www.luogu.com.cn/problem/P3878">TJOI2010，洛谷P3878</a></p><blockquote><p><strong>例题</strong> <span class="math inline">\(\quad\)</span>现在有 <span class="math inline">\(n\)</span> 枚金币，第 <spanclass="math inline">\(i\)</span> 枚金币的价值为 <spanclass="math inline">\(v_i\)</span>。现在要把它们分成两部分，要求这两部分金币数目之差不超过<spanclass="math inline">\(1\)</span>，求这样分成的两部分金币的价值之差的最小值。</p></blockquote><p>考虑模拟退火，先把原序列随便分成两个部分，之后随机交换两个部分中的两个数。</p><p>核心代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> temp=<span class="number">2333</span>;<span class="comment">//初始温度</span></span><br><span class="line">    <span class="keyword">while</span>(temp&gt;=<span class="number">1e-15</span>)&#123;<span class="comment">//终止温度</span></span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">rnd</span>()%mid+<span class="number">1</span>;<span class="comment">//在两个部分随机一个数交换</span></span><br><span class="line">        <span class="type">int</span> y=<span class="built_in">rnd</span>()%(n-mid)+mid+<span class="number">1</span>;</span><br><span class="line">        ll dis=<span class="built_in">abs</span>(s1-a[x]+a[y]-(s2-a[y]+a[x]));<span class="comment">//计算新贡献</span></span><br><span class="line">        ll D=dis-ans;</span><br><span class="line">        <span class="keyword">if</span>(D&lt;<span class="number">0</span>)&#123;<span class="comment">//优解，注意D和上文定义的E是相反数，D是负数表示的是解较优</span></span><br><span class="line">            ans=dis;</span><br><span class="line">            s1=s1-a[x]+a[y];</span><br><span class="line">            s2=s2-a[y]+a[x];</span><br><span class="line">            <span class="built_in">swap</span>(a[x],a[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span>(D/temp)&gt;<span class="number">1.</span>*(<span class="built_in">rnd</span>()%<span class="number">100000</span>)/<span class="number">100000</span>)&#123;<span class="comment">//劣解，注意随机范围和不等号方向</span></span><br><span class="line">            s1=s1-a[x]+a[y];</span><br><span class="line">            s2=s2-a[y]+a[x];</span><br><span class="line">            <span class="built_in">swap</span>(a[x],a[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        temp*=<span class="number">0.999</span>;<span class="comment">//每次温度降低</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">        mid=(<span class="number">1</span>+n)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        s1=s2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=mid;i++) s1+=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>;i&lt;=n;i++) s2+=a[i];</span><br><span class="line">        ans=<span class="built_in">abs</span>(s1-s2);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++) <span class="built_in">sa</span>();<span class="comment">//多进行几轮退火</span></span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quad-run-away">2.2 <span class="math inline">\(\quad\)</span>Run Away</h2><p>题目来源：<ahref="https://www.luogu.com.cn/problem/SP34">SP34</a></p><blockquote><p><strong>例题</strong> <span class="math inline">\(\quad\)</span> 给定<span class="math inline">\(n\)</span>个点的坐标，在给定范围内找一个点，使得距离所有点的最小值最大。</p></blockquote><p>考虑模拟退火，一开始将这个点的位置设置在范围的正中心。每次在一定范围内随机新点，范围与当前温度有关，见代码。</p><p>核心代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> temp=<span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp&gt;=<span class="number">1e-4</span>)&#123;</span><br><span class="line">        <span class="comment">//随机新点</span></span><br><span class="line">        <span class="type">double</span> nowx=<span class="built_in">getrnd</span>(<span class="built_in">max</span>(<span class="number">0.</span>,nx-temp),<span class="built_in">min</span>(<span class="number">1.</span>*X,nx+temp));</span><br><span class="line">        <span class="type">double</span> nowy=<span class="built_in">getrnd</span>(<span class="built_in">max</span>(<span class="number">0.</span>,ny-temp),<span class="built_in">min</span>(<span class="number">1.</span>*Y,ny+temp));</span><br><span class="line">        <span class="comment">//计算新值</span></span><br><span class="line">        <span class="type">double</span> dis=<span class="built_in">calc</span>(nowx,nowy);</span><br><span class="line">        <span class="type">double</span> D=dis-ans;</span><br><span class="line">        <span class="comment">//方案较优</span></span><br><span class="line">        <span class="keyword">if</span>(D&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ans=dis;</span><br><span class="line">            ansx=nx=nowx;</span><br><span class="line">            ansy=ny=nowy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以一定概率接受劣解，注意不等号方向</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span>(D/temp)&gt;=<span class="built_in">getrnd</span>(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">            nx=nowx;</span><br><span class="line">            ny=nowy;</span><br><span class="line">        &#125;</span><br><span class="line">        temp*=<span class="number">0.999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;X&gt;&gt;Y&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;ax[i]&gt;&gt;ay[i];</span><br><span class="line">        ansx=nx=<span class="number">1.</span>*X/<span class="number">2</span>;</span><br><span class="line">        ansy=ny=<span class="number">1.</span>*Y/<span class="number">2</span>;</span><br><span class="line">        ans=<span class="built_in">calc</span>(nx,ny);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++) <span class="built_in">sa</span>();<span class="comment">//多进行几次退火</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The safest point is (%.1lf, %.1lf).\n&quot;</span>,ansx,ansy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随机化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渐近记号与主定理</title>
      <link href="/post/afdc0807f110.html"/>
      <url>/post/afdc0807f110.html</url>
      
        <content type="html"><![CDATA[<p>渐近记号与主定理</p><p>渐近记号用来描述函数的运行时间，刻画运行时间的上界、确界、下界。使用递归定义的函数通常使用主定理分析时间复杂度。</p><h1 id="一渐近记号">一、渐近记号</h1><p>本节定义一些基本函数，用于描述时间复杂度。</p><h2 id="quad-渐进记号函数与运行时间">1.1 <spanclass="math inline">\(\quad\)</span> 渐进记号、函数与运行时间</h2><h3 id="quad-theta-记号">1.1.1 <spanclass="math inline">\(\quad\)</span> <spanclass="math inline">\(\Theta\)</span> 记号</h3><p>我们使用 <span class="math inline">\(\Theta\)</span>记号描述函数的<strong>渐近紧确界</strong>。</p><p>形式化地， <span class="math inline">\(\Theta (g(n))=\{f(n):\existsc_1,c_2,n_0:\forall n\ge n_0,0\le c_1g(n)\le f(n)\le c_2g(n)\}\)</span>。</p><p>其中，冒号意为“使得”。</p><p>也就是说，存在常量 <spanclass="math inline">\(c_1,c_2,n_0\)</span>，可以将 <spanclass="math inline">\(f(n)\)</span> 夹入 <spanclass="math inline">\(c_1g(n)\)</span> 和 <spanclass="math inline">\(c_2(n)\)</span> 中。<spanclass="math inline">\(\Theta(g(n))\)</span> 要求每个成员 <spanclass="math inline">\(f(n)\in \Theta(g(n))\)</span><strong>渐近非负</strong>。</p><p>我们通常使用 <span class="math inline">\(\Theta(1)\)</span>表示常量或某个变量的常量函数。</p><h3 id="quad-o-记号">1.1.2 <span class="math inline">\(\quad\)</span><span class="math inline">\(O\)</span> 记号</h3><p>当函数只有一个<strong>渐近上界</strong>时，使用 <spanclass="math inline">\(O\)</span> 记号。</p><p>形式化地， <span class="math inline">\(O (g(n))=\{f(n):\existsc,n_0:\forall n\ge n_0,0\le f(n)\le cg(n) \}\)</span>。</p><p>使用 <span class="math inline">\(O\)</span>记号描述上界，我们常常可以检查算法的总体结构来描述算法运行的时间，如循环嵌套等，这里不再展开。</p><h3 id="quad-omega-记号">1.1.3 <spanclass="math inline">\(\quad\)</span> <spanclass="math inline">\(\Omega\)</span> 记号</h3><p><span class="math inline">\(\Omega\)</span>记号提供了函数的<strong>渐近下界</strong>。</p><p>形式化地，<span class="math inline">\(\Omega (g(n))=\{f(n):\existsc,n_0:\forall n\ge n_0,0\le cg(n)\le f(n)\}\)</span>。</p><p>我们不难有如下定理：</p><p><strong>定理</strong> <span class="math inline">\(\quad\)</span>对于任意两个函数 <span class="math inline">\(f(n),g(n)\)</span>，我们有<span class="math inline">\(f(n)=\Theta(g(n))\)</span>，当且仅当 <spanclass="math inline">\(f(n)=O(g(n))\)</span> 且 <spanclass="math inline">\(f(n)=\Omega(g(n))\)</span>。</p><h3 id="quad-o-记号-1">1.1.4 <span class="math inline">\(\quad\)</span><span class="math inline">\(o\)</span> 记号</h3><p>前面的 <span class="math inline">\(O\)</span>记号描述的渐近上界，我们使用 <span class="math inline">\(o\)</span>记号来描述一个<strong>非渐近紧确的上界</strong>，如 <spanclass="math inline">\(2n=o(n^2)\)</span> 而 <spanclass="math inline">\(2n^2\not=o(n^2)\)</span>。</p><p>形式化地，<span class="math inline">\(o (g(n))=\{f(n):\forallc&gt;0,\exists n_0&gt;0:\forall n\ge n_0, 0\le f(n) &lt; cg(n)\}\)</span>。</p><p>直观上，在 <span class="math inline">\(o\)</span> 记号中，当 <spanclass="math inline">\(n\rightarrow + \infty\)</span>，函数<spanclass="math inline">\(f(n)\)</span> 相对于 <spanclass="math inline">\(g(n)\)</span> 来说变得微不足道了。</p><h3 id="quad-omega-记号-1">1.1.5 <spanclass="math inline">\(\quad\)</span> <spanclass="math inline">\(\omega\)</span> 记号</h3><p>我们使用 <span class="math inline">\(\omega\)</span>记号描述一个<strong>非渐近紧确的下界</strong>。</p><p>形式化地，<span class="math inline">\(\omega (g(n))=\{f(n):\forallc&gt;0,\exists n_0&gt;0:\forall n\ge n_0, 0\le cg(n) &lt; f(n)\}\)</span>。</p><h2 id="quad-渐近函数的性质">1.2 <spanclass="math inline">\(\quad\)</span> 渐近函数的性质</h2><p>我们令 <span class="math inline">\(f(n),g(n)\)</span> 渐近为正。</p><p>渐近函数具有<strong>传递性</strong>，即 <spanclass="math inline">\(f(n)=\Theta (g(n)),g(n)=\Theta h(n)\Rightarrowf(n)=\Theta(h(n))\)</span>。其他记号同理。</p><p>渐近函数具有<strong>自反性</strong>，即 <spanclass="math inline">\(f(n)=\Theta f(n)\)</span>，对于 <spanclass="math inline">\(O,\Omega\)</span> 记号同理。</p><p><span class="math inline">\(\Theta\)</span>函数具有<strong>对称性</strong>，即 <spanclass="math inline">\(f(n)=\Theta(g(n))\)</span> 当且仅当 <spanclass="math inline">\(g(n)=\Theta (f(n))\)</span>。</p><p>渐近函数具有<strong>转置对称性</strong>，即 <spanclass="math inline">\(f(n)=O(g(n))\)</span> 当且仅当 <spanclass="math inline">\(g(n)=\Omega f(n)\)</span>；<spanclass="math inline">\(f(n)=o(g(n))\)</span> 当且仅当 <spanclass="math inline">\(g(n)=\omega (f(n))\)</span>。</p><h1 id="二使用主方法求解递归式">二、使用主方法求解递归式</h1><p>对于类似 <span class="math display">\[T(n)=aT(n/b)+f(n)\]</span> 的递归式，通常使用主定理求解其渐近界。</p><h2 id="quad-主定理">2.1 <span class="math inline">\(\quad\)</span>主定理</h2><p><strong>定理（主定理）</strong> <spanclass="math inline">\(\quad\)</span> 令 <span class="math inline">\(a\ge1\)</span> 和 <span class="math inline">\(b\ge 1\)</span> 是常数，<spanclass="math inline">\(f(n)\)</span> 是一个函数，<spanclass="math inline">\(T(n)\)</span> 是定义在非负整数上的递归式： <spanclass="math display">\[T(n)=aT(n/b)+f(n)\]</span> 我们将其中的 <span class="math inline">\(n/b\)</span> 解释为<span class="math inline">\(\lceil n/b \rceil\)</span> 或者 <spanclass="math inline">\(\lfloor n/b \rfloor\)</span>，那么 <spanclass="math inline">\(T(n)\)</span> 有如下渐近界：</p><ol type="1"><li>若对某个常数 <span class="math inline">\(\epsilon &gt;0\)</span> 有<span class="math inline">\(f(n)=O(n^{\log_b a-\epsilon})\)</span>，则有<span class="math inline">\(T(n)=\Theta(n^{\log_ba})\)</span>。</li><li>若 <span class="math inline">\(f(n)=\Theta(n^{\log_ba})\)</span>，则 <span class="math inline">\(T(n)=\Theta(n^{\log_b a}\lgn)\)</span>。</li><li>若对某个常数 <span class="math inline">\(\epsilon&gt;0\)</span> 有<span class="math inline">\(f(n)=\Omega(n^{\log_ba+\epsilon})\)</span>，且对某个常数 <spanclass="math inline">\(c&lt;1\)</span> 和所有足够大的 <spanclass="math inline">\(n\)</span> 有 <spanclass="math inline">\(af(n/b)\le cf(n)\)</span>，则 <spanclass="math inline">\(T(n)=\Theta(f(n))\)</span>。</li></ol><p>上面就是主定理。注意这三种情况并未覆盖 <spanclass="math inline">\(f(n)\)</span>的所有可能性，下面将说明如何正确地使用主定理。</p><h2 id="quad-使用主方法">2.2 <span class="math inline">\(\quad\)</span>使用主方法</h2><p>我们把使用主定理求解递归式的方法称为<strong>主方法</strong>。我们只需要确定一个递归式对于主定理的哪种情况成立，即可得到解。</p><blockquote><p><strong>例子</strong> <span class="math inline">\(\quad\)</span>对于下面的递归式，求解其渐近界。 <span class="math display">\[T(n)=9T(n/3)+n\]</span></p></blockquote><p>对于这个递归式，我们有 <spanclass="math inline">\(a=9,b=3,f(n)=n\)</span>，因此 <spanclass="math inline">\(n^{\log b a}=b^{\log_39}=\Theta(n^2)\)</span>。由于 <spanclass="math inline">\(f(n)=O(n^{\log_39-\epsilon})\)</span>，其中 <spanclass="math inline">\(\epsilon=1\)</span>，因此可以应用于情况1，得到<span class="math inline">\(T(n)=\Theta(n^2)\)</span>。</p><blockquote><p><strong>例子</strong> <span class="math inline">\(\quad\)</span>对于下面的递归式，求解其渐近界。 <span class="math display">\[T(n)=T(2n/3)+1\]</span></p></blockquote><p>其中，<spanclass="math inline">\(a=1,b=\frac{2}{3},f(n)=1\)</span>，因此 <spanclass="math inline">\(n^{\log_b a}=n^0=1\)</span>。由于 <spanclass="math inline">\(f(n)=\Theta(n^{\log _ba})=\Theta(1)\)</span>，应用于情况2，得到 <spanclass="math inline">\(T(n)=\Theta(\lg n)\)</span>。</p><blockquote><p><strong>例子</strong> <span class="math inline">\(\quad\)</span>对于下面的递归式，求解其渐近界。 <span class="math display">\[T(n)=3T(n/4)+n\lg n\]</span></p></blockquote><p>其中，<span class="math inline">\(a=3,b=4,f(n)=n\lg n\)</span>，因此<span class="math inline">\(n^{\log_b a}=O(n^{0.793})\)</span>。由于<span class="math inline">\(f(n)=\Omega(b^{\log_43-\epsilon})\)</span>，其中 <span class="math inline">\(\epsilon\approx0.2\)</span>，因此，如果可以证明正则条件成立，可应用于情况3。当 <spanclass="math inline">\(n\)</span> 足够大时，有 <spanclass="math inline">\(af(n/b)\le cf(n)\)</span>，得到 <spanclass="math inline">\(T(n)=\Theta(n\lg n)\)</span>。</p><p>上面给出了三种例子，只要算出 <span class="math inline">\(n^{\log_ba}\)</span> 的渐近界，与 <span class="math inline">\(f(n)\)</span>比较，就可以求出递归式的渐近界。</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组与应用</title>
      <link href="/post/2f92b89a3659.html"/>
      <url>/post/2f92b89a3659.html</url>
      
        <content type="html"><![CDATA[<p>后缀数组与应用</p><p>后缀数组 (Suffix Array)是处理字符串问题的有力工具之一，通常利用后缀数组 <spanclass="math inline">\(sa\)</span>处理字符串子串与后缀串排序、公共前缀等问题。</p><h1 id="一后缀数组">一、后缀数组</h1><p>通过计算后缀数组与排名数组，辅助解决系列问题。</p><h2 id="quad-约定与定义">1.1 <span class="math inline">\(\quad\)</span>约定与定义</h2><p>对于一个长度为 <span class="math inline">\(n\)</span> 的字符串 <spanclass="math inline">\(s\)</span>，我们定义 <spanclass="math inline">\(s_i\dots s_n\)</span> 构成的子串为 <spanclass="math inline">\(s\)</span> 在 <spanclass="math inline">\(i\)</span>位置上的<strong>后缀</strong>，下面给出几个函数的定义：</p><ul><li><p><spanclass="math inline">\(sa_i\)</span>：<strong>后缀数组</strong>。表示<span class="math inline">\(s\)</span> 的所有后缀串中，按字典序排名，第<span class="math inline">\(i\)</span> 小的后缀串的起始位置。</p></li><li><p><spanclass="math inline">\(rk_i\)</span>：<strong>名次数组</strong>。表示起始位置为<span class="math inline">\(i\)</span>的后缀串的排名（按字典序）。</p></li></ul><p>不难发现，上面两个函数<strong>互为反函数</strong>，即： <spanclass="math display">\[\begin{aligned}sa[rk[i]]=i\\rk[sa[i]]=i\end{aligned}\]</span></p><ul><li><spanclass="math inline">\(height_i\)</span>：<strong>高度数组</strong>。表示排名为<span class="math inline">\(i\)</span> 的后缀串与排名为 <spanclass="math inline">\(i-1\)</span> 的后缀串的最长公共前缀。特殊地，<spanclass="math inline">\(height_1=0\)</span>，因为没有比它排名小的后缀串。形式化地：</li></ul><p><span class="math display">\[ht[i]=\text{LCP}(sa[i],sa[i-1])\]</span></p><p>其中，<span class="math inline">\(\text{LCP}(s,t)\)</span> 表示字符串<span class="math inline">\(s,t\)</span> 的最长公共前缀。</p><ul><li><spanclass="math inline">\(h_i\)</span>：<strong>公共前缀数组</strong>。表示起始位置为<span class="math inline">\(i\)</span> 的后缀串，与比其排名小 <spanclass="math inline">\(1\)</span> 的后缀串的最长公共前缀，即：</li></ul><p><span class="math display">\[h[i]=height[rk[i]]\]</span></p><blockquote><p><strong>例子</strong> <span class="math inline">\(\quad\)</span>给定字符串 <spanclass="math inline">\(s=aabaaaab\)</span>，其后缀数组、名次数组、高度数组、公共前缀数组为别为：<span class="math display">\[\begin{array}{}&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8\\s:&amp;a&amp;a&amp;b&amp;a&amp;a&amp;a&amp;a&amp;b\\sa:&amp;4&amp;5&amp;6&amp;1&amp;7&amp;2&amp;8&amp;3\\rk:&amp;4&amp;6&amp;8&amp;1&amp;2&amp;3&amp;5&amp;7\\height:&amp;0&amp;3&amp;2&amp;3&amp;1&amp;2&amp;0&amp;1\\h:&amp;3&amp;2&amp;1&amp;0&amp;3&amp;2&amp;1&amp;0\end{array}\]</span></p></blockquote><h2 id="quad-后缀数组的计算">1.2 <spanclass="math inline">\(\quad\)</span> 后缀数组的计算</h2><p><strong>前置芝士：倍增法、基数排序。</strong></p><p>我们有暴力的做法，对所有后缀串排序，但是这个复杂度并不优秀。</p><p>我们考虑<strong>倍增地</strong>计算后缀数组。也就是说，每次我们计算一段长形如<span class="math inline">\([i,i+2^k-1]\)</span>的子串，而后合并前后两个子串，并按照两个子串的各自的关键字进行排序合并。下面我们考虑怎样合并两个已经排好序的更小的子串，使其拼成一个更长的、有序的子串，进而贡献给后缀数组。如下图：</p><p><img src="https://oi-wiki.org/string/images/sa2.png" /></p><p>这张图中，我们进行了 <span class="math inline">\(O(\log n)\)</span>次倍增。第一次，我们就以字典序为前后两个关键字合并。其后，我们分别以前面一段的名次、后面一段的名次，为两个关键字进行合并。我们每一次合并需要对<span class="math inline">\(n\)</span>个数的两个关键字排序，直接使用快速排序可以获得 <spanclass="math inline">\(O(n\log^2 n)\)</span>的复杂度。一定程度上可以接受，但是不是很优秀，我们希望消去一个 <spanclass="math inline">\(\log\)</span> 的复杂度。</p><p>考虑使用基数排序替换快速排序，每次先对第二关键字开桶记录，而后对第一关键字开桶记录。这样我们放入第一关键字桶的顺序已经满足排序顺序，换句话说，已经满足第二关键字递增的顺序。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="quad-代码实现">1.3 <span class="math inline">\(\quad\)</span>代码实现</h2><p>定义以下变量：</p><ul><li><spanclass="math inline">\(m\)</span>：桶中最大元素，即桶的上限；</li><li><span class="math inline">\(c_i\)</span>：数组为计数桶。</li><li><span class="math inline">\(x_i\)</span>：起始位置为 <spanclass="math inline">\(i\)</span> 的串的第一关键字；</li><li><span class="math inline">\(y_i\)</span>：第二关键字排名为 <spanclass="math inline">\(i\)</span> 的串的起始位置，即 <spanclass="math inline">\(x\)</span> 的位置。</li></ul><p>下面描述算法流程。</p><ol type="1"><li><p>对于第一次递增，我们直接按照每单个字符排序，将每个长度为 <spanclass="math inline">\(1\)</span> 的串的第一关键字放入桶中。</p></li><li><p>然后对桶 <span class="math inline">\(c\)</span>进行前缀和处理，这样我们确定了第一关键字为 <spanclass="math inline">\(k\)</span> 的元素最大排在第几名。</p></li><li><p>我们对后缀数组进行第一次赋值，表示长度为 <spanclass="math inline">\(1\)</span> 的后缀串排名第 <spanclass="math inline">\(i\)</span> 的串的起始位置为 <spanclass="math inline">\(sa_i\)</span>。这里注意需要倒序枚举 <spanclass="math inline">\(i\)</span>，因为我们只划定了排序名次的上界。确切的名次需要由上界依次递减得到。</p></li><li><p>而后我们进行更多次的倍增，处理长度为 <spanclass="math inline">\(k\)</span>的串。考虑到如果合并两个串时，第一个串的起始位置 <spanclass="math inline">\(i\gen-k+1\)</span>，我们第二个串就是空串，需要提前处理。而且这些串合并后，排名一定比第二个串非空的靠前。下面的<span class="math inline">\(num\)</span> 表示第二关键字排名。注意 <spanclass="math inline">\(y\)</span>数组保存的是对应的第一关键字的位置。</p></li><li><p>而后我们对于所有可能的第二串加入 <spanclass="math inline">\(y\)</span> 数组。只有 <spanclass="math inline">\(sa[i]&gt; k\)</span>时才可行（短于倍增长度无法找到第一串）。</p></li><li><p>仿照第一次倍增的思路处理第一关键字桶。</p></li><li><p>基数排序，因为 <span class="math inline">\(y\)</span>的顺序是按照第二关键字的顺序来排的，第二关键字靠后的，在同一个第一关键字桶中排名越靠后。</p></li><li><p>清空第一关键字数组，并根据当前值重新赋关键字。注意到此时我们直接按后缀数组赋值即可，本身有序。更新桶上限<span class="math inline">\(m\)</span>。</p></li></ol><p>完整代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Suffix_Array</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;(s+<span class="number">1</span>);                                                       <span class="comment">//Step.1</span></span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    m=<span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[x[i]=s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++) c[i]+=c[i<span class="number">-1</span>];                               <span class="comment">//Step.2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--) sa[c[x[i]]--]=i;                               <span class="comment">//Step.3</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k&lt;&lt;=<span class="number">1</span>)&#123;                                          <span class="comment">//Step.4</span></span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n-k+<span class="number">1</span>;i&lt;=n;i++) y[++num]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(sa[i]&gt;k) y[++num]=sa[i]-k;           <span class="comment">//Step.5</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) c[i]=<span class="number">0</span>;                                 <span class="comment">//Step.6</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[x[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--) sa[c[x[y[i]]]--]=y[i];                     <span class="comment">//Step.7</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lstx[i]=x[i],x[i]=<span class="number">0</span>;                    <span class="comment">//Step.8</span></span><br><span class="line">        num=<span class="number">1</span>;</span><br><span class="line">        x[sa[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lstx[sa[i]]==lstx[sa[i<span class="number">-1</span>]]&amp;&amp;lstx[sa[i]+k]==lstx[sa[i<span class="number">-1</span>]+k]) x[sa[i]]=num;</span><br><span class="line">            <span class="keyword">else</span> x[sa[i]]=++num;</span><br><span class="line">        &#125;</span><br><span class="line">        m=num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二子串最长公共前缀">二、子串最长公共前缀</h1><p>我们记 <span class="math inline">\(\text{LCP}(i,j)\)</span>表示字符串排名为 <span class="math inline">\(i\)</span>的后缀串，和排名为 <span class="math inline">\(j\)</span>的后缀串的最长公共前缀，根据性质计算。</p><h2 id="quad-基本性质">2.1 <span class="math inline">\(\quad\)</span>基本性质</h2><p><strong>性质 1</strong> <span class="math inline">\(\quad\)</span><spanclass="math inline">\(\text{LCP}(i,j)=\text{LCP}(j,i)\)</span>。</p><p><strong>性质 2</strong> <span class="math inline">\(\quad\)</span><spanclass="math inline">\(\text{LCP}(i,i)=\text{len}(sa[i])=n-sa[i]+1\)</span>。其中，<spanclass="math inline">\(\text{len(i)}\)</span> 表示起始位置为 <spanclass="math inline">\(i\)</span> 的后缀串的长度。</p><p>上面两个性质显然。</p><p><strong>性质 3</strong> <span class="math inline">\(\quad\)</span><span class="math inline">\(\forall 1\le i\le j\le k\le n\ ,\\text{LCP}(i,k)=\min(\text{LCP}(i,j),\text{LCP}(j,k))\)</span> 。</p><p>因为是按照后缀排序的，所以易证。</p><p>进而得出，按照后缀排完序的后缀串，两个后缀串的最长公共前缀就等于<span class="math inline">\(height_{i+1}\cdots height_j\)</span>取最小值。 <strong>性质 4</strong> <spanclass="math inline">\(\quad\)</span> <span class="math inline">\(\forall1&lt;i\le j\le k\le n\ ,\\text{LCP}(i,k)=\min(\text{LCP}(j,j-1))\)</span>。</p><p><strong>性质 5</strong> <span class="math inline">\(\quad\)</span><span class="math inline">\(h_i\geh_{i-1}-1\)</span>，这是<strong>关键性质</strong>。</p><p>考虑粗略证明性质5。令第 <span class="math inline">\(i-1\)</span>位为字符 <span class="math inline">\(s\)</span>，则 <spanclass="math inline">\(i-1\)</span> 位置的后缀为 <spanclass="math inline">\(sX\)</span>，<spanclass="math inline">\(i\)</span> 位置的后缀为 <spanclass="math inline">\(X\)</span>。</p><p>我们找到后缀排名在 <span class="math inline">\(sX\)</span>前一名的后缀，即 <span class="math inline">\(sa[rk[i-1]-1]\)</span>，记<span class="math inline">\(k\)</span>为这个排名。这两个后缀的最长公共前缀就是 <spanclass="math inline">\(height[rk[i-1]]\)</span>。分成两类情况讨论：</p><ul><li>如果第 <span class="math inline">\(k\)</span> 个串和第 <spanclass="math inline">\(i-1\)</span>个串第一个字符不同，即没有公共前缀，即 <spanclass="math inline">\(height[rk[i-1]]=0\)</span>，一定有 <spanclass="math inline">\(height[rk[i]]\ge height[rk[i-1]]+1\)</span>，即<span class="math inline">\(h[i]\ge h_[i-1]-1\)</span>。</li><li>如果第 <span class="math inline">\(k\)</span> 个串和第 <spanclass="math inline">\(i-1\)</span> 个串第一个字符相同，可以表示第 <spanclass="math inline">\(k\)</span> 个串为 <spanclass="math inline">\(sY\)</span>。一定有 <spanclass="math inline">\(sY&lt;sX\Rightarrow Y&lt;X\)</span>。那么第 <spanclass="math inline">\(k+1\)</span> 个字符串要排名在 <spanclass="math inline">\(i\)</span> 前面。那么第 <spanclass="math inline">\(k+1\)</span> 个字符串和 <spanclass="math inline">\(i\)</span> 的最长公共前缀就是 <spanclass="math inline">\(height[rk[i-1]]-1\)</span>。根据性质4可得 <spanclass="math inline">\(h[i]\ge h[i-1]=1\)</span>。</li></ul><h2 id="quad-后缀排序最长公共前缀的计算">2.2 <spanclass="math inline">\(\quad\)</span> 后缀排序最长公共前缀的计算</h2><p>我们利用性质5计算后置排序后的 <spanclass="math inline">\(height\)</span> 数组和 <spanclass="math inline">\(h\)</span> 数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getheight</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) rnk[sa[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rnk[i]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(j) j--;</span><br><span class="line">        <span class="keyword">while</span>(i+j&lt;=n&amp;&amp;sa[rnk[i]<span class="number">-1</span>]+j&lt;=n&amp;&amp;s[i+j]==s[sa[rnk[i]<span class="number">-1</span>]+j]) j++;</span><br><span class="line">        heigh[rnk[i]]=j;                  <span class="comment">//h[i]=height[rnk[i]]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ramsey 定理</title>
      <link href="/post/a1e7c3dbc7c4.html"/>
      <url>/post/a1e7c3dbc7c4.html</url>
      
        <content type="html"><![CDATA[<p>Ramsey 定理</p><h1 id="一ramsey-定理">一、Ramsey 定理</h1><p>Ramsey定理是关于鸽巢原理的重要拓展，甚至可以从另一个维度解释鸽巢原理。</p><h2 id="quad-基本定义">1.1 <span class="math inline">\(\quad\)</span>基本定义</h2><p>我们先给出一些定义。</p><p>对于由 <span class="math inline">\(n\)</span>个点构成的图，两两节点直接都有边直接相连，则成这张图是<strong>完全图</strong>。</p><p>我们把 <span class="math inline">\(p\)</span> 个点的完全图，记作<span class="math inline">\(K_p\)</span>。</p><p>我们用两种颜色对所有边进行染色，染色成 <spanclass="math inline">\(a\)</span> 或者 <spanclass="math inline">\(b\)</span>，如果下面两个条件至少满足其一：</p><ol type="1"><li>存在 <span class="math inline">\(n\)</span>个点的子集，使其构成的完全图中所有边的颜色为同一种颜色 <spanclass="math inline">\(a\)</span>；</li><li>存在 <span class="math inline">\(m\)</span>个点的子集，使其构成的完全图中所有边的颜色为同一种颜色 <spanclass="math inline">\(b\)</span>。</li></ol><p>我们记作 <span class="math display">\[K_p\rightarrow K_m,K_n\]</span> 我们记 Ramsey 数 <span class="math inline">\(r(n,m)\)</span>是使 <span class="math inline">\(K_p\rightarrow K_n,K_m\)</span>的最小正整数 <span class="math inline">\(p\)</span>。我们不难发现 <spanclass="math display">\[r(n,m)=r(m,n)\]</span> &gt; <strong>例子</strong> <spanclass="math inline">\(\quad\)</span> 在 <spanclass="math inline">\(6\)</span> 个人构成的集合中，要么 <spanclass="math inline">\(3\)</span> 个人互相认识，要么 <spanclass="math inline">\(3\)</span> 个人互相不认识。</p><p>我们给出这个例子的证明。</p><p>我们对于 <span class="math inline">\(6\)</span>个点的完全图，两个人间互相认识则边染红色，否则边染蓝色。考虑图中的任意一个点<span class="math inline">\(p\)</span>，与其相连的 <spanclass="math inline">\(5\)</span> 条边中，至少有 <spanclass="math inline">\(3\)</span>条边颜色相同（根据鸽巢原理可得）。因为情况对称，我们令染红色的边数至少为<span class="math inline">\(3\)</span>，那我们举出这三条边连接的三个点<span class="math inline">\(a,b,c\)</span>，分类考虑以下情况：</p><ul><li>如果由 <span class="math inline">\(a,b,c\)</span>三个点构成的完全图中所有边都是蓝色，那么这三个点构成一个蓝 <spanclass="math inline">\(K_3\)</span>。</li><li>如果由 <span class="math inline">\(a,b,c\)</span>三个点构成的完全图中有一个边是红色，那么这条红边连接的两个点，和点 <spanclass="math inline">\(p\)</span> 构成一个红 <spanclass="math inline">\(K_3\)</span>。</li></ul><p>则红 <span class="math inline">\(K_3\)</span> 和蓝 <spanclass="math inline">\(K_3\)</span>两个至少有一个成立。即证明了这个结论。</p><h2 id="quad-基本的-ramsey-定理">1.2 <spanclass="math inline">\(\quad\)</span> 基本的 Ramsey 定理</h2><p>下面给出更广泛的定理和证明。</p><p><strong>定理</strong> <span class="math inline">\(\quad\)</span><span class="math inline">\(\forall n,m\ge 2,\exists p\in\mathbb{N}_+\)</span>，使得 <span class="math display">\[K_p\rightarrow K_m,K_n\]</span> <strong>证明</strong> <spanclass="math inline">\(\quad\)</span> 我们很容易确定 <spanclass="math inline">\(r(2,n)\)</span> 和 <spanclass="math inline">\(r(n,2)\)</span> 的值。下面证明 <spanclass="math inline">\(r(2,n)=r(n,2)=n\)</span>。</p><ul><li>确定 <span class="math inline">\(r(2,n)\leqn\)</span>：如果所有边都是同一种颜色，则 <spanclass="math inline">\(K_n\)</span> 成立；否则 <spanclass="math inline">\(K_2\)</span> 成立。</li><li>确定<span class="math inline">\(r(2,n)&gt;n-1\)</span>：如果有一个红<span class="math inline">\(K_{n-1}\)</span>，我们并不能得到蓝 <spanclass="math inline">\(K_2\)</span> 或者红 <spanclass="math inline">\(K_n\)</span>。</li></ul><p>下面用归纳法证明广泛结论。</p><p>假设 <span class="math inline">\(m,n\ge 3\)</span> ，归纳假设为 <spanclass="math inline">\(r(m-1,n)\)</span> 和 <spanclass="math inline">\(r(m,n-1)\)</span> 存在。设 <spanclass="math inline">\(p=r(m-1,n)+r(m,n-1)\)</span>，下面证明 <spanclass="math inline">\(K_p\rightarrow K_m,K_n\)</span> 存在。</p><p>假设 <span class="math inline">\(K_p\)</span>已经通过某种方式完成红色和蓝色的染色，我们对其中的一个节点 <spanclass="math inline">\(x\)</span>，记 <spanclass="math inline">\(B_x,R_x\)</span> 分别为通过蓝色边和红色边在图中与<span class="math inline">\(x\)</span> 相连的点的集合。有 <spanclass="math display">\[|R_x|+|B_x|=p-1=r(m-1,n)+r(n,m-1)-1\]</span> 也就是说，以下两个条件至少有一个成立：</p><ol type="1"><li><span class="math inline">\(|R_x|\ge r(m-1,n)\)</span>；</li><li><span class="math inline">\(|B_x|\ge r(m,n-1)\)</span>。</li></ol><p>可以通过鸽巢原理说明这一点，因为如果两个都不成立，则 <spanclass="math inline">\(|R_x|+|B_x|\ler(m+1,n)+r(m,n-1)-1=p-2\)</span>，矛盾。</p><p>我们假设条件1成立，也就是 <span class="math inline">\(|R_x|\ger(m-1,n)\)</span>，说明下面两个条件至少有一个成立：</p><ul><li>可能存在一个红 <spanclass="math inline">\(K_{m-1}\)</span>，这个图的节点就是 <spanclass="math inline">\(R_x\)</span> 中的节点。如果我们将 <spanclass="math inline">\(x\)</span> 加入这个图，因为与 <spanclass="math inline">\(x\)</span> 相连的边为红色，就可以得到一个 <spanclass="math inline">\(K_m\)</span>，完成证明；</li><li>可能存在一个蓝 <spanclass="math inline">\(K_n\)</span>，这时我们直接完成了证明。</li></ul><p>所以此时结论成立。同理，若条件2成立，则结论也一定成立。</p><p><strong>证毕</strong>。</p><p>上面的证明不仅证明了 Ramsey 数的存在，也给出了不等式 <spanclass="math display">\[r(m,n)\le r(m-1,n)+r(m,n-1)\quad (m,n\ge 3)\]</span> 设函数 <span class="math display">\[f(m,n)=\dbinom{m+n-2}{m-1}\quad (m,n\ge 2)\]</span> 得到 <span class="math display">\[f(m,n)=\dbinom{m+n-3}{m-1}+\dbinom{m+n-3}{m-2}=f(m-1,n)+f(m,n-1)\]</span> 这是一个等式。因为 <spanclass="math inline">\(r(2,n)=n=f(2,n)\ ,\ r(m,2)=m=f(m,2)\)</span>，所得Ramsey 数满足 <span class="math display">\[r(m,n)\le \dbinom{m+n-2}{m-1}=\dbinom{m+n-2}{n-1}\]</span></p><h2 id="quad-ramsey-定理的推广">1.3 <spanclass="math inline">\(\quad\)</span> Ramsey 定理的推广</h2><p>上面我们将一个完全图每条边染成了 <spanclass="math inline">\(2\)</span> 种颜色，我们将其扩展，对一个点数为<span class="math inline">\(n\)</span> 的完全图，用 <spanclass="math inline">\(k\)</span> 种颜色染色。如果 <spanclass="math inline">\(n_1,n_2,\cdots,n_k\ge 2\)</span>，则存在 <spanclass="math inline">\(p\)</span> 使得： <span class="math display">\[K_p\rightarrow K_{n_1},K_{n_2}\cdots,K_{n_k}\]</span> 使得该结论成立的最小整数 <spanclass="math inline">\(p\)</span> 称为 Ramsey 数 <spanclass="math inline">\(r(n_1,n_2,\cdots ,n_k)\)</span>。</p><p>如果我们把点对（两个元素的子集）扩展成 <spanclass="math inline">\(t\)</span> 个元素的子集，令 <spanclass="math inline">\(K_n^t\)</span> 表示 <spanclass="math inline">\(n\)</span> 元素集合种所有 <spanclass="math inline">\(t\)</span> 个元素的子集的集合，扩展 Ramsey定理。</p><p>给定整数 <span class="math inline">\(t\ge 2\)</span> 和整数 <spanclass="math inline">\(q_1,q_2,\cdots ,q_k\ge t\)</span>，存在整数 <spanclass="math inline">\(p\)</span>，使得 <span class="math display">\[K_p^t\rightarrow K_{p_1}^t,K_{p_2}^t,\cdots,K_{p_k}^t\]</span> 满足结论的最小整数 <span class="math inline">\(p\)</span> 称为Ramsey 数 <spanclass="math inline">\(r(q_1,q_2,\cdots,q_k)\)</span>。</p><p><span class="math inline">\(q_1,q_2,\cdots,q_k\)</span>的排列并不影响 Ramsey 数的表现。</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 《活着》</title>
      <link href="/post/bb1c83aedd06.html"/>
      <url>/post/bb1c83aedd06.html</url>
      
        <content type="html"><![CDATA[<p>活着</p><p>余华</p><p>2023.10.01 记</p><hr /><p>面朝大海 春暖花开 ——读《活着》有感</p><p>自从买这本书时，就看到不止一条评论：余华老师为什么要写得这么惨？但纵观福贵一生，也许在他的眼中，面对生活的态度和我们有所不同吧！</p><p>福贵自富家出身，祖上几代也想兴盛家业，但因子女无能日益破败。青年富贵正是在肆意放纵中度过的，也因此亲手赌出了自己的家产。眼看着祖上的东西丢得一干二净，亲人相继离世，前途的微光愈加消散……</p><p>但在福贵眼里，命运似乎是注定的。他在经历次次打击后，却没有因此堕落，而是坦然地活下去。</p><p>他的一生是乐观的，活着就是为了“活着”本身。对比《骆驼祥子》中的祥子，开始十分努力，而后经历世事变迁，自己也慢慢沦落，活得已不成人形。和祥子活在几乎同一个历史背景的福贵，为什么并没有因家庭破碎、事业破败而选择“放弃活的意义”？就在于自身面对生活的态度。前者虽然努力，但仍以乐观的态度对待“天命”，却早已是“成功地活着”。</p><p>他的一生是宽容的，活着只为了更好地生活。他在极度饥荒时，面对向老丈人借来的为数不多的几粒米，不吝啬于借给队长一部分；面对儿子有庆不公平地以“借血”为由死去，他并不责怪春生。因为他知道，谁的生活都是艰难的，没有被逼无奈也不会出此下策。</p><p>所以，“惨”可能并不是为写而写，更多地，可能时一个无法改变天命的普通人的映射。正如作者在序中写的：</p><blockquote><p>作家的使命不是发泄，不是控诉活着揭露。他应该向人们展示高尚。这里所说的高尚不是那种单纯的美好，而是对一切事物理解之后的超然、对善和恶的一视同仁，用同情的目光看待世界。</p></blockquote><p>尽管“惨”可能是人生的旋律，但一定不是人生的主题。它的主题应是“希望”。所以，人生遇挫之时，谨记“面朝大海，春暖花开”，而不是悲观地走向汪洋无望的深海——尽管不知以诗人的绝笔诗为题是否合适……</p><p>向死而生，有希望怎么都好。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『初丶晴』的模拟赛题解</title>
      <link href="/post/7cf54d2e491b.html"/>
      <url>/post/7cf54d2e491b.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="欸? 这个『通行证』看着不太对, 再试试看呢..." data-whm="密码不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8aaf84673714e0fea1a3cc4856c5de7e6ca7354f6c82951706e5e5d9bc951313">f6941bc60948d3ded0396f371d8df72c0c9411ed47a5b43ad41d15f89ded6845438004f268d68d5b55c37b46fec644a5f16814f3af64f49731d50d223aa8a8a12396a6ecc673da0a683fb3b27bdaa2077cff8016496e5a701d46c7f33a7c71c580271f4d894e948322a0f89877fab7aca51c9c1d9e88a9c024647801f36aecb7515885a8bae69d2dd1473403a406a25af366dad755c6bb25189f346930708002d1dab7e89084fa53b0f2022ff74b5173d6515fbbd874acbf0776b6fb0cd4acb964903ddcec3a2d69704ba6f79a4b9786fd241117bcc9093d2309e64a39df5138645b75f51b4131f76df0a5e7619c4c0902b5c68a5e189a3480513603033954eb9ea4a895e9cbfb3b7bdff6f29e620b77a2ea09edfd726084efd2c833d3386274e3b3debb3b3c46ab3cae889dd627baf867e67fc4bdedd8f548e86b5252039dc1c210c341f4aac33ee70b235dfff64c0eb18d10cfdfc7d2abd6590ed3bf5a4d4a975730a091a760031770a252234e5a0dec8d85aeca8fd6d96f6756f43b51b0f438e62c4a7c3bf59f6fd33f4934e3039b533d8053c44346a43f533ae488832eeb478b0cb15592aa39b853ecab2ff288ad4614c531f86a4f990f3e8bebd31019cde041df5a341f64c2af7bad7d205d5eb621c3bdb2536c1e84a77adcc74f6c3e0c75e65f6ae242ed9a67e9fc88d8ddc6b50f91ac5a9e456e263d5fab364ebaebc495454ab006a7a31fff096f0948491a4280a5ffd8a612c6edb727e3f5bc375bca2bebdad83298f15d45fdecb3e812cadc743cac34fa4d4d9356e286f77f818eb314c98b30dc3f219aa3e7be14fb72da9de23ca20e90df31b1b79225f352eea241fccb03889515faf7cf70526d872069b85c8fd2b2470ecbc4c0759c5b45985f70e5ba60d5454556ea2d8533cd57ffcf7059110061b54e5012170bb24dd27b57a90f16554749e685b27982b533b8b85e57074e8e187b1a2185239273cc9030388999ece644dd61dcbc0deb3a772218a2a3990434ba7f50f8dee13438f50eb08cfaacac85e5a3d71fbb711e234ebbe0dc10a4d6984ae4d3e3cb67244154032514c358e57ab446d487a87c0c89be53fc58b0bb99d75c1bb583679d825383c3b24f3a639fac0f8626313c969c000f66b5e52900356e83b7e75659442f6279d51b731a7e10dda50c61d877360f758d8c80d6dd7e53c8676b2c320595a8e2378374edb7b92c9f5ebecd4e61a717872d842476101248a3a851fa8ccc2062812f2615fd7eb523eb9f2151f72b0c2cbd200456fc1865f5faf13168b75d9b4c624c8c25c44a9843abf75848d5fc8c38b8a1f8a442703df619e1395c3ea789febf3e1c3db0784c8a33f5197214fed6c6861747a0adfc2ceaa4365bacf073e43e4f14d5f5d9d7f02d33e306aa6e75cc7283279f277571be7038d161d2e062a32a777be30ae35ca0a70fc093713d7949f0553b9a3a259535ecf16f08f85d2a89efc7bb561b24387043f7ff701aac86e26f827d891cbd57a22e01be9dbbd6b4309f65e4531b33a612f1453cbc0acc5297da5a40fba68e94ed7b2794bbc5e0643621608d7b629f24373aafc89f10878a102300dd8b6b778e259ddb0ea90155fca9f9a79f02b379e875ae18398c0e8a5b681de3a8e20c0cd14efd283c4e2d738b94445db26f1b68dde295acca8bcadf416d3d205290b9b35206bd585af19ea65368ad6b61716551f54713e43da3c9f11687ffa521ff12ebd7b2561a655c58a29201630a5374d5bbae36c0348cd1bc61da337c57ab3726887bc7966588cd8c8d2d7e1a3c1c5b88e01d0856433216bdaa43bfc95e6ecaf50923e4e674736ef0234881735fa5422e8ea8c3189cafe737af77484e0f32fad6065e7360ba0861c8427f3100bcca6c6794323a0b841e429d9b72c7e4a660b9e4ab1fe0a45d55cc53f7d9581aa83559b5496f1b493f4f69b22139bb13829bb0ed14d579c165582df7efe40415b1bf4261ff14479a31536917c4bee30b39e9147eb64e9d9570d624b16456d85597df911b5edd6ede78853d17085bd97da03f382a52de81086072583588a2bd055a6122bb7379e77fc343a4b450a2b91f0b73fb645fad9d6aaef41566433c3432929428f75538af64a686dd87408166b73e5397dc7217335bc1a4cab66331ce8ef41ebaa73b7cffa139e64112d465d0e455885c1f382c1bd4fbfbc8d398b4b3c2b60e73b8510377ffacaf50f4da159516efa12e7505b786c45386aeabd4042d0ef86b9c069ab773cbfc1eb5f402dce766717e97ea5d32187ca3a73ddcb5a5a97f0eb2e178dc60aa5a5c5f0e7877fd2ec967b7d2ffa985d64b092b3b1ea571c023806d3755e7a036be11c11c0a2cedafd79b585a348aa9e52f14cf9892bccc0017e8a3bba1173298764e5ebf384101ea2d2db5480052a8fb284a1efe464378bbda75420b3c1e7836a6f8921e86009fab38f2f86f111bccc0c3cafbf0bf9d99775dad6834ae2e9fcd4bb613efe14ce6395e71cc2b912c2a5510250151e64db784b592d70a2182d504bd55ed0c7be458e93e3fe5df33075fef995df13f3a6e41d7dd63c68dc3d4fc8bcd38b21c3a00ed2670cb5c51b71ed2ca01a2f9f508a5ff1446ca75d98d13c1e61a4c247fbdc51bb0c3bd8b3825d3c33f0bbfb8c12083177443638538e734d3b24db5cacc2e768a7f5f367e7ffee31f025881773a5f934f1081d31a61a1f1ffbcb058ba91f4f3abb59bcd887ad1e7a660afb04371eb0a4daebcb423a96cdd3688664e9707a6c5feca4f7fd1f3f53308696ae68d3b27f40eaf1faf820a6df01cecdb33c0791cfca150bbd45da082114e6509e382fb2c28a14436cb8dc2d4c688c0efaa08fc38af0fff7c0cc23998c0cfa363378d9f7b355e5584ec616e9ab2136ed347e8694cbd6f174ccd892a5853edd8f8439e44a1eabfa295f7a93e662174b84b37f56a944121cff77ac184e2a09654f8956293b0048d19ef327a041d691bbfaa9b9d0101f422113c31afb306f41ffdeb9dbb20493525b5c75992d514f63de778db30ef540b226a916fc107c710deb1e7f03169887ee9ea4b8b56674437bf581f61af890f2ea2c7cf9fa3e6c0212afa0337f3327d0f877685088ca5d58fc290acc9badad49efb7ece46f66d4f33db4a60abc774e39a1d832adcca9a692f458d1ee24b5bc52e09cc339a67586ee98059b2690b0526facaed8a4fddd7fee48724ffbde42c7c084fd28917d5260b73bba07c1645be3eeea529e4d8d76c2f9a3eb9e95eb36292e6ca96c498631b1b0977fdf87b967730d7325a2719407a3d95d0b33fb246d1f30553c6a5f2fd3a3cb05a0bc3ed7b342bcf0de06d97dfdd05fd14575d9f4e19dbc6e065de3ae505f82342e3b447ca99c9c8af090270f6259245b3f03b0b1f4c7d0a64c3ccc265ede94b9c236ef0de29e624ae4cde05bf7921fd2cf4ee3279339f5fe62dcc966b7c0f098df3fb76f5541562ee3efc4068bbe5afcf17b28ebf13a1405ed5d46232c7e09ea8d1f5965bea01bb588d5f3c5a303101c17c3737b8ef07b531ef440e26c62ce485b59fe23bbdc8d7dc8c99336759e1f40925153d0532a4b5146d2f808a56323ba42d055e6dff637b998dce763582eec3f10126d1db38c46140cdea169e52a9c58f04f37c98ae42f6a3fcf42ccb4d915abcf86a141cc33bdff06517f971e36bbcee491ffff4ebf11c981c34604e63e8a19c6875d70e3b68bbb413650359fd7bc0c71ffdaf76268888f087f68bd9c5238f57455d441a1c395e777b8e9c61331fd607974c30e053e194136f3faee28e78c08c265232a90a1306199c61139bc6bf7dff79f97cf5414a579f53d5ff0b09fdc16c7f27ed6125671d7e8384cfd6b04b707310434d41fab93cba18049e4c355dfdd68ff0d8ea1bf3d5260b15ef299cb8fc74320b2a6a0e1a143d7c09147682e891b96d64960909cd9cee9862e15c7a84ff1910397b65efdd9169969deafdaf023300c90230a3dcae26f4d661ebb50661744cd558058c6409f6f4d96e00f1966e1b1bbdf9b15e9707323239878607d9a200f02ebd4ab34b57766ccf830b06a4d30ee4560f86f9ccb3ce4b023eab70bfa941fc6bc923b1cbf7dcdfa84c05e7bc1d6fdc4b2735e481e55ce789c62c99d29e3d21571e29250ac77f4dabb1f9f9ef672fbd02d5e6123088a78542313bab5841b6499e03e35ba7e31c6c98ede31ea83ffed85c7d5190dca251ea12de77da5f1e5e3d403df0c7a72b9ef9abbd5ea4118dc1f9f97c057a5afaa31ca76ddfa56622e762e46f27117bc06566463fc7ce92185edc2a7e7fbcd29c15565cef5931eee845032be8d88402a649ea20de2e5b6de619e4fe9c541ea3a24acbd270e30ae9f884368dda99e91e017dc8941985d7348269558603a736fe1802b94d568b104d4a66e410210951363de7bd96128f79759c497313ebdbfe6a160cbc30e5f9a0848ed30a74d0ecf400ad17cc6edec397f51c3ae8628567b6562ee45c792edfd6c12d4e2a78edc342caa0ebe32e370cccd1f7c9e5511785f84923ff67180df77abc76f1e0aef8a907a68a04feb054d8265ba58d01216b07a2a76f0275216f7d2868ad336bb071cb0440898d4fd048f309a7084e6046c65e8d4e7127fa7e35cbeb28f9473c1adb65d6101b5321447b77f228d0ab123e85c191beb1224c4cf2558afdb0167178adce9d85de82589aba87de27259556e960943aa8f5f80f119a2813ab27ab48bee2696b18b9a5a48bb180c284859598f6b8608ab5a290760adaec6f78390db60c20d2c65378f5fdf2089264393c462cf5e6a2502eeafd611e71deb1af45b42621e198a686a299474ae1da715ff63446ed7cd9e1e7774b7406069458ce501e18663c2f9921a3e0fccf659eebbd3b9bc56a7ca199ae688a170e730a4df2050571ce21d6e524dc52bc9aa53ca1530d5d06b2140e06a8f18f667a698b40e7fad7f07bdb492dfa27ee06e8b617f3dd7c62124ee1d3bdc09652cb3c0bd4d2ba43802e032db86ce536511192c3fa45bea40c8bc1104b81979b124ececc1e33f7c7f346626ee4fd53a6ce0ddfebee6c444839d1a673c5c4a1626ca2f9cceb6306a6062352c531eb593ec105b5beeacc7b6b0ddefde1cd20e63254c88cae47bc34a68afbf58a38d8d425c5d9133acb61b6e70609a877f6263b8b4b18e8cd98bf82b97234a47b8b540ac4eb9cbc04e80e7ca0975f422e834dccd2470f3cc6f13fc161b8c66975a37a80154afe23fe6cb6511c42a53c292f2d55e60230559f4ef94549bcec5543d4f25d27b8ca3750c50cd086b1ae2303fbfc028969abc68cbdef2381e8b703ef2e1b24fa8176dacfe594d45748442267451caafe558700044f428c64f1c578c49ff353847345f8e551bd4895424677ee236d8f8d1a3b7d71b02d799c90ee7515f5923c190d5b691e6263bb3052e07c759dc7df1837c3a5a5726e5381d3cf90f7d4c68cb4cef0775eaae943c8a9dd15aee300970ffb180eee82ab03f898a120a1a4a08f2249ae5916b6b161f63621d53e30b5857d474218cfe197a0b2f6d5ed86ac61817393ff2940b33fbf072defab9c56f2740d7380003cd7ec86fe197c85f67ac99b5174f3c8a8ac3f51bea3fabea467e7d6ee79e5fc28e27e794c830071d321b39e498b70b8351d7febd49deabfa5aa298e27a47a8c1d03c302149e10877cfe270c2f8ed177c2631cea0e7b20bd7024467c81cc8ded27165c92348898511d9ce8c55a232a91e0ea7d74515d9e6dade65e2a215cc8a393123c66d761b0437bfc0b0e74a407601b4228049d301935f0dd686184a1911cbfc1962343ba9247c86e34bd17fd16dffb65794470d230de0333446d9754dbbef0785a0b9a41c2b25cf0e6235cb0971e32ac9a791bd90038cb3703d35eba6f04c311e576b2f9478b1fb245e1983ebbb060bc13042a970a01ef5ee63cc04cca0ab11eb2ce8be14c4d02fa0b29f007b9235f9619b02dc408ee7ec040a2092d7cec015c0d967d7e34ebf9f594d8f5b1bac6f49962bf8c997ddd2cbdaf233f00572bedd013762062f335b35086853dcdeea243967b8fbe6f10764c76894127b6ceddda7777aacacd0e1e4632f9b99bb6b084361e3718f9521a58bea51f3b037a762788cd713aef9afd6940fcc9d4fd115fee7d07938df6296becd072e0cf0ece33743a61a1bb004bf49f1d3ecba9417d404b2329931e969b796823ff05b60b27b971adf0d7445d8327dd912dd162e52b9b7715385db171d7dd2a822b61ed67047d216cd1d044e1c9c71ab2a4a5f316ea8d9783c974819608242e1484e3e6e290aab2f78f08f7b1b0d2c89df57a2a4c826e096630f505f5663ae7515cb56a039b57a0da4332be3bd8865b4e31a2c1d5ddee6666809892c091c18396b6c1cd556c1d5d5209cb131a7014530b9e02cee153759276430c3baf1f3616b7fa008f947f9ca4250c415dac40c38718ecd6520d8c1067699fe594dbe0e1111657720c48ef670d248bfe02555396de39875049b09b4c6052f4148926095c0c8e08021806c5cc54a50f041d152785051aa8979f868e994d7f9213ab482a3a88ae8f9043b723f78d0c80246da2aa962a9045839387fbaa1b21de643ff73e3835d007edd2497e1bd158e47ea633b33a34d9166b258eca57b1b481b597c364a124c5b2b564693f51c4cb0ab1fe60c5abcd8fbf4ea538ee61bc0470a8c56c76af389325631f4792ef504573dafce2b67c5b311f55aed67c51986966be59f3f5c83b3465886a6a4a04a11af7af3ce8610a453c82c618160d9fd0d6dcce36894d840ed33a5de907cb7d92f43171e155fb6d125b703bea18c47512ac73a38da817e1660162f7b158d4b1833d549756943fbe8f74565991d9e9e3594b87cc963246f5ce0e47652d10fa817b85ac4dd5408f6f7763ecfe87cacf30c2a14c38b795c92b076bc0ef78cc67232f65a3e7c32b0bb7765f88e876e9b57ae8cd60971fea27549cbcfe28eb57c9286d0d765093737506c39127ac441e0503b485ddb6eef2c4667de4ed9d78edd25fd066d6378f888025d2dd979a266d2d2559e828bd3d6218a8e7f4207beca49820ae84fea8b197504abbc4db86828bb3e2dd88f3d9b99dbe0138862cd857ff1299b18889e1a9a009f547699c814c263078ef51b3871c15b565777d4ed8c94500e974279524ad36b51761be71f3ebaf0b3901c74ad5a798fdb11147437b3117fd032216c6869ed332238dba1eee6c7c4249db580c0160ed84bb30dbf244081c8637952edf310f615eb70a168e96730bfd25d1b49304b61ae5e2d4019306446b0790219db09f5c56bcaf72c004d84485500ebf1bee0aa4e0c9145b1e187577f6837f3b90d2f7f34ff004a62e5689044f8711db926a528de2b53db977a347bb2b4366111f7f6b315fc0d482b2d74570a25131082ee958e8cc3a57e95e081496b6b6b5acf74d84aac4d78e54209afe909ee01bc3805ef196b4932e86a76de635ee43d61695e228700a1ab439f342b4cf6c52ba1e30c477fe690c028f4eff47bf7ee87ed7e7f572877e31fb5a27a681973997684cdedbadf918b47660bcd1c94b55c10798d6569bf2cc1f7f056e53c36b68c59bdd1c54a23468c1333739b0cdd2fdced784ea68774818dbe453920ba1bd418687cfcfb0aaf9b8d9e6008f070f27e70355830a8001a0385a19edd9bc8d0516c47d939bb68cc5dc229889c2198a7704d6bd4492e632cd32e35b219fc9d579c73534f0361aca24794c5b7e78964865c30aa35bff8c6bc8f24f83f28abf2d9cbb26ffd58788ae2b0604a92aff5846a6fb1d7a39ce77d11d710b1cf090c6a9aa33f27132b9104ac245704a4f3f06d0d87ae15185cf3cfd7e77427634fa1ab592b86c3ce983a1f3be6af1564f25f23eb18274ea338544dad3a07f62b0ba46f5b71a4ad70e1780dffe66ee753c285e57138d1bd547a2e4a5d1031fe814b726d0b2759cf4e781e660cec2389958be1c2598a02500a1bbd888c7d572c62b6020375b25ebc7703ade44db5335139857bce92967ad5a001adc67a0ea0ba0c2c6e08150af4a6d52cb75779582b900bb6ca7d12c1796783688eef608d2dbd3befc310acb851f21ee8ba129555129b6b052c2e8fb4576d07d7439c4d6f09ea220c098e820706bc8a089c223337088452612b04933794032cd7a5bccd53f7d406c441396761346a3447ff943b832f1c3cca39bbb5bea4e794cae70584779ddf3fdc1fea7511f6c00c37903aad03f60515f318aeff9e31c0bb81357b6fc2f27e16e3262e899b275502ee2811a085129279014539f698720eba8b1a903732b96b268f24a8ee23dfec8812ba39947f222378d371fe4d75214b558376d79f5549563ff039be047cbcd38a9d5df164f62b4794dcb483cdd6ac2b6b82eb9ff8b6b8b4aebd7beaf091713e1423cef07187d236ce175741134c0de668108d2c134a0f82c1cc489b672ca380bb4a58b52e04844eb1b3d2695d51dfd8e68a986d3130d7355cdd74e05cceaacd5956da2668694bf5e87467825435a0ac80e988abf7a148d95cca6406452a85cec15027d5edb95a4e3b9096464647e2c569bdbc9a31f6dca8bd3ab4b0261b3c2d94cdb7bfdbea719c59a07ee93fface0a16934b0278f229191d37d0d4a1b422d6a14fc7e13c0a3d791e4b78542a4b536faffbf39721b68d469b07372916dd26afc9e84f3532a4da51203dc88a12c4535e91252b8329b943b6d02b19a8e95b42b2b423ae2b0eeea7ee30bce3b90cef3410cf4b57698ac8ee609e42679495fecdc0a4867fcc2aadae3fa70f7c35f3af167a7d9b67009f9d9a8acecf65f4d104d6cc26f175515e9184c58e7c54c0bb9a7557079b6adcfc69917bf74edd900eb859853e28a39c084928c0077c7742383ae7c91377eb83216fdc779b20ce98ac3ec77cce4f784397180673d5eaee33491ea1bb6c4688ae4b3d3ec690f3ed4e3f83d9894c28922b06a9ba5515ab84b8680bcee9f4eab9f59d548aa091ee1efa7974b414e7480587f7fb6c0252d0a47ac7414ed6550e7f372773b0673adca2595ed4f47c6bd75de0f560486a4f9dc8026215a00d8665c3ab932bdfe23feb28967e2d3189647ce55105766d73cdb1172487b0578c08be3947dd6b58d36cfb080d9c3dc3a882c0d3d788d87390f5bf1c1db79161dc5e37db82e8e8f92f330b099499d16387def5c04fc159be027170eb7b5db521f8788e600ee55eb68ab7a482e4b8f346cc85e5d57288465b378b036097a22f80bb4ec17738d4057648fbb7c3d25156e8b4704dfb809027b98d5b9684aa51f88f3198e9ea30031d7f0b68a8ad0e086ff18e4907fcbd6ee25926f9eaa76aecfbdbef0d6cbba849007eef86ae23c7256223994956b3ddb28110d72e15dd2718e2b2c6bd5c0e93406e27a8aac2b416ca3ff46a2e826fcfda75255040d28a68e3425cc42448b1702dfb9c457608debdbedc0e8bd4901eeed808211dc0757b1f59fcda484a98ad923058b98c252e4ee4a3f84e38f6777ec79fb42323aa90f69897858d7bf01d9a3bb4e6f99c421a92e54b9a184e314c1124783c56f09d435b7674c03f7e68a082af6a1f4f0ac25c2100e3a597f72cdae0cf461c92abe06519c6095d81cdb2242a1fbc6200137dbfe52fc8c3bd2d1e6468fc4325a939bc2a4e4ada4a354a405258a249280f80efcbd826b76f78a2f0f2d6a6c9a4de7ed0df103d82e8b742a24bdaebb7039668f81263225b536224cbf21d42ac7fea837bc383f0f44de9c362fdd857a266f049839d835fe2f153e01c83f87243d7ffa49dfa80a28d5ecd561b704aea2dabe9fea78841124f6189821ceed73e5efb5027d7a8a8f326e77e19c708147dd1dc5a2855e199da902440f4bf048deeb81c0ef067f680872f54be2f8dc287bdd422eea6178061fccad3dac95a34e1ee5fbade5912de45070e522431f1d6c0bbe49dc1929c10bcf8c5d7777b09360bf80ce7a2dc25812d9ba731d4bb7cd31bb48e40b62a7c27649792153650154af39ad4f2a6807ad535e35a93f3dea7599161312560064098b0c2252d6f30a51c9fd5b9ed19e0bac1bf5b0994a0bc308a7d713d906ac0838a5b060662981d5447d3d2df0d03fc46bf3f5afc2f98c1ca0536bb3a66a7ef4e4e6782510e8843326b89579899d0928e5ce2af9ab26288bb7e85eb09b0d0e9d0fa19208f94e5b8c9057f4b6034df2d27af34337b376d7272729aaa62f6cda541c1cccf6da011c99c6ae32a41b34dcc93883b13a9eda8b1099dd715d24e4a098b046b76852ce233e3caa1d5fc18fd2dc894abec2c893d0288d864f5923b8a97f6c62a490657f31e6580559c3ad756ca5dcdacff06cfdf6e4e9e90da9ddbe78ffb3c01d3893352b9df06e13d2a26ac63ed4d37239d40a5dfc1a45a7a41f08f833d513d20f57aa41ede4d69241b2b33e7646aeb8c3391614d3dad158f0589da09de8a27d9beccaa0919336e734d6ee9b0df07ffa6d393867b10871aee81a593e3302e983097c18ea0b7f8b3be037080f6807a37da49130e369e5ffb6b33d8ee9cd930a66e4cfc2b8d033d98cdc5e5d90632af1e9a1a2b0e98d75123f46b5b9fa0e3ce97c9cff3b29e498999e3ee00bd6b03fb4d6daf49a20c23e7da22d02efef36be4333da46833ed18096a86a82ee995ac0f74489f2d855f714b21a04b77a081ed298e577153088feb7638c366b25f3bf1c2711733b1d27091ea8540cb3ca6860bb610c9308a2ca0be3c8fce2baf89ab795454a11352f300142f7532e1f5964dec52b6ed5531381b4d962c0e99bc4a38e6e0f69a7bf90a931a40f0768ff6d15b92b3ed412e3e979e75ab196afdb57afb599c2013bc1a4f236d1b1e0351a048e35bb7b5162d3dc087b11c1f6a5a32707a36b4233728f52004a0dde4613cfefb35e4d7996e310b3bb706a70a8986c0687e5c66237844c73caa00724d2aa12f376789de82eb271e125e687e305a5543b4d5e39e5d2891f8820d31829b317ad16bcbbdcb48273b013065394119ccf9496c31f6983555dbad255f1258079527abb28cce43cdc3220745f3d4e91f1c755b0f881e329f024c287e08b65d62c9ea8144d35f6e4eb93b13e4328980d719a4d0a1cabc56d0ec1d8952b85232379d8dccff57665c1451bfe179c98c503e3ab545bd26f085fc091b5a8d6217b39f4eaf1b430bc33d50c04f7abacaea3111e41637183026268ec8e8367cdc585bcf1d65e8784b1c0140e0e5fa3a7ca3b4a543d432f831360508319348165a2a39641cc1de8260008179e1e5999f3caa72175b105e721024e5e900b1e37969ac1aa870e861600f7bada4fbf317bb9b46d2837471813ac0732857da25271200aa0297a9fee580de8839222dea3f2d2d62bba2539e60ea5ed080ede4f597c2a3814bb9eec2b0b2e8016a068e2bf005b0814fb341e22bab0bcf288b8407166ad46ada05057d47ddab9cd2ddc256b9ba1a16edbc3ccccbcb18865779b5e30b00ea2ac70a948ec3a3d8aa0d6d5723c8e8d1847a9d645cf2bf3a747253e617cddfff39366e862a3e4caca006fa249866433f7438edb53a999d93cc71d95f5123277b234c3ae849601784227be7fff978b926a800d7f2a6a24e4bca19880f60f56d5f1e63a911dd3129f2fac4d96e30c540d22e2167cf51e37affb2d24a6ab485947fbc9e8d2e14cd45018b673fddb61007a36eec3b39b99102e14307415288d15952af4a8e7b9622d3a285d204e53528de167239bb47ebc8b16ea4479f5c9ec4de206716b7cfb5680cf3648d08498086ff6f7050377fd4b741821f5b56e7399df5ee77d85cede797dff2da5a570ffda704c1ef855e81fe679917ad90e701fe853f04003867a48dda875bae7e8da36feb630d13d727858d94d7a57f3a9e295e064bd7309763b53de96a58ef8c89a8b4836462e5d4629c5a2fd2aaacb723826d2899ee5924b857e00435f5c1002a4c1907600c2e623b4c53733916b898db69adcc3fd4c3146c64052726ba42287cb556cb93562a7486f479b51aa04c1bc7012b0bba8f4954bf4f10409f09e17ed0662f69b3573c6d1bb2f32e513c9f6252d53f2fc0dd3bb3550d65df17538f14eba1fbab0fbba2e0264468670a47e3a46fd69955721bcd97b70bf38d2b2fec0501941580943f74fadd3621ba21369eda7674915d5592cd11aa919060e9618660f02e8539327ac4c2fc0bc7d5ac88093857dfef87915c804a686695379152ad128e7b53e1a4cb2bbeae3deffedb4db5268efe3cfb5ea2e2dcd3b7495f3be447dd7ae0a3df88438a88f869582a48152a0961d9a7ec81e4f9e3b4202c03f2f9b902bb19cdf604c6514ebccc98f5c31c5c809ac1a4cc5b87c29469d0e84f4a3fc741e200cb613acae6f2f3a9d333ad92b8a4db696b82bcb5887ee381446f8f5133db41d75ce586fcf285158e0e3891875618bda110466d18446ffe4717ca96c43e3f77429bd6fabf7002da6d9244194fe18989390b5df9f899423cd9885ee3fac574513401068a13435f9a91775068e684cd02a8e5989e6241ca028584ee8d970deda6377dee1a499bac05d770492c832ff1a3f81ad880004663fa9e81a5f7abe7c4be54017868fdbd8ab99d29e99a4f40f4a3d6e37e245b41287f56d7bb3474b124cfb66119b57c31c450974f2c8e60fe0188e56a23058c87eacd946cb7d958d12738db78504e286581466061549dea87e39de31701f168231d0da7492c90f6ec264dbd323f88da7923906f6230e6007b3b72f04ffe3128c971885e530107015f2ea56c899077ed25c0705654551b9dd1304842d802d24cd0e51b729075e46cbacb6344f086ff6c262f41b5c01da7e7d8511c2868ae7b019128401503cf5b527932534d2c9660b0ebb5132e361d8c2edee9e94af89aa7d20cf0a79ab5ff444f9a5e5b4315d84bc0db8030a35076ab934b71412781c84716a9c0a142ff51e4667f277a174ff1c3d9f57895c551bd3854166c97dcf3491539f2838a5d9b2f0776a7a4ced40b75fe8bbca076bbe82d422633acd255e6588a800764d489a665e6bf21b6b8ddd9f048c2ea20e28e920e0c2c8a61ce9695fb5de01cb5211a66252eccdf2b7229a4d35491efbd79dd21923494f84dfdc5ef6496f39aff91fe4d275d8581afac8f3932efeda9dd811fff2efcf30d9303d0313129218642117ddbc9090bd959721574618e574aebc3d99abdf616543cbb5d613e812535a13e32c8cb76d05aeac4e9b01181b3b98514896e7ee0f133ab5b70f2fb3b2bb1303a3ee996a5191f99fe2ca4ae13cfb263fcf8f70a87f75902da72b4b518a16c0e813552d7a2bc0cd092c4b55a177b48ff0ae740f89d1cbd15732e78f3406043b35684bae4d82941ab2f18f8a4af7d52eb08428a409cc7baf997c77d06712183a63de6bd19a01b919c36be6ba8e1d092628abd0345f8576a04de2e259efc10c551e0bda585425025bca5f947b3d3b4f353450fce9cf31ff95ca076ed62c2829d0e54cf4d7753c5c06ac64d1aa6e5206e5d86bcfc5949e6b9b5af8fb38304111fc5a16ff563960ac56749d8515bf37c7c5ea0c1fbda483f5926400f8d765ce20cc013723161eb5c155256ff0ed1acae105fce00b104a30e6cded9bcd73d023df169c87b29a89701a5dd772210ca39940573d97c3cbe2750aa041e4603abd8ec967e86c1f7e68d3286ab4cbd2a9078489455a268a9aaf838c0bcf355383757e42ac3c0e58a13eb4d4964374a8cb2edb38b69afe92f283fb0c68b5ec25c547d2b27a028d65ffde50d1dd6d810461008e5297bbfb0e56e688cef355d9715f3adb549493073962b9982229dc9b8b26ba98fa82ecf0bb1de19358cfd43e065f14dcdd252951e6a9713dd5bc92ec1b543c24838c2afe06eea3c0982006de04b4fe236672666afa73fb863526daaf04531342c78dca98aeac7a06c4cb0f6bf1752eb48b11c2bb6f564cdb4a85fbac59fc27a94a97b1d575b8f9b8f32866544b756966936d810a46fea5723d11e5ebd5047706bce9c6a9315e5f8a0bf6a10feded220285b2c5782cdabf279e7ba2d7dacc4aecb4db9f6c6bc7da6baa1cd6ecaa54ade1b7c787a05bd79ded6211cb39d3098683827bb13b4429fa0ae019bb80a457925a49f7613491ec163af6a4060a2c9f9eebd83411047f41d13a7f90aee823cfa76d287c65c68f144263a150d887b5602735fe1832d3ced915ad67acbfe8866a59345fa5f9b540e632addc40630a30c677a9b52a5a5f5cc2a5fa6a0cf66e99c8feaa3c843b49be8626fef7d2469267b265701ca37c464ca0b25df90d4feab7825f8c6f7c8a884b0b482162d28c4eb834b912e294bdaeea1dd5217ba3b1b95e4e5b9d2c414aeea401515812b4034ba550ced3831619e8245237bb905afb3e9e6ac3c4f9873e920868b02e7d860634e8061ad9d6da745bfd3abbaf31ffca2b3740c0e637816df5e4d49bfeac197f6f190588b140f935c11d4153d8be7a83d9bfda24aa68087cf8537c406900b8efe1db18fef85180cf0a4f1f578ba1c752ecf7b2c9401d8d678fceb923ec50ddf57b3046de0d0755592546e2a7ee4bf3c35a44e054a0dbb183be2f4b7eae6c3d77ca25249675222b798e1ef489201b12911df9db212148b560de6de4972e59682015590f7c067904376598979ad2409a0260192ad6b47fe265d14b8915f07fafdd5013b12d3c9f890b2294acb02732f82eddbe9158265db871e161c86f2a6bcb127dc27e0608d05a5e929d978fff234f6421671d207320128afea6fc1942241dcf1c909802e6adb39b6b17f6bf6c8a2a77e9f93cbf907a089e8ddf57ddf9aa7e3a462962d94f4427f042ac2fa0315e271f2bcd71dfc9c3c14797a706befccf6347eec97b45f76d6f8df22d01ac8f1edb50a10bfc8d586bbf2927dab1c7db0b1b8745b963a5f62f10f96f775cb3bf149e08c24d22fd4360859d3ee72f05414e01df5ac9581cc0eaed8264de25cb2f600a35af7b96c30f54d4fb08c198bb39c6d7de24477561bd0ace7d4094a5f2e8255a5a0ce28206a64b6d1c902cec0cc2a8d597068ecb8fb209dc976657c0d41cebda7086f86348c2e824d9276dc9a140d5dadc3cad38e1ba5945f24506938fd47c293dca47bd4dadb923624a2c8df276f223b9e55f2329ebec3a6428977fede9e4b9022b904bd660157ebf7f44876e98c8dbcf8b4c798d2b050ff2cb4923bc432ea0990ff8e714c7da7a8d0f847a6b06469472e137cb99ef2e36ac32218cff78332e592295d8088890ebddfc62d3fb5ffb90a31c6399d2fa3c5ec7d974aa8693af78c0323cbe0e02ca47ea4b9dd7c84f95fdcfa8be85022cddcc4ecc007232bed4e9bc3e43423e85d0290ea88bbdc8282093490773da6120513398af2efd9edbd6a4a14531b6ea58f82d2c117306aeb8fe4cf6d14af9a109ca08d3059a581d5aaf7087b1a5c3e406e235c5877ee50f424e9fea5556b32b612c83436ad7a20c1a61880497c35bced14c8193a5d3d05cd97ca1b198ba626538a90ebca9fec6a6bcb320f6d1b5b8c9f4bea25b99053c970de422516c79c27990984fa228288852a09d3cbf0c7a517bc9eed905b7203812c3856994ff1c0fdf5ef8ab57c4f1e8180530e9285ef21464e12f781cf9b49efa533fb54f8e1ffe576586c536cca0ea50da4271a78384bf08261b6730a2a4f5623527353e998a51bb900dfa53a800518dd83f7270aa766fa7ec1f92e7e8bd1630b7f5c877de892bdec523d511d781a3d33c833d32a1032cf5a9922ccb8bbb6635939a70557d6911f39f9f08762697a523f1c13899b1e6ea4352c8ff3be88310cdafa2725d23d081a39f018e628a32eec5b4a9aec10e81ba88bbffddbed841985ad0787869ca604e8a19d9ab4d161425f2d98987b4709887edbbd06ba81c4ff5bb93d2d25fab599d8cf6dc8f30a5adfbad580cd254f77d80269d546fea2db2f8ac7afcaacc0063fe78f5d483281ecbff62b5887a8d07277ebb63ab12e46e4bbcc1463d71f7d5dd6eb2215dc3a2ae47825276be2653721fe4f0366d7cef6a5e0d1bb6becd6585a7900051d20a8fc70995e42fe5744ef29a2df8891b43dfe706b56964ec7f7a2f1d88f0405a58a6210caec85eaa98ffd5f6de6115a6ad6b708f9b7093e28a1c5666493492e900704d9efa46d3655f16a196a898d04bd85ff25799b35c3bf324a454b1398413a5888fc8f3d4f8ab0007751abcc537b899764703c73ca4dc278810e6aa18829b0b60bf9b7c4b89f5ca9949a924b00c5d97fe8d2448eaa8931c2e5b55a7b16015476a4a42dd9e6cf0042207409b4cc44776e9bf6fcb0c6c04cef7124836d2f72864e9bf90458398547ad5aebb77a933d14fb6893a41701bf12ae33998d84ddac68f3294f0a7aa6209570832f16af9f076bff67c78b60c3b85756703877bca674c3067977abd07fe951504942be399f1a1674910e31db188b7e93e3935601a92cb3dd37a7e390bdd3777416698f26aa105d9ce59af0a4ba57b2af4865f4460ce0d4d0817f4d1a5b47bb68dd3effcbd24ccce67050f929651423428fffc94e8b4334dbf78021f88400acc5f525d822c8a3fa4926729c565c8dcbc41046ca2cc3a69813ba0386c7b24b546f8e9dd7b9522f6b76b7515e6956d230c0d540f5d628aa1fdf5f2dc2119fadcb2353ce57f937e53dbea082c08e5dc46e3c7b81391c4a8d6987ab7dafc01d1b4b17de79f5c807fd0a75b7ffd33b89b2fc93d1f0adcc3de43227b9dcf7d4ee70ca87f4ffd79826f70f287bf04d66879a89edcc201ca87326656c7e8c00b750a86ba5a79904e909d04d2474a25a24b190ab58de13449de9386888a886eb79b6a999e14112049b631d643864b2bdfe457a190d4e257e74504b0b0f4bdb4ba107a065b158377ff281744a35959747b9fcd16868206f94bb4460027fa4c6f36cace14c8d533a8ea0a73c248f41a1bae943925ad0d5fae931e6a3a73178c79017ff6f87fcc39f6a1f40bdbe7ce303b3e29701718a39985bd499b29ddeb6fc987409efcefed6c11baac66c9e10cf085c6278c3e1d85cd4fb97cb164842aeeb121231d1bcaf78eb45c8f6fe2a29f70cb33ca2f1ce328e57eade336b6cbdd00d5457a661bc8171f3d7858b7fe1722d19ac953af10f85548ea6461a5582ae9892423cdb0de918f200d77a1836fa3da5edb3c80768002ce39168129180b7f0518072e0a5df3f86b40b6179b5008202ff74a0e9d87163e0aa527f84be163c4277dcce56676af356465245f617a7a9f7ec7f268a08a68f0f8c28fdc678073a4e1ca7f7d310ff7693b377e043c54ec337449692a8f8abca4399bcb0fba3f860ef7302e2ea2cbfd9b1d63fd7b50575685a8f8456dd9f40eda5b7c1f8b57c88d3a4dfecaf4decf7950e380730d52531a6062be684dc0d145c2423456eafc61b6eb407c41ffb1ac18268dad980edd8aaf7581bab41955f1776594ba042b7b1919302eaf9fc05e2da86818c8a1450c225e9131a09c5c28cb9fccd3697f058bf9d4f096bff24168583c2e16227abb7a9f6c99f85cb60b250362edab9fe7d69c3179c4ec39b5d337d99e8d4d8ab93e0203e3dcc99364a0fd4e96090f86e66139a998e35a9cc8597774613c58c5ad4667c512cbdf01f3fa9a20084897819807c3a800a2c6775fdd1f21ae9b5f3aa3d43817c14e0bd03b529a670dfa46958bcb571d7d1724428fd6547ab58959429b3936a3e82117b2648f2c0f469282377db1a8ca67e7a3b2dd56809645e660b7476c39fb13a4088dc973590fdcc8774a6c7a9e5230ea3b422bdb86ebf47bd4d96ea1575d045653829b14375dc4544abe0ed231d626446ccb96f96beda47cf9cb8ecb1939a722997187a4d23aa7ab74edccaff99c605c2ecea5f6a3b92426c8c2fc78ddb44300f980eb43c26507215d0257aa720ef8cc70df76a74519e73c034fbfeefa1cdeced1f7d11bff05f64c0a80c6bffb13926bf331e3cba10fce366d3a7d07829872e92d78094b24281bfc4fccc068b5a1b81a6bd3000f32d29e864b7d1fd7e86323e3fdcbe82f49ca9071772e9253ee7f91866f73506314f872b03d9d416a9bf35b1ef692a84a366de22473624759b731571568d08fd02f2dfc307aacb7e7ad13b7d489382bc637d5b6eefd2a3ce5cf52fc1738e9781a1bf899e507c9d13bc903996159771debd09453f3a4a2ede788b95df04de84d005c441e5cfe6a2f5542c0ac8bde886215946cc350093880333d9dd3f1be1b4b9d4310c328513ede2647a076d15cbbd76d04815125c8aeaf080ddeb58ef7af69f6e09115816605574f3b942770755376a377637ff73056a61e73ba840cdd4c02e011fbfa6ca05d2eb7763e431724611b5dd009717290edb7a69f2262406c1b7e7a72ab907c244e08554c2a342fad79801d70652a64b0e6adc44e7c3798d4b000e9911ddc6809f341740aa11bfd80e29699104ec5f254884a70a3bce1d83e4c1463d5360e75fd344429a0c16ddca9b218c716e2f30e797bb385f5c416a99f58eb9a633d60954a9cda8ea56cf8f6cf57c138c61d7822fb7a09c05a831a2e9011377eaac9b9c80c5b2c3ea93d3e8c3c6b9b09172adf058d5309a5c866226dd983e8525266a99ec7e6f2194722ce7ddd814d5a1577f2af0a9df98cdd2bee3e4941d71762c2f2d6996e023e3e655fca87a7b2c51a3829a8837e6b214a1ecbbcbe126871175e0bcb8db7935024cbe9cbbc4beb88cfad99affe003feace4ec901b14818b8fc9612202785e759b8c4429703d0e311342e883a33ad48fec988b6b225cb5e57e2745e64484371f142a491e8570f5ee87c261f46fe86f2f9da609d24faa4f6e6e0bd3eba3ed7bc8fb2ffa449be74b8c3a94bee77b6f44a56b2fcacf4af2bfdd550635ebf4947ced6eaa1ff7cb3bca5ebf95a5de898178d12be44357bd76aa24d4c64f2ccc4f34b94f91f828cdbb4f1bc50733b94cdc0e8bcf9e664c8d23c1aeb21e1f6c91dcd0b0538b7952294679e0e2d939610510e64d2ba9263d645ff611c2f14e8829cc435eb424fb993ba768773fc913e67336a5eb5327b83cfc0f85a27296c5b436fa852a723a6aca5354d86a514cd23521b9f8544bf50b50c0b9c0b7916e924410aff8a0f4c8c4a03099f3311125f5fbb0ab70560d7aef2d1080262e35a059a2750e175a3f63602c44ee533db6641a0662c13f173da80aa8633b16474804e6527539663f0eb6e174f7adab0afdf82e3b0273759b8984adafd971a5e1aa4aac17a39c928e8741d64c304a3dee0ce96304dc452b1ebbe91a09cd291d3736f1b30406e7897fa3a5fe8f1449788e1653e19a5715ac1e0dda760ee984800924f706864543e5c7caf97866df0a6411be26d83582116e96512bdf427018bab0473b9ca827c89f78b5895251e8c048da0880816e7d174e3f71abe73fd62159216f593a6e0356ff977f6276ed44892f0bf05bb788714b0d40b6fd56d0ed61df787ce30384824edb3bec65307e9eed7658f6cf67d5f1d42e9783f6e9d2ca35c997b90979a65c727b3cd123c48698826d02cee9313cd287d348b79b91ffc9144150ff33549fb6ccd221531420e56cb6f76cb5383cacec07afa3333dd0af5d1de62eb64498814011fdde22d4c6f454d9aae37b2194aa6e5f7c16eb78542561d5101951daf37a18156063224d74010f4b24232e98b30ed111e982d89b9281857109393defe3b6ab650c5f85d426a47f3b92ef55508716a8ae77d442dd9b9dcee60f56ef10e0f4c659f2e77692d183874a10170f8af7bdcab3242bd67b6bdd3889083d0a3bcef7dcf1f7dab9382eedd36ad09b5ef5bf6bf847eafdd52f653d366764cc43cddf781a5ea8400c8b1c4ff3c32da1efd4d8562f94d810f76caed4255fc4fc67b3004a7cf003f04fe854a116ff6d30a91b34ffdc0c1e1192695b9cdd0fd83b11ff62be68a1ebd124f0e7f879b518331686c20a70b980d10e00dae99c7f330cde9fe54192fd38ba1661c2c400e1f68d9e5bbd7a56d781374781c7f99bf8e4091cd8ef3e69f6a6ce4d9b838c445c46abfca6f98b9d486e59f5a90dd0d46bc1e6a9f0029e8bb8336c9f62c5307d0b1dd933b4be5828c3a587589556e0ac349bb99e4462b97a71dc222304da4a05ca55ae6fcc472345c022b674a4c0d885b2cab6c945197fa97015bc5453377b3117932f12b5f5bafb6c1179006737723652bf697e8f47e045de58080f652f027d8b0b0631d12c530c111c9bee4395a05c8aa2491da4dcb52331fa89e91bac149105a851de45cb6ed0ac44fc0c311f9f631baaee3bf1bc980a88eaaccfef09a899f7754265b8005fcdb81ec58ceb347c9ecbc8dc5eec1044a4a8ecac1f35ee54805130b592ea2b559f46d6c400d10af87d2becdeba16bc5f72261d3ebab0ad30fbf2f95df40a74839b782883afbec64cd72f407ad8f91ff23f7e5c7e9f2b7e5567c22271074441bd7b26da9d670cdc7a94ec0df8d59cb93c06bc465c3bcd19600a1e559a0bdec75fba991f63085360a77c14d63388278926a78137ed7ce9aa18c5cd12c40b2f135b8d0b1542ac14d118ab3d1423f055b59b0e694ba23ae6cb1edcf03aabb762aeec7a3e7f14c6f8878ccfbbccc1d704057d07b1f1cbb84da6a4ec95e26418e8299ba91801c0d87a232c299be5ca11bd9fd7e660daa7441bcb619526e617c87babfdc3e2d516044bc478f29176f1a562c628f85c677a18c64e67a612900826e592d7ba6d0e99d552ae99687fa487b13a213e9f37b4f970db4593e2cd1ba48c1fcee2f6ceec58a00a37609b5af958e3c62d522e63af1c06548ec8f6b352527c7464434f275e852ec32b6a4d867a88d40aa81c28a3483552dfbdd80df358b9dbd9e4a1a7a3a099e7d6ea40c33fbfd867e8cff4230d5376179793b3a3d1e6248659f9c1019bb90f882a9f999373563c18390f0f03743f9b94a0b654ce61dbb64a38de291d1f559a3fdda17d616801ba9cec12340e7fa2c2c51de1b1439ecbc41154b31bbc3cf4c821eceb7aec0c6c31a5d8a7b1e4e7c42a54f8c26d338054a461d3cda87e9477d29aba2b0219a4b9234f215ab016363edba4525251ee5404cfc5ef9c6762488d10833ec64d3e35bf65c8d8435561947513f0a6b5ef0461571e5bc30cb3183b2b7dd9740782582d48df87df867c17a712f3c50359645dfaaf6752aac3791c8f46053b452133eed13ddb59ab698a7dc40b7ae0e38ff63d7abde792053832f7d3904c1378f4785ab8b2b67e61e764adbd0208fa92ad0f9d7dab04068ebcac501e0b9a5901ebfd8e6b925e3aba6a140fa579ab2bef5daa1960964adc361f7740b69c465dcdca7640e1b72c9b0981e553b7a322966bab651697c7dc34a916d47628f09bb45c6818b0a7a4e1339364b9e2882e87c67012c423dc2e18ae0e5465b6dcbcbde7601f88ea11e109fb76653ea2b65e5d65028bbb7cb8038250716280d576d22bf9a157eddbc51b8bd4b8e7bc5f1ae3749c40599e8d8e41b81fe351d991c67d448949427b1033c1f5c63c167a639dc1e907261614cc6522259e3d340d9a7853d763d56c648c25b9b1ab3082fb118d5c81f986866afa1117fe8bb2e0f34446780ff993059fd1d889d61a7954787e6e6f5768f3e63b9fa478214b3d988401d70aa34a077a29ddd8ff610f62344cbbd9e8819abb54891bfdd41e457b8a1961f7733a3790d34e7346a12173d4bd032189cf60a25fccd2c034fc62fc6558960e1e85cd45b0c169c0e481e5d936ad207b6c1c701bb0b265ed010551a9c47a5886e62d2506083e0d48263d1debccb06936a549527b853b3598342c3db6417fa51422f7349c8276cb9fc103502d6537f6270df28407acb72fce55176accde81471b6ac67f52aaf1541b59080019965c9727234831f644b4b9c1d04601d6ee923f2e35dd450236d3fc348c1deed151ad92410667c295ab2a92f04487232facaa371e0b5582f71816a387407c871e09fbf1578ae4e05772888c42e733b31939ff5300c07423c5ddf660c434067101497ef1492f70673e2f5de8c2c55286b35a00312994ae2f35088a97508eafd8121b1c0b7f2045bfdc30266d5de10ba952535d1734befa4a43bc6ed0f9e94ee9e4e8eac851b793ad9297f852c0504bd1b852220374fce43b3aac82e339c41461deac67215a30edd06405ab17b1e163a799065912c7f30f052a241b5a62c5c63b6a1669c018cd521748bb01ffb08caa9f19d76b8cefd441c8e44b6df159c7f34abd63ab5e0db7836cf8bb12cfe583dbb109b4be8f74ca0e98286afa24af72ed105808da46ab0920d77d3125af0e57f3d9664330f92a91a64bd63941992b47ed5964f3f4185295694a396d78d8cf998178637af3d1dca7a3a98a31ce7794656dd9b2b016780e974423b71a8dea68f9d58a502579eb97f95119d7b460eccc35fea66b0c3611b8a6048eb7aa865db0654c2cfb4482d9c91f4e7976efedf3118bf3ee7e227642b12346c41a083bfcd22aff057d2a45b8b61f34880b09b6812301f7310fd12684dad5196ffaae14ddc9e7b306714daa8ae51d377863979902c76345863f48f3e238e6fe04b3f53eaa93aa59c5c7a51ead3a6c87df0bdbda955b90657a90f251a0d7c42315f54798161e5041a50b179e2b6c3b49a74c9adc40f4b617e65b72f8a5b6951d0925c2f0a949f4976673b80417371e279793b4bb0efe38168144b6c628ddbfaca0035c68c17abc204b7b99c842554367bc211e4232b06f817ebdc40a22ed03782838e2513f452ced9e20ef310342c87cd3c5141df4d8a59c9d495aa27f74a12c66530040d611ca61e85be4a4c71fa05e5a1dcdefcfffccdc5ccfb7d45e5c36c922da1317eb73f09a0d67d245caacc269e4500da5feb5a2387a267dceda1f509eef9b0cf789882bbd5bfc702886b5846a23a5b5968801080d12064ad67f87bf11f2e6a8e50be368fa9440342e936202ded0392a7582c5bc176517ef34209ca8774b59ac3f375bfbc295516b1956e02d2782c377b477ffb4f62996d13da4a94ae897c5742d5c950b79ae44c8c851fbd0f6a465e52154e06950b8586efe5a53633a96d282084da4cebb298d03d3bd71d7d4a0cd6ef9540c64b9c8064b1f71c9c8bc603499869b1508619d2fc120119612c13483e554626e16cabc3d81fe2ab285d08d8b8be066a0177bd6fcddb7c4c99999af81cb76bb58e50fbfb011d290cbd821421b7a5abd98b587d39e460bea0d6948b1f70b4d3d6fd282ad74f4fe94ce45d2f2998cf98acf34ee1f72fc203455ec3b6d7329605f38bec114bd82def8b4d18bd71486bc370456c586bdd9dac1b477e0dca78c766346f19cddcb5df47884730357df5ce6c3e7cbdf3008ab5e4cfb04990c28b0b76f9f78c54c9d533a241667c9063114ebf0a07d39ad507ffa40f7370a85fcdfdc07b7d762189c238d5565bda7a5cc3b058da4ea90d236da31cf30320edc5e01dd5f88253e794589136e48d1133c9d03ee84bf7d5d23733cd48a44615c704d1f73a0667f78c4b5b175d2d705b47dc0d283aa0f958651ab7a26628d07546e22bacb69f321acc5ca1fa67e7f7ee22efb0e2fa56294ded428d47d9269b2fb33731b3a5350610b9d7e84546965b2145a40b0e3c281e8ead68be12519063830bea754b14369cc6417f4a3fd5883dd2fcdcdb5262b694b1cd277037a7e181c13898b5d3d9438189c1874afc9bd65105a537ea677cf4b9f97c2c0bca19c83276984b9ffe02d4c748eb9487f52ac827d3821ceeaf2476761d370325d291532092f985833c08ab6617b4998e70a82e6df6cf5543257712a356f9da43c38c413ac2c38f539154df2cbbb75defae845a631ce7e5c448dbd5f31a51dc395211a5f5393ebd0fbf8e74aa91c95bbeea9dcf89d6ada8a579e774cb8dc3ed6fe1bbc5d82a26a6d0defe1a58db779aa2419423bfd3c84802b75efe9157966d39aa0bb5c760d4ca9b34bf7261208aa13288047aeaf273cd184417007f78ef54f774b70e082c31ec59f3de62fb45d964055a588594e36d4a404c4214c0116a88178360fccd68ea3e0b72b0e34138d638787b9b75a72d8833a9149f0c263ae6e26e0a9678350833df0cf887f5f46272a3ef68062ea9e9bcf1da95e51f94c8fd0d9613f611b94d76a3a8d0d4c404c7bfba044e1ad6d20f45351b61ba289ca8f9231cfb7837ec8804d20e7cc49650bd1c66b7cb38a31910eadebc0edd1d6837338a5a5a3cc053e4da13d575934adbd716d3804644c6a33c5fed0abb40dab56394bb9a904e0a6bc5f3f0f5971c1687a267b7deaf596be47eb4450a8dcbaaac9e5dcd7555275b08b911eab23da669875409c99e07a7a3e1e2697f4c353c70c0e83e536259916243506a58f10127e1706b11848a54e296eb0928aabb77a2ef21224da23db12696db3d43c6ec3174d577f4514fe9ac31bd2ebe1950d85b16b7069367936e02afd1c4fd1acdc2f3c9d0d42656d9941c3afba91ef532c6ee262b334342434678ad588a21bea736efebe56c67f1ecfd147a501b474ca3ce61ca23addc2b020f8262a9b342a50da2035f080b3ba4ff1a35d2b32635cb421bd92e54a6ecdb156e0e0fd0a7a67695c373f18a8c21a765c4fdb3a5eab08ebcc28e073a678f30fbc0c31d38987c929d6f3e8d6db204fd13d740026dd587bc69f6b3a250a536fcb0f5bc4de086f27b60c647a8c8dbba5f3588e249795cd325bca87a4795ce783dd10d60b8b4acd4ed43f76ada0e3091520532ad638a45592563538ac350f60d6ffe2dbe48bc305ab65aafe361267487d95b0cad1c7e06f370da1871c9ee86004aa8dc09cfc7b94613232e7103111500a33036c168c04c95b4670b4b238990cc2f521c4453e07707928eb00a3ae7b07eabee13a5b64e6e89c71db2ac0c05882afa7279c162d30bbab597193aff104be543e568d0bc6ef2ffc51cd1136f10701fa5f38fc66c854d234257a0a2dd6fb656775cb4511853c51dcb4e5876f2b92d892bb7972a4136af15481ad89f0e2556eb0b3419a3feac6606c6906308f923535b624694cdbd0a6796cd9c73ef3392345a799ac2647672d3bbd07ba335bd9e04e82c1a2c3725ab651b09e0a94eb8234ab8ccb20a54f2e6c7757e4f2b951e43d8112ac8dca14a78c91d361a0fb6b0fc6777d021b16f15c25cf7d44e9d51a2c2e45d8fe81cdba96a641ffaa814f75ce342c7ef6739e343ad9c35f8be89663431bd43e30afbfc70959c0d554243123fa7274dd265f1669cf25a1151cdcbcd7d56b70ea1bdd5b343d4170b9d05f162662d9f65a88d0e5235751d7fa0fbc5a3828ea7eb6a44711c55a2acdce278b44b00346747cccceb7bea159421a209d58dc9bbb31fabc2fb94957b1a4c75a4d7057a07635f75e820c87bf67549d304b13841fc8faa0519d73f8ffdc242c77067b2afef33505e1e5e2ce4841f3772d2cfef8ba9d88f8ac7fe4ff810fb051b4ad6d702fecfa3f0f9a15f1dd2de174393e5a2ea3e1d9b9ab8131ace50016d0a852d9b49a60e1231d0d91ae9e8d7073099bb3b6681f2d329ed8c20a2ded29dad5b81f037dbea6366b9565bcc33710d88e16aedd6f88b28f24c287e2f23507d56cd741b5552134642831148dfa7d0c117174cbd862ed9beb239c962d0b1c307ea1244489d389adcb338ef971de75c86ff41b37b7547571f21596b076f6815b4cb69324df62ae5fe099c505440cca2bde4917ec15e03632acaee59a4d8751dfb8f233e066d499538f28cc1a79c80ffae1d6a3c97e14c6397422274923225105990b26378dbc3e85b4b5a91a1e84757412a707cfa9083800b70df264fd68633a578b30a0c6f5697bf12b8578be69e3ee3a3090102dc7472d3b4947e98c5cd89a31b8583b5e01edc036480884bc86a96152f763a625ab56156ebb3e9d2453d0473c8df8ff204715269f3deb21a73ee0aacfee68e5bfc020f22048e11e298c0bc6827504933e9409ca3faa6375c5cb8ec8bff30d03ac6970f1ef9fb9f51fee56c1166d85e261b654c41670a7ebc47a745830f69b7ed3d4ac03b80bbfcc4333c55ef558d31fea463f2b3d28f0a9df8bc8bc8221a07a2ff08ca00dcbe7d43beb6423ff008b0f63be1062bbbc09888f17ce336f17681c405fc20f990394016eac9008fd577742f70a16832477cba2254271524beb4f1c536a9ae398b155373465bab1437c5c03d486caa3e713b29fbdd9f59f028f6bcc0a8a811f81e9398b8698466e65460a1a4d239478a9dafdea414d0135e2d0d0a67f54a64123d71640d4e5e9a551d340bc5721d317cb166902bcf330d242ecb1d7fa4820aa641c5d2efe984baae9b7a0345e469642b86a2f4e77fa36d1b900e876cdd848179d236d967a05795c11bf438b5df04e13f1be78904bbfb99d84b13cfbaa49923acd6e107c91922db285a1f4d8607c7bfd74c1e225c38f756cea268e9123a84ef8d1fd47f3b9a856c194c644f76f2cc4b5069ab04581e3bd16b8608a626407752fc41db41ee5982e18ec227eb58b0af2b3331edc566f49f3a912254b63265aef719faa476ba805dd705a6d53cc010b011d417e34570ee875da7f947447676ee274bbd616eb1b81a291664abb8676372a70639d40b79486e6a10b223a16d3cf89b15b75f07a7eb05260b84d59914ddc88d9dd4781cc37d662daab5de3e3a2a12ce5783e7b744a830d67595d2d36f94ec849379161dd8ae165aa90204d73008011d6844a47161de1b361bc2caa6ee81684c728e3fc6c900d4b551d477afb4dce498326dec4a2a6db0b8168f82121844ea4b4741a381c84fcf9f74df0119a86ea94c96df100fae818add15ba953560ce2f3ce2056403df66050fade7e7d3674b6011f7fad2e0357616c72b22b929c006d8a8888a2f71d0baf12231edf28504d789660e788fce931b8b83d50dbac8f6f9ca6bd533a174da093418e8bfc7fb7ac84bd9494a89e6f8c8dd4860e4bc24ae6036f3d6fd841d82e046c5251c5c5588b1309bd9013b27b3c61127f5d7273ad6ff8014bc661ab0211ba334a1f1da9b3ac2cf2f1ac37f85f1d3ec10c44ba49c80a3c86df408beecb7c2fcbe6ce6aafd8ffb241d53a110cbc63ed80eb31b7eb63702f65027908753f73dcbb80e5fcbdce56c20609e3816972f0bd46157f5a8af1886b38b3cec0aa42f7fc7cf660ed1e925aa4e2308d549298d16ee79c4a32219cd3f5f5c244016ed34857dc85e93a69eeb81b43d08bc310f38255ca337ab0e0a44d959cb6810ea75bee14abb6f444378765dbdf1ccb6c9818f4f626d92ce3aad61cc2f7429cf3965f2d420ffc45f3238da6ccbb77616cc51e013b1338b96f7ce1fec8d9fe08e502ab507843bb302531a9cb2b16adb4d89732170f3dc4347cf3f817acafc379f141445c5559263e57c88e400865679c25112d00ee4951a7ab657eb50f7f79904633eb5f904bf08a10e133ff306534c6a963192d1ebfe80366ff92cf74e42d0b35fcd4a2f3a861d843ddd863133b72c9d0801fcd2697a79965a4421177e87af5366a2ad6438588b48b1f95c2f983ff700c8e616c2f86af6ff2a2cd04890c49a25832baf7cc8c585ae9db253f60204a5ab65876ce98f2bad46012a48a474df47e38914adf1e9f2959f10b2851cfc7b0c222017ec0e91947f37640c30c5131faa6be6ef910a0c8df8523f5358a96925b4d4b90a84cdc3594e38eb989848a2141bb8985fde46aa6a1853a853df526c42fb8036823be9e06173f385e110dcad736a2626aa9eb42c41269fd7722a5a297ffdcab86612eaac5873021c26f805c5d371ed8d984a4559ad395b700181955e731b36025f7c1420c1cdf0632ea128f99eee0b9dc1c5d9493d0d2e34e3464798cb01b7b9b67ad618426482ff247d5f6031cb0319c91e95a6ca02ae38d6950001aa6d2c93d722bdae634b76a46e79a6d39bbded7de600e0c1455173444a9dcc06f096b959a717f9566f74dd202a54a838438178d532ca3e81c0ffa6a4f9a8ea5f6628eab0404f29dca33293b34a42a339475acf4ff658461b0fed5a0a465feb212e059a2f2b984236b1d11abf960959f28a241ae98ea46263b30405430531f130d3004c46e20cff48cc99f397c91f816b82651886d089f292d508fcf61b1cfa9a3764c2947d5e6af0c17fcf6c51c06368bb443105d4d3b0e1c65d11525925c577aee3c0e29cff732a36b9ebdffb1fda0e797cd953b964d98b6dc4fdc49aa87d7a2a4b108984bdf9d342d3572abd7f5510e9f90dea3c91d70f113b8859d88715a389190f6eacb057b98edef9f550e67cd4bf2c4fa681d75316e69df8c3877394fe96c783461e7b07f174d67cce2f1761b709a94cf2c6682d4a170abbdf7cbe99d05d5e536cc56212dc8b00037d1ec62aca65b231fc5ca0d0560a1ed9a70e32eb42164c6a36d686bd1224e6c5fc6857c34ddfc20855cfdf6d9f01d67f6720d6182181578bd3e8605a2dc21606ee528bb952b262cf90ca3f7eb1fd3d88e36338e8932474990a790cb1c6f71388ecebff2260ba68eecd406bfed872b868121d1534fff63f52949cd7c9e78784d8c3930de00e4fc16869c4a1fac9affa936715e94274b2c3310cbaacfbf38efdaf2a0d73dbded9a69c1d87398b5b02c2e56c060d010ab247b91c95c4bd124de56360d58d837000a8609d159a621d15b89b5bab96759e54a1f82091f5f9058b155051af6a5c598d35e152f6f8775c9923837d19667aaf9ac65f56a3ec4796acdfee21e5edf6d0920229aa59bbe7a59ad81616e00cecc6cfd64700039d8e9045cd61860921bcbef45b4b224af267ac0132a99da0c626f2f9909b2dbe382fc39f9b61e56233dc273ec5033872ee088588c3e365c4ebb7baf50eb0000c284b72d97719f9ed4f2aedecc5d5a9158ee5a3a87816b75f19136842180755596984b5bed55ee5775cc0bb301b3bc508bc964ec0f8387480dd1ff62bb0df45008551c4bf4d67550cfc43fd9a708255ddf80349a5c1deafd61d848e66e91a5c362c9eb831d6d8e03802b116ef6be385d3b127dc6864fc9268442b55d742c3f7467405989bafa4499d69e9c3734fb4783ee0ccc175005bc4d333c02a96241e6226dc25d706defe85068df7cdce19e28e965207e35e289c38b1e26c23033fb3f8c661ebeb8b2380125f64da2d7c9c1850b135fb99f1f36b3083cd4f602a5ffd5803afd05f60ab972952e3328c0803e9df3d9f2b3bfad53d9dd0c59229a716a7003fb8669b6a24a8623b5328c244bc2a766bb7a0ddc25d2d65fda5296adebc0497750976ec49aba29961cf640afb8d5413f7dcc345c622c8b7930021f04a2619c2a6b4f8cf3b7a0f16614b953e42485e30aca8182cd908d030267f7de68538f898c8a7bd3ab63e7c61d7d289e00ddec116acb276db714ffea7f0a015558f969f62be31b3f4dc644c65471b4f11fe1d56df1ab176b0d365210575ec4f789891b86d3ec5c0846d01a576242b0e05ae59fcc9681d652cf56f69e63f2efec6d21b1823d4b14ffd9e82a4791f268e421e4a4d10c496f1962e53bfcccef4fa4eefac4e0cb4af4434031804cc8d843402b234922199237f55695c22b12ba1934fbc139b91fb116c755e4364cddcf5f7cbf133c7a31dda544912623e0d679ef7f9b9f1457eed89c34137b488c237e4aa0004dccedccba25678ade71beb4b487252798658b2fb0ae43a19d8c1e77856792695d113f3d67c3e23570706e49c892e34cbdf344899ad06e9edd955e204b6e0cc4d6b5d29755a72e031e6207d9cea2f574e0aa9f4d8579fab235cdea4c3a3bbd835479ff34c522d42322550c18425d338d55e4e797ddef153fe2fb145da27dad30c1e74165537bbce66f0d6f057b80a36161815d6891f44da2ca774de7c31f83c389dc14be1b240a6b9a1023ba6821782e315eb7dda7eb4290dd5b7cc3c30d59d38c50e34866333d80e1103661587c7a5e024147cf37f0dda95d9b41ff3de30854576fe8d7052b89da7e5ce5e91ef3e86b0ec1ba29ff34dc38b96e0ce0ee591494d1dee53fb4baf1947f3710f82a340fda7d293469c65b28d77073572f2ecb524305daf418647b7473a955f218efe14a5d1d27cbc8130b20c0178f5f62b63ffd4a1c90a0ca4de5e9faaf35d378874086fafef901954530591cc734febb6de2143ede49939748947a47008b232e32d03ec102d53cad6fdb96b3634af470fbaae6c20a588605a9f2b8d42cf54bade5cab762acda041fa44cb381e7533bc12937f54a0a1920157b35087f8682342ecffe1285f2237e87306b54fe2f14a8be66f0d36ee7770bd81b79e6fe7179eeb10e12dd96a601039727f0353cfdf407ded68fdb2d84870da58f588afef34ccddb98face54e61b2ca8938b44e1888aa921699926aeab50e6da731e3d300aa89509843b833a8a8ae0026a4cd51688171bd4c09d8a046ccf52d9c267415de66633f9ce23f503acd8df3c344803d9a34261c34a26d5145ffd779057acd3d3cd83b5a94a3172deea46eb6e9743690dd49c0dfd7747a0256d2e11e56636790c7b3a9462032c04967edfe6c8c0c27948eb6248cd05337cc181f512b4a8998a81e5c1b6652e2b053c707fe7b5ef48fc1817f9a38784079226638a3a6b2efd7bf64e760daf2e4248e59ba08f9784adb1bcedd5928d3da178e985bace208926f27fc356d863260004c6303141d375bf79368bba35f96806274d45a88c9308ce3870bf1ccdb9e898dc05329ba58af83f076290ec1bca9858a9cdf0a510ef53229188a389e5351811aac8a05204afba40dff00a323f6321abe57f4a1fc0f3ecaf81330a5e3bb0969d092520945eb146a528310133cd3a9460c75232324a75fc9d5b2ab4db87655e27647828c765efe1ee80a98a2d640f41271fbbdf03456eaf3506e34c530a6fe9d0b39ac3ead79bf5cb7352c37929e4960eb01e8b486bcde49e556291c4ea8ea9fff71236330778bb5eb2fe4805da4a4e860faf8aa51b12339c403a78a3cfb8c2595a0ec2eccf8cd4891566eb853ed73c8c53caf51207732c857ae06ff859ac4874c0de95a7bb3f8687a5791090e427d77448b87b3a3afa2a70bc9ea926e75dc3480dd1eb14392b8c0c5277bc7aa7422e53056f708645d79d41c3a4d9856a19702e8c11c8f6a4427ce05f993af68706621687f1f4c866440befca2fd5459ddb851c013ff62b241c0da96add6dab1f919b3c6500296625363844741105724b8d8cfef296088600c34a83a6a5f8094d81b1f28df0aaa5fd7681de4d4988c855e5765e4637245499fe109e5d536f5ff9d8428353f2820f25d9a6d2443f7e58c6033a0cb9ae26c6716e98e860aafdc776821840275564b6ee19e366c2cf284218c1e6c39f294657cc369f91f6dd40309f42d67095c1b93fb1f80f4185903eb722106eb25a89d4307bfc4debd8f538c2fd2e1b3db30928abf35f86ca7bb39ad63e2541c8ac6f7ee5a586b86f8dbfc684870ef481f269b2868a457430b139d168f63a899a2b60ab62426a67f5ea9cf311ec1e2304545678d2614f35d484d907110b79766a9a563d01b6dcf4bf1f41233beb9ceba5000a46871d27465db7c2df441ff28b3cd8ca40d12623b07c1969936e99b1d23dae3d78cd628cb28a9f1a5c70b4c9dd1a609a10a3b9119c14715a4a5d400656821e02ee0adb858627493f8cfba1e7e08fa807997d90b5adbd57c5b78594d8d3ddd6d687ec8313cdb9041324af521f64768aae81376b167bba7dee16708bf30f64347d6273d94573a25281918eed55a32fc766df258ef772ca7bf8cdcb0342a3f15964fa560982042c89965c99f99186183d6ee810cddce12a9c3fccdb713164f2915f46ab0fc8376cc04935f2638d2b5d3046d200e0b90bbca8f7f95c53ff6e2b830dd42e6f085acbe66ea4399f7fb9bf10c79826dc8b3650ff4e7f013e6ab476682eb22e15d045d230cc262a8b862e1ca8d29cbc632f158327637831f089468a351679eafa4c31ce6c00336f25341f4f823484d7c0f58d4f2654d316c42451469fb4ec6f8b8506b8698ebeb8b3f87a51e71a49ab5b54780de49dfdcad819162de98b906edd6baa5ec57640db246f4029279b11f60e3b370dd088fa0d5c5c8f2909e7cc2b50b2d1460d7e490310c5f18ed7771752a08eb6301ce90170d9f1419d09932bd90f03cc707c40d8eaf8382d0b99c7e66e3f4ffd98b1907a10b6867d138c6c79c70e447148c37aabf555e51f49b58b9dc0ce60fcf371e8a718306a4a9ab02613acd5414837d89a448b8c82d48eb820d9a1782f6c5de3edbc0ac970cf6ac98cfb9315afefc607aff22c667aaca1393b8b347715322f32753963f551dc8664880de5dcf6dbb8f296d5f6c242101575c060011c1c57caa3734f121d9964e027fd85e108048e326797dd605ea9529298477bf80734486d37962f0d2919dd87e077a20fa6ea6fc1480749f036c93df25e7588ffd9aac076144cafddf2ac63d0e573c334355a0ffdf22d8847149f3ca0c62b3c33574bb77f31d6308c0702368e5be3aa34b852215a5b458f486d6e0abb621e763c0d255730b3311c86ee62ee7d2a6143918e018ce3b069f64a1a8867d32323ce9b9f3eb271d93e338103ab07b0f2e6af1a1146a6ef7cbac626f06fd0324ef0a16f7ca3e813eb617c2feaef2b1c66a4fbe49995aa09953bf6df440dc8117f67409fa6d8061efda06f14552a59efdb2c60e252caf5d609d1b98b808a6a4aa5f6872db929256782e6103c6a47657d972c15cc6bf1a2781b2b72ae0a7676d72780372fb5c764dc9c2be4dea387d86a7fdf605a3849384d27334db383c42877d9048cc9906df0ee50f08afd75cb75ce50656bfb148dafcb608d4a12c7be4339f17758644623e27db8419a3d4d25c5b769eaa3be921de68b4f5a5664dfb005ea93d7101ba63bc4978d5ff7f0f002dfd2813ba4839194506d2ff8ffa62dae8107168939ac3c0138197720c32f3f07282e76fc77780109b1a5f4bac7d3ac92bc8d29a44e0bd646eefd7c70515e6edbf35718ff08bc699662e8c04125018649dfb20e578857e400325279945c4a0b4bc357bb98eb6053a88cab1ad5fa16fa175d24af9b3b8463b7830c1e93293abb485f83b14c66cdbde428581b5e223a8fd3491e8e554fdfa39198591b04aa482df8c11803db7853cff2081291f0bff1f5134de9d67aa04b91d05a67eac7ab8edcccc1906e37ca89fe90aab4a85a9894d15df29cc0e64dfe8ba00306e1e09614682ccdf7726702501acd712a86581a5ee12aed96580b176c1aa0e01ac5f8e3a0a1f9b278780af6f86967d2a2039dfb8cb3c76d56111079855e21820db10d11e9b9e6e684fa61eb1e579790c4505f79f276e1b5016ff37228d777e5035eb642c3cea38c87030d802bdc858a584a54c45a7966ec3de52ca186b706558ae4a94353ae31840653c5de6523a31ad38861054a18e825a530bd6c4b88bd64b5d01bbd3d82ff6d7c11869f56e2c8cf34ba96f644f6a6b66c9e8a077ebc069769cb7a870739c7e2c99b474ea8360495387374717d610d84821df8bae7ac9000136a264989971b869609861059d72c404af874208e69827dfc4a864936d66d5fae6855a86c20579dca93c748a3de610080a8e17a4d887c00309a83dea844e8d35f96c30b339f646ba3c54e34e79bea1102bc7f8825343f930184d4b0add7863985d50bf28b0df6c49910e2ebdee9c6d18653229512941c570e4d4e773a016e874902cb1b693e4f6d458aba3d087108dadb5e845d38db72b9c99a7cc27dba69e27b295af5beeaebc7491b70c2559e578e3ac4b0aec8e313faa98aac4654ef8937a55bc9b6b0492516cc6d5fa5772713e947d918255f25961b2fa843c5174495b363d00db669bc6bde1ee18af2664bb90f865116c79e31dc21d4135ed2593878ae938f5e7e0a171bde746ac34bbe86f87e63aa61ae450d5c58a20f991e50e73f6d71de122b37163261412383a84720507b44c865255264f3d0318d3681372f591528a6eb3654b1d0c6df1b853d0352df723db399903863c72cf3b620b94a2aa07fd54b2e85347be674d5c291a5e6ac2b03aa33c070aad923ea9f30e671266cbbee0d41f39a0e743201c762ce3a86fb21ac9e3ca8af333556a53ee922079d0e73e03e1c642849df41635411e9a322301bfb950b98c9032327c0755dfdb80704b894ba17cd1a73c05d3e9b367357df33d24dd0e1318f3d626eb43ac727bb22480612c07f26cb8aba2cd1854caa37dde5dd6fd58bc9fb7f63f7491e8ac746888535c98e2095340ec9a1c573793d301b4897d5d4719538c4a9c12e44149d200b83a726f30ac3958521f8972743280e17cb1510d9ae18566f00e1fed2ddadb6fdcfb1bcb0ec154db215529dfd42e594e370d49b43d2ddba98621d91f643c2712d3e0f6e1968b513c8e38600cb7b258f5430898e54f609722b61b72aaf14c84212c4a4476aba69c2ba604df21268ed2fb4aa5bd569759a1c622c2b40e051fc15b4af36d82d0fe93db9268e0614a5f64e2895865277dee5fd4daf9f16ff24b552287ce05f54aef3e8afce66d0aaaade39da76b80877763d493b99ddaadb53268f311f0f132d5f03788c9941bd10a919a5a51ff165503dbe296a41aa0277902678ec47739f2c9b0296a113b2d7274f94370c4b23531390698970b38faff53c13a77d9d0ad31ebe435f973fe635e531243d8f874b754c2d45631799cc4f2f2115c36407fbf31b0fa3e8e98025907f2df2ece349a58112198650ed234145176fa3aad120bf918caa732e46f360a680e8c5cc0d7dfd666535a665f8af91fc20c5d1dee4563646fb3d30046e7fa0e024dcdce3d8e7847271f5981aedf5b603733acae91a5b653e67d4dab22ba4840b100c402f2dfea8320c67f0ce4877f57137fed210494de54f6e7fe0ec3c2217ef07beeb429150937562505772dde33342069dedaaea3990b7c5438bacdee6cf2ec21fe720e3e210bfbdc0b5063c026f7982732f99cb82e9e43d3a34cc3646a8472cfe52af3078436148acb18fbe65cc43364e342f40c785903f6010fc2b5e088cfc811631bc51c8eaf1b2eedf14687fe1d799235466d98442f524a01813cd93cba08806619e6dfe975f5f66128549a416f2635846a68485125ce445818620d4010929d0d3b7c718bbb78901952a91d6481ca6618a2ff8c7ab059fc85e75c0e77168f30e0c1802e8ca4f50dfd45ece19c2683c6ff5ed65559bbf39934f4cef6e092bd01fe3bd19c91ccd9bf09c57e44f61f423c916ec14191e380a85be24f5307d4dfbfcb5ea22e340117cfb72f77b8a04b23491291c02345f004d53e28318363f6987815d77d2f2c106cfd1d6a99d0903489f24b7b2e3e0a1e00550c2b04bdb2b8e4734f36405701dc17279f54b018a7bfcab26d1528d092a6c847e84d9493a8223f40bfc12f4f7f18b88af0c53f653bc146e6e2744659d0fa0f6deb8ed2941adc98a80a652498cb18a863a1b202309667fa054ff7b0f9638fb57fb3263b64daf6eab1286943b3969b503a358d56852863f66035ba9c0365fc844a28fa0edb711b93546bf17bc7e5d1b2c55b59cb0674d68a7b742fa551c9b7faea1dce3e82f08dcc54beff388ba36298e5a7b84465239be151982a0c9a704392e9324bb8638bbb5d64d03c4bf9b46a853811ef87bb85797133fa2502ebe90e97e008f6eaa2807c8137b49d6d4a2e45183ee69779b10bed3f1a869d43757a88cd03add8433e9750581401b16230c0b25d0c57565fdf185215d7739b044882fe136497883d7dd138ab1c7eddd8e0385d56c7fc31842370ee0adab22f982bb140f59f553652fcca15c009eda023e51153ec932b8e8be8e08f891d1c927aa2dee2498f5b2c5456e61c65f57d83b1a6e04ed985f67854b781db5d4a242f172d4ed7bf9c475defd2448fb80da9fd3370a30fdd86173ac64bb4d84c0badfa472f1033cbf2c0f27d2d4ae61064a53fe302e258769368c8c07b3787a6b11dedd2f532635879c9f2f46138c4154f74755ee1f0d3a070bd99356e4c4e653af7f8b2ca2f0b333cc958d03d1bb478ac64457fbdc3379af85943ffde274e180a23c214ddf69504f59e7c0635c0b71345cb9ba90229ea9efa605d68511af27040bf9b0e34e579f36f9e3c926badf0f518b46b6f4f2373905b95c91f693fdc825787ee11cb09e9e93644e4d7d87f081089cbf2957af3ca6f4c033d5101eb425f836122810417ee5668c0d9170bacc64e782757bc1d3303c326af801714f8b59556cb30a957ae81372b11c2b40519590a03a879a0dfd0509b851a84c7e399879a3e19239e8ca79121c5762ee9f8dcf82cd52d3c55de5c9016ca2973eddb123138eb21c6e2c5bfd1e68f845b180f73f04a9cd373b4f85587952e1b2fa35a4adec9e4e00fdb4e65fc03b3274f476700a8c1ef33b4751ce548e4d22b8972aa9f2cb08ccc6d24d192550f9eecd98fbf02b8dcc738d8ee624a3161a6988e71e4876ad8c2479e3fddc6bdd5e02044fac33db112b9e0cc42493dc5ba9cc0e72f9003f74873b71461b9a6c886330ab210d8dde7c147aae60171ac0c776b161f648560fc8592414a1f974ee640109a2234150004a539fb2a93fe51deec5ec70f4bc2bef1ba0ffcbaeff38e984e63f20e6d90fe4972c6843805b499de2a48bb09dfd7f0dd9966183db590cd3744e5d77abf0250eafed9cacc43c70cf11398907f153c5eb35cc8d920ea65dde73badf4c7366cd07829235d1572abd2a2d5acf25096d0591a802e79c10d076f6ad029f098fed0f40b66555b826659590d1785e763dd01a4306aa882a9a7dde3519660178705b65b12767bfd1bd9518390b980c8e1027911bdf2b41618e1f9451f02b8f887eb22bffa8b6a3e353b9726c960fca37e4dab0f4e5da7442fa5d0cd22f574501f4656b69e5f9e1b6bb75e7aeefa8a59d743dc5e9b1436ce95cf9a79a0436001a21bb827a1904890030d22485ea1394c0ece56d514712e4bc7ba51cae0c89cfa3b4bd82f6037a2936c9a95d04e158cf1a204dd137224418c423da12278643c3c528a714ead3c89f847bc27f1f43c97e72f71a26517cc5f5a77965346c7f004a1e1c3ff96556b05304abf5656adb96398117ba42bc623b7a92b3893e3de1857010f82a9b9e4b8fe632d08690680e64a5a4076f24bc9fb5af4df6e048083e7338e9b23310ce4d18b3af4082186d49c476fa856b8f40596613485ddab16c7067532289469e3366b5c2072e1ff84a13b96cec6e7a868f919be66d05f808ecd76eac80206bb79113657408a9c598501136e2fb280dc43816fa42d9438de3e99f00d8a6c5e856cc92b0384ea614b0b9ed69db7ab92c99eda0b4271a9038ad82e4d5357aa4412d1d24411152dc62e6d3313f9b4d46c2b266eba1896503d6380cce906028d5a3870a75240ae6fbee4e9f85fa401f559d960ccba032b1f797746e3933f8188ef264b38c1ba1ce6c9b4cf68c6c8b30184d584d5807dda4938821d2555bb9ea8f7594db717d7d500ebbb4147a931456791a2a37b48a3344344eff4684b8a6d587dd20dd4562e5b7ab72218e7636e2c8240eaccc6d666bb1770ac47bf137ba6de0f374edd72bdac67925e5f0d1457c4d31d3415d2b4b4efa82ddd15686728bb6921fb7707873f853666e9140bf0fbc91673a7ed5b0cc4980d64de69ced653c345eebbdda16c9a83ad2c34dfbd60ad2ae98d8941b1f658edf1fb6d6565d0ffb53e5e61f8ec7ecceef834d6225c96c339364b96270d6aa16c28e02e865aeae12a7ce77d80f84031f663b4adb9a24522b5d8c35eac3bf1faf078827ebbc9632cda9071e90ab00d334ab5d7bde9f33cad06a41d168830e99e1de59e73ebcf6e9e3a6c4d6579d4cc6616461eb6fb12cfb0dd089bfbabf2873f9527492d5e1c75f96796dcb2396aabca0351908c0178d1b0d754248b19346a10fe36b40af0df2f8a8848bb662f014a70e0f224fc24b95cd78b116b12f47fa3d0d83f8730dc0ba140b41db8f683806cacaba0a3c6a9ea5def4d3e3d6ab44c27d8319e802cb0296985dbc16afc37286b24b7cf279a4fffba686f1798ac22a3e884135a0bb578bd4c42cd9f4798d8974b2b2daf35a4d5b991bd997acb2343de7ac4d938f401d995e318aa43db595678d3ff6da7760f77328f1674479f482370efee94fff3d2c3a2358e1e02c84afe157a23d0ddc061f6fb40989ae4005528767929af7c11da01504681054be8745c8de5f33f78f7685cbae1ad984eab88def98ebad481bfde6337c80a5d0025eed04752881b2dc439c3a6391c3910df67fe5c7fcf513346c8857683ab7a1092729012585c161f18fe0244818c64cdb315e3efa8dc6da917df9c2b94647ea1f2e137339a4e2772e5c6faea7349bf90ae8a2c079253633961038f2b6cb4beee6cbcf1e51fd78614f4887e4ec5a266e79991420b17429275eaabee3c0f9a38ef06c9267efdcc06cddbfd85ce9b283a87b15d9cd864a3b159ce9d48383c017d5bcc6545177e67c761edff1a793ee74f9544ad76555e2aaaa48fdced93af3298e585790bce931cfede805190fc24851970344673bb7d047bc265a2bcbeb367b1bf76768d1464d9e68b4fb97e95c4cf11827c1f5587fb3a6b81523534e1155a00b1ee5e11732acf0e524afda1fe0599a123960619bf7b9a4093c46dad666b2a15625433b3bf1537924b2035fecfb2912f13816f777acc310fdf5aa4630f4982ef5af8baabfc0871710f49b27f9c4dadc3b87ee95b04755a0bae02ed59897b837b4ba3390a43df223a1f0138bceba5e431727a49e3b70d2c419b3a19d918642a25340d3784b0c6bf47679ebcfa5edc4ede25ff55dc87628d4e40e9824122f6fe3b50626a9a95815df655758e3e8feca8326e537c70d0027042f5cefec23e6d326c70339218284401307fbd79d04fc66156291cd5b960aba95fd5cdd0b21dae10ee1a7750c7737bda27282e350b289ac06e842053e57806575127db25006039de0d43ac511b594ac01f69330dd4d71088a09ce2cfd17a20423f4b58b37e8998670f865084a94642d7e97b5ac27f46913ce7a8b7cdc59f7b536fa2b473a3081950b0f388357e3d783a4ace97ad2bd44c23618f67b04de55113a1aa71fe03feca996f1a85edacbaf8c62c21e7118e2ae182c5ecf640c3edf0d6beb8ce60c03f03b07d273119e69ee37477aefb494fa2037f54b72d4e4527034fa2169529cfb728272e2be0a061561ccf98105e61235f20ce6c365e86f825f98956c3e328ceaf0795bdd3934759a93f4ea46a3e4772afa21c62d9610ee7428ec6a5aa8f7f2fca47e030c8d115e1803dda40e7b86b8501b6ae53b75726022fddd6797f27becce696536d7704341e234bcd4ac19eb765db0f81384f515fa478721352c7fee97e3273b80efc0479d30be09a9a16b241664d234a8828bd940b872c70f23c4a0d0294132e5ebf7681abbf032aa6b8e9df5423a45e67a3e1dfdcfa5a01bd50a1537c22d5a4f5ee4f84cb8070b8766c830ae878c97a80c1cd838b054ae85a5881a8f2817258311de9496fe830e76a7c9cb9a2572af4c1f6a00a2fce9bdcd8a8185cf3c406692805a588edd021b7fa6fa669badc1749c73e4d7a41aaa5eb035c4143a8eea5cef103aa0614ab8e127dd0b007d0f77e47d46b9a479c26c03fa9b88dd0f4d7a22a3d4865ec8333e676947eeb9c3d1dd55fc6eff379c1685cc6c2fe0fbb302fe56a2da6b12e38f8ca9fbd674b14c2d059deabc647da38dea2f367269cc1df100928b4bf5651bb03bd37d3f958a7b7a72629b94d651fd1c134ce1528c9c09c3ff4b356a514c3f96a504ef94dccce5a691f4772e54676ca13183ed3a0d09908bb646f18cb1b20bffd86b0c7fac74b238ef0063881d0eb2d9fb80c3aa4e59c78777f5f7b0d0fe733f0a9f74e51e51feae110b29cb111460bf078054237ab93e704411c60b5f9497ba8c1c6499cdf6941dcabbab30246d8562d69d3257cb64e35dd4968f69ef0305beb3bf918e3cece2de6011ba20838b812d2b51870700e44357cd7f89a80a1074c878c22c09919aeb68f1f898ad83da31ecd6bb8de2e8e8ea9d8b88a9a4d716770c03e800aa30326fc3d69a157d7c9c7f16a736a2969a09548253a06f2ca5ae0bfe6dc65724e323a80542d5599d6e233e24bcf7515bb45f58f1e1297a0a34fe9d14da02154001246ee347c5ef0d5911a80960040226695c53b8c963313efd43fb62e07fb9c7362a16b3cb97453a1ac448846b5b28be974c17261f019a7c5a7f45fa6a3624930c4bb18ce4fbb19ff3987a6d8f0554f50cb4e4a4e1b6982991dbeb07a9e1465312e779cbda7db6a7a67c7e833eff9cf9375164175d8db30cb40fc0b9ee8bd173b5a065343d94e878ac0d3cbac824bc6849cc617401cee06d9a4210b82998f5f7d24a00c6de16fb52d379742d56da2bdea6a538dc14543830d6438f2a12e7e6ba970bd23cf8bd77b47a4740ba381b426f6ec8194015d794bc3389d09fd2e81bdd26238aaddda4d9d084d6f899f86fff9d2fbc033760c930fffc6452c64a84e51e0a4f5def04c0c0480653e76e51c8f2c8b94095e026b3638eb6fa78dcceca2c1c8850f1d02ec8b4c3bbe70302074145b0caacfc8b6ef392b63f6747dd688079bd55deabe12c4b5dd1b10ad86f5dd3b21fa2032d163121ecd053b05461f58daa9dda08f61594dab765bc6710b24f6191023e9421c0f766d87f3716c34f02dee84d8b8af4b89f727b20be3c790abe333b1fce14503fd22cb164c5ac41575bb1b274196bcb304b15073e887d7fc721d4b56f40dad32bf2fe4567745658a46be4e0ebecbdbdc90e0a4ddf49b47ba289856afad07bfc54dc3170fd340f96f6d18261db759eaa14e5706db1e944c8b99564a2728e4e49b817d4d257a1c6c1a8195028c383b3432e22ed4fb8ad1b0373fe21a3a45bf0cc5dbd1e3373b903aa4dd56318440c1455168993e62c643922db87df535c1e7ccb560992c75ed32e0719ec4a17db27ecae22f95c3e87db94645acaf8b57b11032b6252611aae956e11a98628b5d31f738bf42bec8f788a2ff9c0133916e5e43729525f9001229d709330b0f900649c392f477a4b047159ad5e11933d7f966ee5ef325bd4dcd09b675b409b89cde55a2a20dffd1067fdadab6ccac7c7181cb896670e6c4a5edaf2a721e4174a0b9aa091a70aa3cce9df71e9d2349ea9973b2d917256e5c816c77760a01f628eb6f7d7c9fae640ea8198758a6b8c1c2c70e0cd080c783585792b2811f99e0fc1e2526fc7ed3e7d7ae6b78c5ef357333abaf49cc6053a8f3d951ee0169bc64305ff18efac628d72f516376cbcfad824255a515345dfff4624cd51a447e334a4ac5438d066d52fa06782bed10fc413715dac618644364923b681bb6d95ec60218be3a6ceba41d538c93163c5408ed2f7f4b8a3952565609d72e76e03568bbbbd9b579f15f7edf96ee63ece6b4d68d88c956a6c4fb9b97e75a5c5d6a59d99b9df4552989a587044b676ccad0c2b637a1a19f0a79a719df55f465175b82c04e594ecd8a403a7696755007a6411c8d817562c3225bb2a65d239472e66b90d095cbc194c045e0487a53e61c6b827332bcb28bb140e21c90c00ef5a9db4a2fee1def24b7e957a7e28d20c1315687f6c40b29439d882a7e1fcb734b86a2b99cee9cc54de099b5ebdea4cfb13a0b831422bda3d65e6c272e8207351ae3e0b8e691efc5490fd4357dd2081af7b4e01cbef6ab06a32e8766f4935dba48ac3a687a8588b7dfdbc2318e03eb37b048002c948feef8ac5604f84b6d34d1374bc0d797c7f7c689e88bfa11e60dfe54f311ef9074d6ddd45fd460a47c8484790cf2cb167a489edab152be7dde5c326d14c93459a346e44bfa9db6996cc0cbd2696562c1300e21db227a1441702fde93d850e6f61229db7e68566bc1252cafe6b5442e7318d5d0323138224c7a1e0c2c99210c46dc3e3a2a4802fd793c18da54e1fae3f81392b9ea01ee6655379fe8e0b375fe3180cc518b401b7efc0a0ede69c75e527dc71af19a92f2d17239bcab6254f2722345284a0b1690cd83e86ba76e0a5b11bc25a591c842224ed2a69b756bf712c45a108d654f92f622244203a187d58180aa835646cb7021b89c680ab4a56bff85c9075ef9e49aba9761305a9683353ab6271c55fbf1dfc98996260598f51392705e6eade894ad8866cad13b479b7d32dd425d677c7ba1abc4904bab0b3eac41ec4ce4d4fba1f5da9007970dd28bd255ec0b7850e044d871e751911f9c2ca6b4f8b70e6377c2638eb922f17d90a731b1068007b128cd085d5b3d4a0a1f30ecbe2c57bf79dc1a9106cc4c757190db83a149563082c075eb0ed64102274cea87c02762cfbffe0b5e115050292d21c238eae069d404b299271ec4cd151cd036dd24cb01700501dc2b797f171feeb062acbc54a8ae4b668aab0f7e237e142ffde2eda855b9881d9695434e3dd63a386f772768c765b16a59a4db24323a235d8bdc1b55c87d643d8728cc4d7b08c9864b1e692c397571f5a0fe1bf8fda7b34f6ecc1e26f8bd6c3e090be4190563285536be9d302f38a5ad88493d154b54d68349723e0cd7c0f046ba79f29a29d1bd5c8800843746e20df000f2b03b92b44380112943910a10a44fe701edf8a434e79ce17e92986ef53762e278bb09b4dbb33fae715a7fd4136c4f03cad7ba26c0fc662f0eb50f8339a41bb16dd3ea9689df2a1518c5a1a3ff8c850055db3539a853da967ad9e5c02ea236bf0dcfea98c33e3951fed1cd3547f9846f5d4864d7ed30288eeb9f704320fb15b271dbf574a96e99e7ae00e5faa61519c2270e8bbfb19f7e21dce8a059b4516e75185a8a1e1f351564da37c6193df6bf7c7c452c7dd075be0981bfb854791aa2843a06e44c7f4d50798c4b5b25938deb26cc5a5c2a316f02ab2e55da68ab2f9599a0eb2ab18223a3594f92d3ccec2183e273d19a6f11be035b4d107bde3bf457741777e95f145be6a532ad833bdfe25b7da640710f906896a78eb6b5368ea65000ce7ae02fb9777190efcbaa95d8edae1c4620a3f159b28da967bf393fc24fb124b902843e739710fea856788d2ac37e2913e4cb46243ae14ee0c460a1f83489c19990650d3116dad49d37feb49b5022f85e6516471c915fe51fd3c6c5ed40fc677dd423df77c3aec47d4289f122684342ba5d30f2b5194ec9c43dc8b8144b1fb8bceb1133c177fc3ec32ae5d7089cbacda9013f0494545c59e2fbb9f00b184abfb48756d16a8757246dc743646664285e2be362f141872a56863946e7935b5b4064a7e3a5d931a685fb816d33bf40e09b5f63db6c8f8f2ec64b19e75cec3f493d8e1724e4913a659698093e33c7c98eae5c1374fd5fa9eebb9f93f0bb6297bacd5d60678c555986b6029e9977b5b9231501f92b666b94a26139e905ff267da09f1aad361a132a9e56731fd06732d092dc101cd712b62075cf7ccb1ef965791a55d6e247e35d2ee74f1b0982f63ceb36760c08d549353d97f5937d69e60b6e36a3fd3facfb6764f65ffa4b3be60065b59a5825642ce9f2cf18457684ac6b1a1523954c980eae0b3f9cef54a02bbaa96dc3812254de3402faacb57e88bba1ead89a802ae02aa58e5e144d7a2fb2527c046ee59455e42db6938ca2bb0ea43e98a3d6d76ca7644e1e050ca85ccd8439e0ee0eaeedd467ce1fb7e4a3287f335bffac073f09c44f14550c2f7f8f140b1a41f865073b7157c65d28b4962bbf553f19ee4ef38ba537cbf4b449b07bd5060c2a30ff692d49ab42252f0ae09eaf6b7a1c511d79b8269b638b2e7a2ebc8696518c4c9230f7f726519ccf016fb8c32ecf1c2f9abd41245b003c9dd423c1a734099c881820da985b21b6d8adc015298bc12f3f1937f823b88e4e9ad81fcac89ce9c3e07f1d650540db8374c5f21cd4ed778493cfa6443ffe22dd57e25ddfc9ee3dc9b94d0b5d18e59977d8eef112a98c15205e8afd65f85bece1f18661cff0eaf045ba5089231648fb289873ef7e0b5f89d405f8cc8cb72c0a9b6f5913fdefb2c9988c66f610015f829b8afb4e1f705d75a486d17415ec81a9b245a7acf688a452e7dd8d1d232079e16161350c10a4578cfe6ffc1b383bb531a9002c648e79916c1d37a3ff4c0d066b49874e6aebd7d7a9fa6541ceeb6ef7e660a216d7e34107c65379cd31d972629201e5298d4bbebce9b2ae5d03a138cfbd3901729d6665628b82ad64f8873edacf28dd82c5f81805c363daee76d9d48fc1025d5024e5c5eec84c3ebe75d4f7499aebbaacad07ee3a048b7ca9735e1b89d5780d9cb0fb385f77ff95ea7602d30663606cc475c76b3a55e32f27f4aad8de134f8555f0a135be7603ee414982c98dd8e56f3126182e6ccdda68e9a6b0ae8b560dab172e211938f3523c22b5a0e85b1225be478710735e10f26c4a59c56520bea5ad4e54c9716cba2bda2ddd93a57f8a4597d1db322ee60c79276b0cb1b34560d6a50541409c5889e1adb9d4af99594ed5c1ee7c768f84bd1840436d7292f603d48f2d12e7faaa83c667a2c3a368e4a022a92bf221149538fad3fbc636b51552eaae594d4ac62622d8f3cb24d74156c92251ff9be917ab364c6092fc84cd7d311119184fcd69614553198bc81d8d20d0a232e7897cb8c15cb5d4374b848323ca72298be8930bf989ad6525e3271a24a69672c32a47a68d30334c99594c57eb526b41e498ff670458c30bcb4a9189d99281653fe9b5fee8ac6cbfc44462a43e8fa1baedc3a10241b06737db6427fb9804e2f0539d2ed7cd125a382f738768da6bce38ab752c7d38776c8e8b2892564a7f5c2de6c7797bace1344970685ecbe6360a228a73941be82e8c3092d16a34e88c8effec830cd93648c253f9137356b881ad1c063bd86da8dc4f086281e93b0f826f8ba7192edf51723892eb3343aec788899109bd43181213ee4ffa509f4413b64ec3d9765059d670b7508fd2ab950f70f25e2d768d7b8d5e8e8427667b15e447980461768cb865a629c3d1458d9bcd26fadba42294a0211cbd1bcab076a94dd3664d3b3c828426f474d373f79694d81d2d71b2ca411d6edc37176d9c67c32c6556992f35443ee38d2cc0e3e6aea0d82a4fa2b4889258398d95c7a8ec65cd2a41fcbd09fdd296d7113277cc808897a7c0b9ee462dd8cba147878abb13ab1136c10376a9ec071449ba2d2777ccd9911b43c33bb1e685bf0aabb845d5a45eeecf9a1300c6212ab1d85751464f98069ad9515cedafc7d5902a605b63c7e13ab737c28dff5b20fdcc81ee3e80cd00f96c450d62ec4174072289f0d6d80ab314b9acbd8b57ea8bee08199aa7f20e5d42734609ff76fedec5ed8cced3bd0ac83098eb166ac98e6a21ec7bca41c17653ae57d115084a3ffbe415351947a4bfd41f4de00d60669ae2d2ae13c4c6a015677e935e840536c261e09118ed6bc4a6a8525e3dd1cd36dabcc290b301e71201e7c3d017882e0db874fe4ebe8ba2e7e541ea6c8c41787ea73b053781ac44c543331dbefeabdfa6b7b75380717eb61a07dc51ea6b5556b813d8b8cc2b3fbcbf92de7241efc782cd5705a81d5e0ca0124ceb08a811ef39ce25c67d7c7ec3454c2950b7b84ddc7e91da541eb21c66ddd4d5049df99d6fc4466c8ac03d0c8a64ae08b9e1389fc583943f89ab5a749123d43aedc65f8bac94249ce6f769ce9f065689fbff5c34e486cc9e91cc9a8dd7d9d1eb6df5c1d8eae5f254425b45a0effe208b67ac5f9443d70366b67080d2c3fcdb949da1365017876b6b5ca349d8017a38ce6d7cded7653b66d2a29edb65e26e9c358b9672c05745d6a06105b2320d5ad8aacea7694b338a6d88c88caa36871da53b33994736da2a7d88440c97283b26de029866fa79df0fbd41e22bdd4444d1076112d0c1b94e46608ada60b00b533dcf49c84e8704c14b70d7473abe3401ed2ae056a8fd0176781dccc584bcb764c8f464fb7030c9e847f910d61f185e5a63e99ff45771c099f527653ee4ddd2ec9f60d3440cf130cdaf63cd0ab171f10ab5f7450bbf29007def96d1798aa960986876886fface081a5d7ac1a26e5c4009bae6b95f7a34fc8a172c899029fea61f1df6aea027aedf55afca7d4443f53afb404ec9734647e03507049ea37a8ab6696849a4d1ab72e82d007bb1196d4002ecde35edee42e68f161dca44c772e36dc563aee8625127a27657d9dc468f09be05586b1f0406669365b026f7bb30b73c90a41ff29ead0a501884a2da877acaef5a484b8df0e5628243a186efc594965c3a453f9b414adc95858498fc1cc98ce982934e073b722952f272a4dc6d7839b9f294015ace738fb24d7c721fe27c0805683b3d2cff69a1451440e88be4373be37b9831b929e1d7cfabda999bf91a45132f7d04dd1b09953ae37b12e389d49052ab229334da4f6de84793bb7615134f9fa2b40ecd8eaa05b4ed13a7d8565d1ce9c51a8b35e8c95703fffd6998ad57e0078432ceeca26fc303ee76b14192eb8db6c4b1f4a0dea58c1a9f4858c3ae1b732d0f6c799e8bb8222478b7452728ec56ea92cd95dee03d1e46d7e66841fd6e0a3ee59bf0f9d82d9ed30c31657a9f6b0534ad721e948a8302616c64c2723da29bcbcde374a0a3a23c5c4ba6088a541a795fc514a05621ddb5d40cfa895139d82d2ce5f841701a10ff481359bb8d106e99e97170e695e70fc05c8207c0a6ea86224411ad2d76dd9dbd2fc2239278194945bec48a98e589cb2cee8ce91371765500d76826e5cd4a8dee69fbbf73d2899e5fabc4befbee0a952a5705d2c540c388c43164868dc2cfbb00b917da3882060b0a546da236faa170f41a20ca54561da4f15335505468a5495f0dfc49d80bf4c08b17e6e387d8c35eeaf6a9c15596eafc50ef5ad30476778c1410f9e176e5cf3e84f4d4124af4444a1197aae8e69f5abf25073981f3ac2046ac1ca34468c794c5e28e7b8470e010bf3bf80f3814c6eb7e3b45a9f4ad39e883feb58fe1b1966dc037ef83800463fe1ff3c781e9cbd5c9090af20859d2250b6dca8b1d94256e3077bb6f88d52860f09a2c23ee8a728490ce8edbc7f836426a88cdcf502117698d7b14f5ead474a23cfbedd9442a1e1735ac6802b49c77a37039f814bc7934cbee8c6b0d82be4ce3cb0b7407adef93d90e9367522878ab2c849c97d7491b5e0bd1b199bc6295cc31fb817bd28897d42668c4cac49251d2ad28a70b6778c9dcc34877f8a951625c797f24b4b072616710ecfc7e52fbe3e93d86eb0d13ac927238a6f74270d5c04c3155419d00bb69e5df4ed8b2e5eb413ef3b0a33778e6041d82d193a280cdc2b84b26719ceece23a9d164141a343cf2b1f14092170033a699600404e3e387e9a7e6130d2a30c21381152f02ebd17fc444be2dfec5a97a7cb79c785377b0ca4bdfd434dcf5480928a53e7a93442fe3fd2583d70885fdc1a6f00c6b56a68f4c171432575795ac0072601e2720c48c35450e021f959addf322fed8adfb8a629660b583e4e203fd0a6caf082c765438523c7c245d504be14a5505d188dc60aef2b2df8be17e40f5dc33b62abeeed9d4c72d4aae8b58dee59b42236bccfb73da61834ee4bed622bb8d4463209f326e3ac78fcc63a399ab7c0a9997915fe676cdb0aad016b3fdcc1c69a09a5f670a192a6d97f0820cc019ef0acdcf0c9152a15652d9b65e5ffb4288701a2b77a46dea0857d0dc3559762fb3f42daab26c84d73bca5327154fb4495fc92b506ad0a136a409c6c1df5a77f0edfe945cbf19792a217f21b1a6f92902d8a3c29850df318f3c194a9197ffb0fdb8a287485a156f16f9c92fd7cc5cffd8fa90503ef086b03a991fe2a48899da2645bfde8d7b7f5bfbc971d96f721fd8a47b64b13488b228b2b8e013ca15eb287949f55627a0617d5508eb0ed7884bd57c6504cc0f4ed4f57089388f43afd18c1fbb1d8c77ee49d009b27e555d2a62d14f8217ca1270eed3a0a43f2b48631e532435154e54bdb1d75475a1ab2d1ab872afd899fb7fd5ac1642ee93c3c09f9d04d9adde87888297331f769ffc48784ae1e288fd4d094a313a30e5f4d702eae8846eb58ae825ca5eeb96e324a39bd3754bf1a8b80096d5aff12e38d4bf44df426f76d022fc8fb004e0dbbd01f912e75509103cecbcfa208ceb0970f8d1dbafe91b97483eed7e666df288a94a287723b1f1235e17af020b09bd1856ae03b97f8d27f22e6535a69ba64124dc662eb1cc5a9389cbcbbd3be5fde2872727dabbbb2df1a995df5cecf69833960ad72e39b57cbad576c57331fbfa6de25b6702c0305067169250ad99c73daa348d8030a75a7f2bcbf2b3aba4787ebf75654cc1bba65970dfc579d653aa27c921d29b651b3e10d02d9d9ab40f89501fce9cea1cf7a7e28ea85608c86ccc73c55f5d49d05a9f102f5354aab7032883700aa091fbbcbb9c9d826b2d32e7321aa65619c75c370c2d6e1fb87fbd16e7734c8eb7f139606de995437890447a2470eeaf1f46f2631cdb37d0eefafce724f50650433f51b5e24576a4fcb72cc9fbf0d2c99ac278591f2658ed355e8b7f0bdd845a58e9010c020b9c5f22126912fd9ec55d99d3c65cf7618479dfd54fc4f7f9710cd6a17af77b89526afd31aa01614cb539eecee89fcda5e10807e3cbc00e8f24abae48bb998ce9adea1aea815158898ec7515e516c912e7c062a06979a8d5e5b25f7ff80ba7b0ad75b18243b8d7d20ec889293a58742fd0d0e081240e6cab9a25d5b2e6ff2d78c76369dc1380865db7e6d5823de6a01382b84ebeb859764d3968477d4eb8ce4ba0ee64db5b09dfd689a4ae21c1fa1ba30d090473d769a07f01d7dbe67d098a122b52d75494bc99602d0bb678e1c39b9a87ac405d776b54f9c2b48ee4e30904b76c60e55881489f8d433f8b076fa1fc576c6dd7f62b57e1a7a058635e8365eea5a14971c606cc729c1e7b4d7a4452ba73988d9701436da465013d14a52295ace1159bbed2b558671d8e42b42ea15e2e7dec0b96f5e38aaebc85c7afe5a2749db986fbbfd4a37b0ce56423317ce0fc9b534f98e837b52d42ca556aea88c2cef056e209ece327d2caae961f7b4e114787e1e3368b2ab87e52cfcb6fb89031958ccc5459d773b13c5c92753ae19d57bbe6b516245547afd37dda2d3c56e506142ecaa897c75f0491f7c8a6d78084b98c6ae489d66f7348bf2b72d526a7415b4da71e8bf05a179b5192cf596c37a609b12373abf79f11024069b701f846d27343f57ce15237d6bb9a060bbe88ebea653eeafd3021471131c9da9843712c828313ec50988c3ef22fca0610643a9fb16f4e2f1106ac1f6e7f8be72571351d7f649629bc89e4e0d490e8fb97c7b011e5edf677510ed59f6072f6ebeef30620260d2b808fb2c16c2909121bd790f669ec9bbdea33d5f9a657c9e5bb5cde0eb749117bfc6c199b2bbe71d24d983dab50d8a9e9924dfff43879feaa6e59a1b5cd021e1ca375502226d992973a6a9bab1697c0adae217ea3b1e12f2aec0f5e625954a167b48767e3bdd528d51ba3261727514d50e6a4cf1f0256c5341b9b33034951ccfed00b82e3f0ca3149a75e451be9815be957615817d7b57afb2914c6841d14ceb7e8da21a2c1e466441799f3784d19c25654f428c49c810fbdd3f136b0bf74e728000ac23461507d5a6f1b8f5add137dc7028eef29f43982541501730ff756b61f7603694af8f856cc4233a13f8c86948729cf7b80f6aa11798b671655bf5c9204a0ad31fb9b090e51dbc912a30a72da71a41813c9304d82dd37aed491feef89d9e55c84d6136e031753c60f681b3cf5d2b35123d4c947919ca0fbbde50e9a63918bf45e133d181963e1d43de4b5fe3bad908ad1772335b3d1705422196697e4b7f941472c3be8bb3c700032d056e8d0b18b15e7c658a4e68ff347b8288366e9a19c2567b5e5ed8fa8fb0e0f153abffaaa5442de820551cc186513436574c473afc37c9b546cecf3d9345ce413adfb71e557abd456ad7ef8a0612a4b7af23f00e7d699d4f2ea91586b460ee79dc6f78c7018bf12a7d25c6c414d907d93f2a79d43fd58fe8369a98e572195d98009ff696c03efa99d032d52cecb6be32f2fee46bc056d3b2fcfca0b141337603fe7cb8e49409bfb797ba51bd4a8d89280786482af861e22a5f63b68bd2fdd0ee4e778a736c7798ccc6e7edea8b49072d043d7455b6efc170ba7533860f99a1aed00b362e6dfc81d00ee85d4323b18705b3d6a8e39add902716e50ae6e3c07919b760f13636405a700876370b613525ab78a47388d196f6657f6e3555e10112e9cb21ef54629289b7f9c898c20ddfc75bf5aa4d556632000e18d13244818f6f7659a9ec16aa846981c8a2cdd9411676cac579fa90af3837f021a4f2af8b95ec89fcf7d1142f027d475c9b9b97c0ef72cedb186724ecbbf0b10e6e8666a9af4bd18fbea751a217ef639904f94852e622a06e2f8f6e156060b5854d46cc81df697e94928b2b9908f398f48ec44ab83663825701a692b101cf3b3697d8e8969e4dd7c315e98645cabe809cd433ff5e030093952f2c635ef2e03436ffea86011f4572c53e53faf3ae4478c4a57b84d7287e0dd4c1a7f61c105c1cc19a526b7c9d6637fcf7b67642a28268b6bd19da611c36a8caf1069e98fdd3c17f989ae81aa93844fd38c15939944568db8ed7eb7f71b7e049083a2500c3b19d779044d245e597164614ec4725b72ff3e0572be7540a95e26adad359adf93303af277dc757ecfc247d12dd746223bb5a696105e92a53b77c3f05cb42a590aab17df1bb2bb7fcc89f6c5c0cde6dc49201597023ce8273a47379205d9322c4d2df0b3072a4b4d7d5ebdfd8e953940db2b13f51c14c8aec07dee276fb2e87f2d707699133e5a8dd851b8dcc8dc0aa57994dc728a6bed822c8f31bf120b27defa9061c19960dcfa25d660a77cc047fbc47395bf62a961b415747c7372d97dc3d6b8e5189eb9e9c752c0fa0dc4f7f3f5f20c024a73c181865b6a969e3aac56faf2ab74dff1c8a0f2a812d13e0cc83d786c002dbea064fa432fbe1eaba8d8c4ee2cc53aabb40f53b79418377dff5282e69f4fdd1c613de02b9f1da08c38fa31d911016f7f6af72cd90114740c72d6f823f351a006395018c6de019e4f9cea1d6cb07c608e19f78431170b04ad82ad77435879cb78baf64329ef7b8b3aa1ec4de73def2acf5742e8291f9ad87ab9c0dbadd27036c884e4bd885185555c99b46dd729a7769b7a22039a5893908ed33aff1543a0adf2858acd69c5bb5669033ed3e2c5600664e8b40057105ddff53ac171358174d55a324bf821b576d211b86a2ece691c77ab0fb18f32f986e61b9b85b91b4ceb123cfbb60a13d753af6e2b71aad623e916cbf31639fa3d99994a6e97f02c49812069b62644869dd4d9a97f450e1414292881cb81b0a9d613e72c3f890da797c0d77b4c7f933c8235aa18fe9ccf875fdd65a8e4f117cd952c3977e4f9d921eb11706db7c518dea26f7b8be4d614df447a96ccdd24926eb0a2d6363d3e1c76ba89ca8e1e7f23f2ad19c16a683e8074d3fad60d7090ca367e5357fd82f80f8b7404bd7c57bde3de3e1c1dcd8df52b7a0f4c5bf1e6987881795f677282bb80b81954c3f44d022fb028d550c63552b007b9d54e47e0ce46373a980678639abc76596e83e975d62379bff074e12bd7c4cedd814a1547cbd1783dec20422fc69cdd8a281267f11f042217882b3a87a2ab6f55a6c67c0686e141dbafcf4da362618ea9c945e8073001fb03354f6fe72f50b404266cb4c125afa318b12f3a0ea648c1a07170ac29e11e93b80c46c4153b9d0045a68af9bb3a4567b20979b4eea209e453b185650eddd046f8811cb84b3c9ba269ef73f4140cdb743124ca23099692bc1f696c889ab9b05fc78ddf89e10f669d44659f73594e2da23926e322e6bbfcb6cc958b181057a9a1bab66862b5486ebe5b6b4ef00f762b1b2abf89134112ef6e3649d945e19103cd1441fcb130b80f7aa393fb88b9e1c262120343d6fe1c15c35ffa0f3df757e82ffe5896a3835a9115b05406cf3ed60d9cddcec201ce10832b54bb74bf2003598123f311670fc0d34a272c7002628f11072c703960cf65e83336c2c5b64fe136f81a7ab54274683ad634572ec6f6450f6a7fd1ef520c10e9053a7550ec47a341f0508b939b297dcb40687a0c5ca69da92a80da94e4e12a74a41153fad5f53ab5775e795700ad177047fd8ac1135b5522a96d6c3cec6795c2976d3deace280b3cbb9b60cf6ef05ba21c42b92cdd17a7edc9da9d4eea3ba0903fb35ed410c9204c4f16e64ff01409eef08128f0d08bfc0fd6754a130a2d69d369a0eef50d84f26ccc0c08c25646e78a43944765d58c758a2f2d1a1bda62465fd93328cd4a99fd2acedc932181df4a2e60582c1e1009d2baf796e3e1a241889600270c8809e3dcc29960d544e9f096ebd30f9a04f288d3ca303eead152828ceb45ecfc3d17f971bcbe3ea1ca6768e02e071793de0d03b6a3d92d9e8e8b463b668d626c2873599b2b9c513fb48c12775b3e11cd296b31d89ea48a216be88e3cb8b4d30ad65d4ac93ea1757a4380af1f192d333eb47cd74ff2c6f34c59c015bee53f9448d054fe8104bed0eb09613a17fdb75491d3d226eda76f50c762305b0e899e5706bf96db8b912a793b7ec83836c4c4ffd33cbca4ff4df89a19f9e48559b422808b96827a4d3d50528d7d0f1836823d112a27842ec85073393f8d1214ddd02ac6946b9c7533d166b622ffd4735559343ea06a87dd7e4f99f3a01154503b8cb0c63eedeb7b2d2acef5cdeb4a9c6df775c8afef8d7ec72f8036ff6912737538c72362e4d86d0b333290d5fca774f49384b1d7ac067e2d0ac2b02c5c90aab8603a60bcf0db6cc472ce805fa7ddc1fd24a4e1de2b27f16f52f74ba82a3ffb75b22a1a3b349e766bd9d919d944c640b34571769b7654f2ae417e1c6a9c33b51fb75760d73221cd0068daa7cfd90c0c975b9ef16b986db6d4cb00619db23eb776adc07b204225ffa9e363b26fb9becfe64eab3b9259fcf54aca49c49468fcc9695b5b374fc748c74b6161285ba4df7d53b9c8517b847f173e2c726eaf839bd1f77b7fa9f53662f2fb24f75108ff57d6712a32b2b18cd5a526a64a06c73a65d83273c9b2aafdcd49b602167af1367edcbafe86ec865dc12dc95c5b7f2426987e0112ac589d6edda13642ea6714a80f1ca39fee67373b6707bae56a5d0d8e98cb09ab842b5a6dcd95b7048442a6db4271d013dba7b81f7205b32bb0a3f4637cb0c5434c0116ef593ecae6094d015458683271008114e1f6957f5a1e3ae79d618f7ab77d5fff828f4c810ba684efe37226ad98a50492ee01e0498c0315814ac5106e36d1572f7a1fb7afab911835da6c00bbaa855a3c2f2e922bcc986196dfe2227464f0df5195aea365a32d120c592a893481714b6d6f5cd767ba1a5c052e70d4936d2bbdaab0ed5ae7467ce161f3d034d36841e13aeae280ba34a3b750377a3d8445ffb9190ef9278bcc049bd2f8a17f7c5c5ed476443b9437284fb1c838c0ab4770e609bb8fc1daf25ad3a4bfd80731b9e04eed94a5ff594dc2ce17c6e5d2a3ed9b7f5695eadebd8cc90f7a264b71f2354b59e0ea364af75a91a4d8f86e0584f9e08f47d70800b3a470056120fabc2046a19daa22812adb0f6ac6bd8c1eb1d3bceeea2f5832385f946072340c9fcec5ea3d545ed0d0e9e37540d9b284d22fe3137ec2611ceee79e0991e1c505221cac8a3d9c6d751d2a7850cb3b82b7c0a48d2144e7a45f2bd4bd1c3b03feee08525cbd42f0995fe4f43a06182d46985fc93e284fe14da0cab205a444e69f46100882dd3c861dc91b5dfc96be83a64feaf97c953d5091e7a4d2815d082ff3e30b65e8134fd0bf9370181a837664238654afa24d721a908cfd7a0ca961d698582d3168cad995df65fc10d1875224fe9b369efe1b7c724cf1dc2397ac85b55f996d259a1b4a86ca5eca6691057553f818ecf47394da443cbc3fcf73c713a3c675c42aad282a20650977db20c2f706b169e92a2e9e9fa54be739261f3bc851dd2276fde527d04bbdaecd4021b3cd8eb0eade1604aae04c7592b7fbdfadfb516c7f9671c35c55a6e92d045cbf10e670fc0900e536b90b470e0ab484c8fa22ef9a1e360535b2be9d54e45f52dd9168fbf1df32d69c3fd4d80b156755130f07d7a86feff0a2447f799ee2d6b4aa8fb79bde76c5dd5808099ac97a0ad5398eebe15b175ac9080f3685f8b97748be3c36baf3a548ba37c9d4262272784a075fcbecb85bf6851478470006d1735b2a1b0ad3283ef2aa381bee7a987e38db051349ee42f953d5fa270fb939eb3992d690dd9b41305c167e089901d3c1a7cfcf159311240be899763dc38b19b681d3014f4f49d0dc1a4e3b992294305180a00b93c9531f4bb5f356bde871fc242b3fe306eb585bed956d5941f4618c815d78652bc0151b899b671be69286266938a7919054bcc4e0892a5d6d6de3dc972c5d6a1639bc56482d7e03e56b48383302d3c0199c71af1a8bd321f4315e447496093cc0f9088e0db21dc3c4239caff589f2d857252eecea191880738ddea5e2b343e3e4842784846fff940efbbf5169e30c21fb6a058e2e11cf38c0021b96b86a50fb0a161fb9488f001bcd772ecb38b917c53abcc66023edd8feeb0979ef910c980f08f0b5e2cb4e312b8d9d2f05e52e769f6e3373d27cd79f84ddd9ee53d195bd03a7f8a4a84600749dc41bface8de5e8e954550c5ab08add73b97716c3ff13ca1ff8db411a3f01a11877e21ecde4a45850aa5ec40b35db9036ada7e771c98a16b49d8cdbb7e5a7028a07c6a9b19f31cc13a77c2d21e0baa40751d2e2d53c1c5e4ba56a719c6c3f91a2a86ee6014156f604eaf7659878314235b19a0de6b1fd72a7ef7130941263ae36c24c703baba2a0addb1ae5f98fca90e1eb4dd396abf2f52be4d6dfca39a1ac7831a6d4fa343487be30dbb88df66e6eb7d7431e01172e78f1080ef33df482e3196bd226177bab2362540a4698864e1f78bf07018632968e7b276e6657c871a18525553514477b5b317f2e1cfe0d3d2a170f7fe96a234602eff3d5c7f4e54812ff7d5f003ce9ea952ccd8ce58d9d64b32b5a6ff137accca594c0f4c3c6f5044e6ed4f3a5a13ca10ce5c70e8d4cba3763447718c96e1020acf0e0052dc3e25574132ade7848eae9d01d60a8b760b4c567e8b27eae40d076c834a5fbf0d4a3fc8f76252d0121e02a74bc18b9c6a26d7b6f7f6a2c3061d86377879ef00c076f6a0990f5c2db2ea8af3f3ccc70347f62236e40cc6d43f880f42406a2a9b800ba01a2deb195d5356a49a850315c71128c42e2f26ad3452f395f88a2589b4ae35665ae7d29e651474db04e4d81d52fbfa1602c75dd1592ffc2729b339d88c9b67434bbc0f7c15dded3a1c2074ecd348049903a79ab112595d81bbf2ea558dbf433e447e00c502cb15c566d2396781eeb1ac7798d6480f84c8b07a6f23db017895353b4a00819d9ed13be053f27b5c549cf6a04a93029dda5ba9c12a7fe1415cffda223fb387763679f4d370cb85dfae30629d73227d933dbf8ec1ef13a6a6a0bc8bc9cf059ee9f610ca1420475666adf485a89274ad32136abfb5f993676dcdbd951b0c065b2a0f6fb1aeab7afc1d7a851978de0552cde4acc57a15912322f6438de45046a1229135e8a4935788280c408f5da03aba0a68696d7f40e68c0dc64af574c5e14167ece73a62bcd7eb5befc92c8315ea8d9dd1eb835a5453977a5b37640376fef6b0ae26af82b66b57e6f95ee7bfc4a3a36dca6a8f793b311157a53b44a3488cf078f0c62c81264be2a6c368bb20375bef038cf3a99d4cdeb593dcce01e0c7a8c7eb5254c0593735ee89f8c90c5120737c5a8ae019379c089b747ccc9ce3a30c244bf1ead131ff04ea7fdc4ae3c980433784eaab4f425563e343fa4ac939693b0a6d85d6ac966def092006f14ed87d0ae74d85790e25c0ffb0cf3378c808e7d7d237aea349a0d264d1cc33cb7e4ff86b717cdf069deeba950bc5d3a0594f8dba7caa9c006a23b37afb92446d3ec9dd2bc7f687762030195650d14dce31991dc826b4231e67dacdfdb1e018005f679094f47b3c33380736d688ded5cd9e82f6cef13d719bc54bc3617093bbcd381980557fdcaf9c584bae2f86a513ca81968adafb46060777d19648fb811d4fff1d45cb6ce6ef4f31851ff4fe688d18c34c84dcff84d6cf9c0ad2f0d0addb256b1d7d67ee0fbc459b2201fbfd48ec63906cef2065c0006a333e78125aa3c524578ff917c71e259aa123074f9f463b510492a25709402692d82d1d490b43791a1930661e74f3ed021b5d0e8149ba7a9ca5936020a67a3c4905cd0a2df38b8c9da5e1e861843ebcd027ec92447bb3ae3911cdbe8a7220e6f168d821c8bf069479a4a703d0e805d742d4f68d6c0084c22c2e63f62324ee8c68769dcad8e21241d0aaa9b9d35c10ddcfb735a5d7e6a40db2eaee6ba43a62787b8b3d502edf123414feb09c250986fde87f329032cc2e07814cbc42064a7fed9e0a95c3a5c9277a88a601b2aac5551e73ec5a74b73b9df285f39653efa765e16800a1a440a8acc17ef170a772932ae154a290c354ab62d7ada89f47307b511d5102b2aa145175143aba46c3d5a451eafb17daa08eae93e8e6880eaa64117d05a15018f115b8d7e1a65647366219ab0b39b26ae9f355d102fb20dc88da8607f5b1cfc7fd9f1a12d5fc812f8c86989bb2f83cb9b9ff54c00d1d24ba320e6615c8565666eac59339e8a8be050201001dda61df94c74f265b90af99104596183882b121939645c728c21f9c2aae50280c54569ca237c5c4562163665fb7413606fcff501afdc9dd7b55500bd2e5b008ff72ff60c26ea94209029649941d3dcd3a3dabe6d3757b58fb0d96a42c172ec5519583cdaee67ecc40fc7ce0f8de30f276be0d6938182c918548090d3710935c2bb5fbf63c660dd4dbfbaa8a8dbd408e78bca8da1d17f234ec399df0b32d6483bfa72b2d7050d8cb7e4975d08ab20b96e21f3e941b3e558f07c0759206425094930b9033504d55dcce2756aa6473a5235f6545148ec2b9e3453e5493ea576b43b91f582705ece6c985377e58c3404d0adf88e2b3baeb3d46add05f52c7462db2afa01cc430cd77e10335f8d69da0536a66585ceca334a967861af474e8eeaad356a52f0cdb7ca43d836192359d6b2c6e325f974056d47a8baf705efa4cf179168cc57e99ebfbcbb0b754208187efa3095dd05e725ac0614b15d8f29432f8a905a256330322d2c223a29ae23c96024e8bdbdddab834ac6a41aa25386da92651d2518522c1eca39af21193cf462daacf598354d27e7313a1c0381070f3a6334a1566faa27f68fa627f8ee82f5ffff445ff63eb382c64f90991f565504773b1054b2762f91f04d13b7784a4fc3e98e7f635984e6b6d564794f264b8a0609c6e486bfe083b52525e2abb0ba9c30a55c7fd8f9257e670a8e7e7ec8ef111c43023c19c0d089e9b812b1214cf9a6bf162a9d86930b66501f6a24aa32aeee9f04f9628153d949de78e2092811945b6a4b5242061859f4de1eb895de29a4bfdf344ca395cffb8189eac75ed5d0e42fea0fd7cbbe0864e1d74a311e33f1f1416bcb742dcb7e07ffed1749ff7e9be9b9eb39a8ad82cd511de884a69cc481cf4bb0f428d4db27497a485cb0c58dec78db992529466dee8841eca3938fa7ec2226a9e8fae006a8417163cd87e4d692d7ea98571d71e9d4c1ab704fa9e4cdfafe09f50f63cf232947de4003a42e42e68c9bc7a1172d45d69e80d6c14b268bb098ba4863e19929b82965b7de72e115ec1d76bd273014f292860c22ad196ec752a8d68499392316d6b2383a7fd603fdbab234e22982e24ad104191561fbbd8a3cf46cb8eb8c8a51b6a1e656afcf88b2539ccd33aa8d4bbdbb54b252eb05e5bb9cd8e5cc51423789ccdb22297654b64f48ac845fc3be0c72ccafb8998f14d48d4ce80a299eba96ac242dc37e89a0bc7d1149320169a349aea9af2bd99c8a558ed7bd5f17da8ca1b18c91a72ada91d821cb308f4fa2d4940be5c4ce8045fc07af9394efc7002f86e45218d3fda4e061e5787232c2cfbf5e4ce8487c2c9967c15e7a8da6fdf6aba40853f805aed5804aadb0491105e3b0d61bb8711375d5a5f12b2e3f03319deb9445f739db442d71347845994050acb7ccc3f8a44d561731692e11e67e2f36555b8cc25a659e0b6225cb999e08cb07bdb45c3ded13e9415d3f1423d1ebb4919ddac758bd81b2737d6dcceca49e5effcf20bb9f79f2002ebddb8a60402e6bbd977d1a474528fb9b09f8da670c49e3ab92c268f82dd6597b3b9e18d86a8a0ab05c14685b6dd0ab2bb7dd5bdd1977a90fe6765a3248e63b58f72e214c7254ada0708efa7286614a0aa967a2b77bf2f85c459532741a778b7a25a9e6d5a6d4612e3bbbeaf3e00e7f066190e8b8cfb5cb7dfc1b04472156c009bc729906d1d5e0b6b30a4d1eed6ab9f63e3ac435e3ab44e5938a0d5aaf68a200c02d9f139b4ebe7b84a7cf8a0824cdb433739784346367c753dcde0ee0f27dc134cdb037cc5278ae69b67394015d355d23d8f642e28dda0fa048c0665707fad14e53a6e577131e5764d9b5dfb370ee696dba348d2f165b5c0fc9e03c9f9a139225e048b1b808594cd98465cb030e4a1c0dd901d5c3c0e900beaf67e6855d72f7fd62f495b959ee608f237709aa6ebb66bedc655d8c56bc611c539f97a83ce86ef4d486f2f6d76fddf3d2d40899767c2303d28273568ddb6be51fc937efc124810dd7c748647c405b344096b371c460d84f98949aa842a4fd22bb705706c2b892cec0b556fe467c1986fa67a2e35ab26c7e6cac48759ee602683e8dc32bdf6a50967d43b49a1ec966d365e4577594a0326517cb091a9ffa759de82f529f6d37a6381cc41bbee57ec8d53f2f2da1519fdebd726c8d8eb2617b2df19faeceb30e39dca95547275563fd67254b86a375535be7b021e70cb51b52fa8eb1543dd6b42ee5fd2a24ea34fe29c30e1b9b5725f486612e4e2e0360147c67521229d64952b8e7cf19b228167f5c06fd4220919cdb3c0051526b22c1d0d93b011384291bf34f14208f5a53941be86ca90d8d0fde9c59fe802b765b5d7aab6180e111ad914aa675f47ca90b99d56d73696ef64eb0c5dba7639c65585ed24a1a552a628cf764fdd27fa6424f166b585f703fd7a0155e64a0b3c4f4555055894f7c98620bf958a83c29877f85a9977a85b88b0ed8e8c16c628a2938c41d9a5d505bb1597afecdd9fd0c85d00911aba539827f9bc12cfed9cbbf4b63b02959a7baf6b317de1b8d828b9d25b7b36e0da30151cc443685c4b1ff245a1e627d9535e4351768b01d0db4e78450968ef32cfe426d0700a124b5f25b4d003de568cbde5f5f5e7d26bd05e9d5052e76ed96fe559c5f41da55bfe1d2a4d6dfc4b6654c93b856b13cdfdcba135ab3f81aac4cfb8f3ed19433c7340d20821931c24115d06a440f9105ad4dea796293900b398f46b6b46ff8eb86037d09641beddb320e027d2b749e91c3eac705beda0c865b38c51451b5dbf1de966c4acbb2cbe85f705df1f9f3dd3ae2f64a37b5e04161312329856baf8fe75dcbb55d6e24c3efdca46c0674d0d975697c493bde443167151c4c9272922cbe29850f39d12b5543561a9f0379ae7b45ac7433d9ce28cc3049f53c4bc292b4af05a37cba665a93083255d552ea3540dc6450885ec57f24de986bb969e5b98afa67719b4129efae7e3e32cbed600a735a959493acf4792e0abfeaf654062ffa5e50573e37074a89a4a43da247a9a340ce73a5936705e59646996b6cefe0d3b686869af8759dadd320a948575d1d25f8e4b17ab2af8fd2ad16cc4c57acdefdb7161e479a930e1c1447e9e1a1b198f7364f33c58e5de1883367605c5a7bc25af0cf63dbab057d2c08f93129ce89136bcac3a37d0e00e40ac642d89aa9cdc81a2292f8a7bd9bed68ed24cf753a6d59ede75ec91c997211c8d0176217345398bde47bc56a4ba36d09e1787bb3c95b20abe9bc193c126b4b23f51963bf12238f9727aa2ddf82efcb3788666ff5e68ca6062401df36c670831b0fd29c8e81f616b2533652c2c9ae0d04842bc1fd6398a9ae407edf4863eed5cf5550df89ab5c4d3b7358a5924d0ef474f52c60d723f98ef5954532aa343dd1d5dcd24f5926d2002d58fd0e6383ffa42ba21aac1c333cb576ba4adee2664cec7811272d8e294735c1b2cdbf8ed8b64b17ae62c45281869f5a7a658b94dd366bf98bd877999e326a3e456d66a50c2cfd3d5f3f9128f1aab8a77961073a821b8166ac21b24ed3f7b08f6343b5e0aeb36bc17ad2ce0aa51ab2ef52cff39e579ac2e357eb58a0467d36402ce235b5037c1d7236f32ad4d19484f5887716f4bc38cb4680a248d1f78958f8b314fb7554109a8aaf1e2c36200e26036bc44d31d8780b40bb01b1ff1ed1df36c669ac6ac2b0efb3f81c8deb747121731d2d696b4ef821e302748aed7a0f30e24ed90d0520e0b024c6677e2b38ebe79a0167d3273bfb9cb7888e434b1301b212875c5ce0a40f7b8647460989a7d5172238ccff3eec474d2e9cdd7c080d12dad0242ade074a8f399d14c9ac64a4bc1777f5d275fe453462ca55bfc3b794bfe36bc0ba1cd12929673e1660d137cab52d255f4f9c552d560fcb36e06a2da30ca1de527bc769cf24d4ac06a686fa496db1d0d17ee168e5d6e1ececdbc9681f472386d41c08e709af2a4bc85e28e6558e649af31022f1ca4c7cdc1237da29d58b8fc734e9cc5729be0a18fab43c7e1c766c3fda6690e7501481f752b23db42a261b6f0b4dd6e759156326723601a4d47f047924d8ec07fc55c416c0b867745903583bd9cea2ff4e8c9777d9c03eb9da7f6cb154de606b5a2743be8276bab6c8f9106ba92afa9944219ea8adaff1572e08302472f3b816cf83719ff65028df0ed040ac358f4e9288e7793f8ec9146558656eb7127cbe7a7f190d9d3b0c587f948da30000f8587c377077cdec9bb065f5a272d6dc0ab20277d9ea00c0455dba54c91385fef235b461c5741d63965cd7fe6bacc946e6c16f2b6b2a7505f3bad7ae0afe00efbcdeac25ea8da061265f7865e53b501a40c80b15f99e3daa3f721be27de7a0860fdf64c82a4600265776da6d879a6daef99dbdf68c07bad9a3f25857f14329c26f4caa7706d2249dbd858e956dcf6c00d9437b3da0d3aa108af1e116bf2e62d040d89153c4be09bf0671d189f32b98a48a87621c92d63f319303501f43539a370e038529d2bec2027c443abca003c33e875aed908a04ca77b880644716fee24ca8a68388f92d24f03ddea77216670ad627ef113835db8e17ca438e84895e2dff3a6ecbdc232c5121ef5ad88caf2088b7f2a3e170ea379bcef4dfedd1eea1dc8e8dd93e93a360a0f519a28ab39d4ffef4d33e19a849d7d038496c0789990538e3c3c4cf6f2103ca2aee74401abc54bafaa24dcba764b27c82629d98d319b375456208da577610130153fe3da55703b3786590b6eb06104b0f5bede6e4f7abdc0979d70ab0ed2a33314cb9ab1c8b78cdcb1f3915d6cbb99a8bc371f7d2299325c6641000ffdb0571cd6dd75ea5a9affd71a2c621a5b30715c874ecb3d2e51b115f520ee28056106c34b94e2807c4f2168d5224ba2d6c8b59b8c5d7084666ae0a7bc6dd9447000d1170f70c3f9ba0d4e3ea83079fd6cd61cc7b2d62c0344999366c6be23f97c47d2c9bf89f86944612dbca61fade6b8b7ab2c34c2ebf97776fff1c624aad63833b60733461e9e8a30db8f4208e27ece00c62b6b79fa8f0eec22214d16226540a661d39f2b74147519cbd5c8ae6f626977b9ba86a6f2cc0091711e484a10920a35e560ab01cc607f448507a3658aeea4c00b12185492b6f98e2c7eab055d3ca1b9bb7f3c6a255218f1af3a8bd37aef3716669da49b2d81c125371ec5c554f146ffd927617e4b18f919597d5686808a13285872439009e2a4a1163496db3627fdbc54142b2d3444aead1905955369b54e5decfc2ad9bc3a85559b3f2e4b60e0764bdb89abf285bf7f3296cc7f7765c92948b521b7ce289c5caf8fa72c960d2520be2592f6b6c6710a9fc2ba02648765924c8f9903e794addf80502ffbf0f406231e5ed2245c5a26c6d35fb21aa45e93f20811fa3ab5bc746ce115a9832fd2a67eb42041b779fcbcdcf29a81559556e79efdabd3fdd1342196a17a620681a641c1ba54a31b02d070c215da7449024fd8381dd26835c9e303dbf309fe10ac71908082361470f876991d035be5ef6012efb91f995d9eff9c48f6bcab0a43eac340bfe1b5a66a8892f654f781393d7c95910dc8a87cc2f16736c8b3e82af4d0747fc85a315ecc439b8f4c594f66d7c95a009bf194fda3a583d57dcd72c7792bd0ff9a12dfc997d04bfdbe18c467c1ef0e02ec7dcb150900d9fed2679e5bef52c0722bb72683ac72574810a8a08ac548815942b38280727c0463d591bc382e678b79281ed5ed92f7a51812e6ab4509e89848a8be92d4ef1a06ce0ae9bfca3f33870f02c288fe732c4e63c5c75b4d0be4503755cde495fc659a91df89387d5ddbe6743a8f3e85fae58b3ba047cd0ff5f32135e0bb214f059a10a75572ef0c0e8b681e65359ca10dd3a3339750dfbb125521b397960fc16960fce1963f52d3d6b0db932d842083f9c23714892491595b9d71940a9e68ea7a118eda17a1fc051b763dce949d05d87ae65802acd12110cbd3138bb70ec3b3ccd0f69bd2a25ffc66dc703cd5b1c447ee579a24a5b6de1d498b02a4b3df77d2a0f2cd4e3017a32c877856cd5048778d3acd9263b525b3147249926bf7096bedf606916026e498bd057f9743dbe5409321211615353d8d274c9b34d3bc8efcec6c20a4f59701c693d1c8dafacf1c695882ac46b41812f983313a031d4330646354091dd5ad93fe17d27a9f63f3d04c211650fdc34a1d8b743179a9b29f0092244fdaf82b66ac31c7151e0d9d7686f5532c288c20d7181a3526c496b1bc19b2abc4aeba9edd15fe5c662db8bd48ac54c18b690a3a469a4e655752bad23b994b36a3e5d73753150f6278c3d2dbcfab9be568f6e69cc30322148150aa7f6d4a52e39f0c7bfbfbb9252e9b28bba09f7289a43ca8a8e58f7b3f650287b723c937aac79c8875576327758a544ea6ca32dc6ed0a9baba142275f5f6fe7eb81a0c6edf76131f0ccfbc0590f3e1599e0ff7a75b4fa6d3127bfa74f325e1cd7b8d9c15880e6604d50f329397ce58da9bfce3ca853af7bb8142cad5445590b217c32e46ac26c0a81056f54c9dd24636f16e5cf2f49f612cb62ed16235d87404a60629cbfa74bba58bdaf6f53fafa07e5ee64225f52a83d4d5b8bfa1ca50458b1ec48e032c54a5225815f2ce6a67418be6a1a7f3a0db7999ceb4ca99fb53a1921e86c3c7a774a679f281c1de851805370aa05ae68df68842d54b5e36dade86f640f106a2062a13ca328474233c69d3de78f6c3ff74bc994df4874907bb51367be34dc4fe90dd9af24bd26f018f30d7af1b2d506b7736cf03c6ad8d2e6a73b82777c23ea66ce17b93f4f2d69c3ffde6f5810626e3c9316fa678c5cc47089d77ec1a327c31aab4a674da5b5dff1200d90ed6be14dafa42589272985a8ff24f6b32065b908d8a20ba60bac55a15ab9564820a307e1f88d1bf752218bfb7fb95dff2f70f6ac2002252af6c7f99d0780fe72f2580f4ff8dbebff609924c0cd0ce32932351ef22ae254cc8f5fc7e2c4e53a861a2e8ab5d80e0374228df32f65466ed1604d84a741414f87a6afd7dbf762197e100bcdb517654722ab19678db5c6e30a46a6b506999c2985139e68074ee90efb24bfc297cc098ceb946e419a78bbeb74896fd83624bb1352c1afaaff1ff7efb7d84ecda5921973344a5c614f17f8ca4cc2c1e89a10f1b00caa9f55ed775eeb462010ede6f1fd2144bd5213b43c06aa0d804db6d0ab5fc5eef1a44526cc2fc1e5739f554244b894f1a1d97d12edd881a2c1d879119cd539086bb50f37f85b856e64c96d9022ed4f46ccf65da6ac1f453ded39ab1c904df85c878c45eae438a6cfdbec99ea51f4de2db66f75a6ff38418e74efabe30ede2f916bacd2bc75ce5d45842599e978e3972eeacd3b1dc07d304da00020c08f9c3b06e84d704bbc5b6b26fe6e1564a1f865932f15ed2bef245d30914a6f2f07897d4dfe7ee3bfc93ec131a3d2d72c6a646963b0894b75ececee8e4827ec98d19f08abf42ee469a341a41aae95f19ba6f0bf113923c591b1bb3ce6e98676739b54b11e66c4e0f91e783795acc3aabe03f2cb8e8c6639250712fb0e90b6545f9686b29d61ac58d7ff2bebbb82983052ff3624dea5825234e83c8a80766efdd758680c5be5f1d44fa809ce60408d384d63f262f594863d9a1fc80fbdc99d64aecce547ac6fe44e19c8ebcad2f9d8792b667ec77a566ff9539841fc3467fc22093a4507e814098e8884b504ea88b16aa2f7d230a6c7a754b0d261e8cd1078f663af3718617431b8b71561169f809da77481a844137135c1dbaadba029a2d7baf7b242783b2601bdd180eead10d4cb33d0e6b58ebd6298145958308eb3060df8f3d27bf1a6b163c896d59e552c06ac2c0c604b3e3186b4a19f2b80f38f8b15d5bfff94fbaa3833f773850f48e188d3df3d9990809df8e73409e4536cb218663a9648b9216ca19f0602d3026ef1d86ca857c26ffaa019fc751ceaeac00710cf9483243f61fdf2b26da12353ff28b7fa4bfc18f3c8fafb7f67445f0b7dea921799740fda456b4f867f463260cc0d13ae79e4c44d53a8cebca6a141580d591a775d398a4f7e1cd1e69343f403ab16479d6e72f7f9eea7e5df2b5b715bfde43650af336594268da3d77cfb685e14b18a3839d56b079fa74783668c0a873b9cd100c8fd6478d297a31f1d343798d42eb6dfcae4dd69a407e92cfedea4db43a10cad075eba12269719e515c3c772177091fa886b779c0ddb350b106b3b58ecde5523b8eb99dedef95728acc6cb9bd3b8c26cfda2d848f498078f1084210e654017793e2598ef951881a485d26e351eefe5941deeecd3434f776eebf06d700b360942e695ce181f760365b6151f1212f735b71ffc7822fc7723f5316f1d015389c5b9d22d6527cd344a34fa37b4bd6bb82cf00b7833da2a7957f849f25496790b70c7915822785af1714d6d3a2f90da552f29b49540fa40490a20de7df4730ceb684f62c9535d47e350c7b65aca7a1c5ad1bea03e8afd8b471a8b83132319105e2bf1b95e35513baf297fe3fecfeb4aae22edb9713c6bd9f53ae3e6e8eb52b15a716171e78c0842e1446c47cdbc25233a71001f576c10e0c011d7f2ffea2ea2c89ec9134f9357a5150505624c7eef1fa54aff33962d5ee7e5056fe94cb3c4674d029817e047bd0b87e1485d5cb9b1504189edddbd7d67f941b89154caaec5e9438dd3b0d5e4e01e9edfb00f2718cccf3810916c706ae3967494c64e64fa815b01251b862c208e80c7ed7f2b8322faf78d736c7b36d5d1024be2151dfdc9b5aae8a81ad00220a952d9f22796562f252fabdcbc63acd2341d4fe8d0bfc24c839e3accbfa7759ba4dc05faff7009bb663cf688a31ea4c750312f3cbd73d729e6010288fe3f0de8c0647fa213a1ba585d995b9d84ed199429eb9a25e56ab95bbbbe6c9d9e8ce32389f21ad738476eefe356cf8967c6676b8a454eaab85f5fdc0a9d2e1e88dfbadba21a78e4cff4e51f133c25f115c4780401a92cbe96869e51a023b3c99846e37187f289d332544d9885e7abfee6c01a6c4aebfa3f9a737ef065c48a2d37fc99ceec8fec226e6ce0bc20eb5e0a583fba69a2b7923da4daa7080996cc25540f02a2881ae324039cf1a0f6b9359ad2da97a7e412355ff7fab1f792e4f8c3ed544953423ba2bd6e6aa70925e4403e4b7bdc0e50f2210cc05db64f0d1e7cb87bef710e9b3dc7130868b9b516cc7a05e5171665522c59b4e27205267929ea2f9e034df3f49e456fca61008e55dc9d7679cecdca2846773e501ddd49309b7c4565fb0c060fe27411eb91b50bfbac487b6a8ced776dcd3e08fb7d54911c6153275ad072edea8f51697af1d32bd33b70fc31411ab7a2e7f8178133da1fcebd9b0196d744ec87a481d98a6017d831a6b854e7ca7913c8716f72a09b455204567ff03687c5720088fad66097ca07406974e2f978ebb9f0b574cbf1aab5cd8159acf6bae9b7ba6c912fc739892d74a1344f0a541d8c04c12aa3ff65b1bc69cfbe8cbc15367675f9feefa18544b16b501b67d8ba18c749245a8ee6250b8bb3e2fd787e1c74dd45120a3c213d802685137f47b3a6b8ecde3518df9180c5e807eb65d20d68be76bfb16a2adb2df5acdd9268ec5ff3884d46649c5774226a78da8299c397b11dd51da5ed4e0ae180b8e010196165bb4a3121c64bb7881bf275345f0ecc8e050f062a1206d1cc1c8a8e167c8ad435e0ea659fd5e596e61d3bb8f9415190da089ca8e2d2c5b53a673a838e04cb6ff00925c65721ef437b93f0ae3a336101d6b4a09c4e4c336b0593e1bbafd4fe3fd79c1334e6f3fc2cc6bc3b23cd9ccae821a042dabab93dfe0c0004a39ce201ec2af27fa63bec7aa3b899ae6c886a158b5b9a19d92219686eeda8dbec172546b2a3041b9d671b85fb23232bc93d09d38082b5fbac52834bfcc26bd0a91f7e575ee28f0234a92f589a636802a76af770771178c0da998bcd8e6207ad2524276b122399ebcb5279dfdce2391589576b00d789cc87037497df7e7adcbc0345eb733e2caace99876f37d57e45aaf168ed60e5c35593e9f1a9515311333e9080ab35c766e7e6a436f171a9f511ce46a2e756b376d03a88aff0c314eb35d28910d3e41d5f796eb72bf277e3ae0d9e21f5b0918c97fd47b2c671553d24a8ab1636fb6878955672b7e4cccc8f225cf5f1a265e7c48c94039f13af26ebcaa0334e993aff41332d9d1747ec001142a0ff85eae37f6a7043e7af1a259a942edafec915e4b4bd50327734b52b9f0b91170e53818387ace53a409051b57d139439f52954907fac349be18c87b45dada9a889df6ae8806da8d2837a0f096033bd3d67459f1479081c5bc3b083cc9d015de71f9bdd84a9a98816f04267d9687d07a0d17faf7299ac846f17cc4730ea9f8a5e5de1baa6d83597da6109d1fa10e666875d74762d476869440f764c0a3eff0f45de9f06414f12d7714f510837d9bb2886542ffbb4875a2fd71d9b216f7e0c19c2e9c52039e828d537586e6657ebaca0442ffc173809d447c28df32cad467fff6118cbbdcf7865345f6bc3d80b30033d2dc9676b3ec8b5de8daab53d70e186376256591988db259d85cff645c6337877447f1140c7252210d2f0ab6089e0a723209d1f9cf8d515ed5f3ead7636db2dee46854cd74c59728e391f0fc56ab192c3020996b50fea38942100bc2f0870a50df205a9cde9181a6be4d53a782edae0d96e53f000b6f63a4493d560b60a2b38069d76e14706a818716fe667a83d0440b9ea752591b5bfe736ff9a5fd811e508102cdc29be604438844303810b80a2ea4b3ba667b4d8bafaf3d96c8eeb52a5491fe0b90caeeeeb1f979ef5280c44d237293d9ab6592be8733dff6f8272820a0ff20924eb35cbd0dfbc8bf5c3cb689ed5f80ea4b259f63f3171866eb09beb729cab9233d504c60d92855de2903b9ef1903c5a962bd30753ec313f077e0e5959b86d641f05e11886f04d77aa78e11c6186162063ba3dba566a8d1ec2890fa824dda771f0ae97987c96a4026c92bd46119d9e840f08ff1c10e1d6b933bb3f3ccf924f967220aea94ecb388a382ad471d3bd8310d45816eae9d0e4059bc8b426ff589e71495c05c203dc47a47622f7ce2a30245c55f04a9b3eb40240d37ffc55cbb420525652be77c64e4d96d938cbee2d00848c283f1249208f93c5975072c52461b633149a50eee96fd848f7967bec6f294781935f4a3e21e093c4b7104e4e14096aaf6fc4f85cd12498562b5635f06650cc671235eb61ec62c545565522bc17358d51ccb22ec965ace0b97bf8ab0914b2a2ca7dc2c66d673d3846727b68d9be59a785eeba4db1b93e2e7bb8b63089ac8aa71fcc262169632bac616bbc13f89814f9b32b32ba2517c29022e7c580d138c9b4e581cf2fa651365a9c098bdfe886673f20aa6560253dcdd1cf7edbf55428150bcfc2b4a06fb32923ecb83aa5e27d45aa844f131c7f17c590fb8e8abb0335a54e7793a481d010a19ab4ce86bda0037e3b419e672ed78c187542090d55194500d78e7d33d95c0d1db949d3f7071e38af3461942a4ae91e4c08cafb04cbcce2a42eec7f202dd5f3a91c19e8b3599a72f3471a5102355f889ed59fb7b7d5e553af2ed6487d39581ebfd11dd29e2726c2ab9721bfaab2c3e0ef6cfa2a28941d31b5cd9a2c1a2a9d86c28779deec9ada56f9afc3ce2e8407da5c6e1bc168d40f0a2e2bcf123397b5661563702a35afeebd2ab1ab3511c3da10debdf817a6cf4decd58c0319105fac73803dc4a0efc499deb70d0e1909c4b5b662ea8977d981bf9ec70f33fd03626a848f43fa75fb0b5f6c210ac2518c798f8d2a199ab83e0566ce84216f6fdf3ed59a4f584a59f3eae0d07b1b67eb53a2b02f0004ccb563f81f67b4a7317ee1a3f2932ef1067077d5bc5cd3e42e0013a0057a9c0624c244bc759ecb62e9c3959b6c644189c93a9acf826617e04b2e76efa9e94a4c0178c3c4bbbb7593be02500a8117d08f7e880f01f45e9755a97bcda5beec29067e546a699f1b690143bb08ed87ca4fadd65c7ba8bd71fd90cb2538000fc8a90caa935830c417efd6adf6199d9960c0f39bf326e808607e303c947ad7f407f78445476786aa7b3dad71d88cd75669c880491505b86692bfac7755bb24233fc55ad671ef7ab1a44435371ef59195d39361147b8c1008b78ebc1c18013c68e948a783a50e2d5881e68658dd89f47af19ff2d47e1d2a9f1689cdc478e1b0ab40b9d4cb19f080855844a082a57132bdb44eeae8508f52e1bd1943b85ff4654e94d0145255f4d549e78e170a9f8b204712b3f0e4ac53a01ea10ef7475211a06597580b848ca8ca0556b21c379e955c87da7e06a462ed135525147a119ae4894de20d8405ca8179bb71906a420fee1aedb646f9441d2346286c55da111c3355b564d91b1e0fb3121aebd2f4d8f3a9e6dfbae3e3cfb71a57361cadcfe03bdaaf6756e3d5e1e668c557edc1ae1f7f58c469b635e59a29f182450642d3028367a5da6f6d875b5cedc18e179612c6e5f4ca794a55127c6f0ed533644f1e3b4807591ff0f83880283a921a1081ea1806fb85601b1ee1cab06e50aaae467e36a1b5e4081b669c3c9e123dad2d5195f2be1efda95e034b611abe56db6c9eedcbbe090a3a892800189e13cc0d955180c6ce7140ff51d415e1bd132d23e8a2272d9a1e925f16711597b066304bf0b4de60188b62f47e55ec207662fc6d4df89c05e675099004645a465590154cc50e263451cc388319980ba24d0583e9067f99be3f20f7d0cdcce370f0d0c2d2d7e48951eb89c14a354517a73238b45811e51bb4dd9357c4a78d0c9eed3deec9dde88f1a215d1c7ae52087b4526c0fea37ca01da366a2143a010b26b91e6f774c3d3061a7ff38076534d811c10722f808fc7f2c2470341995b38142613c31d17411a7c0b28c0ca8eae3d6cdb65f59aa4dd0676b53809d7264eda8daad0d6dc1334404ee99f7fd11d9f3bba07cf31a39839319d92a2d3463398441ee344495e76b454a30f054d749d4cf481a20849f46f09ac5e6606de22c6d8962ec0a2d62a0e9bc7c8ee90b856bc46b3ba380fa4e76edbab35f54dee630c8e9c4d7c505932d23efd266731cf05371ef5aa251f40aa65e6adebfdb14159c3595188f8c25a6ba5f5597e53e2463ef7188ce8496e07a5b708bda3bdce2f6688bf3c0f8ffdeb296c661ba8047e8693b01300ad440f78e6f89d61f8135e0730130fd4ab81e1195eb6406e737a83210c66feb8b5610e07778860f0e2172882c865547065a9c3fa976e6a7f772b8d0fa72704ffa5c1b2b2f31e78275cc3c51396ce5576caed69434491d025da633e4b42d67ff22eb77831963852c15f4a4c22989441efc560c5e943174405e587f17cf4ac5ef6062d51d077a90038bac2e490f4ef0e258280f2907258995a3a45e38012ff3d48b1c6cb9568a09f8fe2477fc33d74fbc0d1155a90497b0f4a61b391551799b5f85e6bb3eb36d307f2f26833a64448c51f0b7381ed2e303bec70a83f1b5be5af342aa86bf6c993eba09ce89ed8cca04890abc0bca44f17f57d75af63ecc6118e4c6f0e9e5a3b3055bc2e6745b9039631e49596d57968711dd53a37407b49d52cd45bbc826f904a68fe545900fa9e11893dde7408d0eb0735811feffe3701e10e5223ec13887a145f0769367b5b1d32e74e0feda9a3b145a8101bb0db02c0dee2206f69634c1b46151aa418d17bf7e575ef2699ca85e9378b7eaa8392d242db4d0ed26116b9ee71573cfd63ff17a654ab83a50cb1ee74077ee46833d82e81848e5b7f661cb649cd05cbdb98314fdfae58915ace4ad98372f875b1aa04065b90ea0f8706531c55ef607ebb1967e1e4f5245845fd0ed330b62eec8682af0ae48d5b1e86923843adaf5d8b4ca35449134ac8af23e7bec69a4d7b0aaf457f9e5f1a6d504f276f0474c1e8ec876cab7f854e3d9fcb1c222059dcf8e9c491e555c680afb57f1396db1e00ca115f6cd67e054e4850e71d5ff41e0d2f352497988e7db4c0110df1dfc3e4d604a3c7f8820d85f8538f73bef527635c818b35662ee5b550f22b71b792b6c4647abc46ad4dc9b9f96c4b6660f813fdca106f9b31fca9a6b0c6eec18cad3002afe5e4a63617e05df859c502238de7bc8a6630a491a9cacb6d5c70512e61b7c36f7db1d53a1bb1ea8cd373fbf78a516875a3666f2714d310263eb906ca31df228c04dee458ba3f6ae902acff25eef4ab792934f90d33984dec208f78dc9d0d0cc92380a718d1aec830bced0878f6045f5ceaa118ba1a9e9515d5d2453946246a9d6789d70ff545a5e6f311494b2660d19b08326c3dfe22bb005e281926b1c55f2a3507293a81eb0f8b6d8c6d80fd0a74774a9f600f1fcaffcbee35ceea09f666c67387c826f7e7151fc471d2afaa14a0dae4bcca622fadb747fb1387e7c043f49e3af0d3a395c6983ddb4e1cbe4c0319634489b1cc29711b1a3d8bdec814294a6f91f2ead8497fbb99a3419634a148ab5a49daa878f17b109e8645481aa4c0b69d1d9a4750efb69a6eda5d54ca5e377386a08a11ea319c3af8aa71b5242c2d4bd3f3e9f77e723bbc2288d1bbc78a595c31e6134d7605b6f7c6ffdf4c8a52930300a5c283444bf918d8f31302a9cf3a0212db5886ca091a841f55917c455aabe113e37b18620689236358f102a74b53e9ad1639a5182340c9c7bf0e2ad2b46a40d697ea1613e013924e2a7851b3ae57e6c70b13d4c1c077f0c24cd14c15e72fd8345228e21736ac19cb9bd10b815c04d78fea1a5307bb8fbce872b217d20ca44f65febda10723daf066584abbc1134b4d6f1380f4dc74d4c46243a36ff25d92cd6bb317b4d68bf06784682f4a7f6cd6c42dc1347aea4a272ace15c80f34666a59db99b417cf2ad68c34aa8d943cf4f4626ac5338d3b7e6671410cbaef33c331a06127568323c8373c106d906a196458ab6b2bef5adf012e6695bbd2886ac3bbba4f6d6d52abe93efa835e277a7f5481a21a0467c1dfec55da3516e2fff99e1b4fc00efedab11fd574d3d34d307129087410f55ac26b54d318c69fccf6cbf6ce565d59ebb15086b1400c9b166490ccb1e760e828dab9c22c4a6855bac0de7d9f86d232ef2e9c31be75a3b50a18108cd3ebc5954306cfb298aa4ba97d16389c84c12f4e7ebe0f880a327a7c3614a55f7862abd9568051dbdecf3ec9c162e47d759764540dfef5f077bbb7bbddf921f1cf61d50d217bb281e0907be50c06a89b166d3e1bdbe8483fbacb1000d4eef47b442f130098bdcbcb3bde74d6b0846fa8c23a2ae4a666b53027366d1e271c8b3b599d417b6dc56da7707400f036a14290fdabd364ea550d2fd1764b3bb8f191ffd8ed54547c7417ecc29fd9308f78e8aceaa6a344f87bb10b603fcf38e89f461fc74ad5b8a69120d77a3dbb0294e02c4398b251b200a0ef24607d2ffadc065dbf6b2e51ec8d683e146cac5efbefad8aec2994d20f5650ce1c31e9e7bf46312657aeb5866e8105977138a712bd49fafd5ee55e4aa18b937beff1d2c7b8ba02d4065a865e508c71e3f99c2738f9b744bd2eac6913cc0ab6abf82301555bb57e00241b3f337404cafa76da4e4812c14b3288bf6e4ddfe717076aeaffe564e3210fe23747f1ef9189898d7373189762e7ff73bf30430d3fc2846a79517ea13c6f190c9602ed9cb8d9c3e6f99090fded8023d69301de0e568eca87b3129392ced27f37a03a7fdc3847503d32adfae9621904c926603d3dcc3fb9acb235246f53d595bfdce18c50cb1e49d584c77fbeb7051bad5328d56bc5060244ccf8d1e9d4e6fae2a224ee4de68415cf8264593f47534eb781eef4a59849ab48983d0dc1e84e1bb7701697400d3b61589ab8a10347aaaae8e9e74ea668315a5ea54ee2d24d57cd928f5b31953ddc76f4469f20bcb882b178bd5bb019c337a005708fc120d4a49bec2c33c43fca466936425b78a24da1557895a718ff79df1b26cc10a4efd316e6eecf3a13c33d865e0d2b06606fa67f040d5379038e374066eae0de0d8e6cc95037d7ca3c92326e1066496f8de09fe9760fa68f4104a368362c24457bab7bcd9f71e1886e6c5eb51dbeb8f52566670c973b95a4013b398facb6c8d1725515c4cac9a91c4bcf6fc5db18c6a42da77f9a9f0a3d72e74292d7788aca503d41c124fd72be33aeeda1a229d8c9633c30de7fa069c06a5537888344c2ba0f0f0d9b36b5337f6e0619a468cdadd88e519a02fcbcd5a3e44247e97749f12fa8e961a53f695182607c03eaee88158ab0ebe976d3eb855e1ee88684072178978fefe9b208616e6dfca552962e882f93efc17ce6e7a82d29e953e027e75e25a2872d5c050492a96c259f6b7a9d0f0f8f9422b0b03417c3a3c4029e787a72ce1a6a6a39ef24e020d607450016539485eb0e7ba61d5fd0e2dd0699297dbf9b7e63bc89d790fc758252cf59dec6341c163ad2dad5063b26d82e2dcc79097c83454be406b7d3885d9dfdff208b3d843ae241c17363ed11cd4af6b3fb0d9ab32e8997fce8a770d0cdbfd141ebdba0b078678344fbcf66d249d718590ab885240a39148d28a1024cf624c74f846def1f5e278aef6f2e37c3713e5db58f6741dabe57c5615e46c8729b5a20c8425534120770717548da2d222093dae56636170f55642cab8c2aa6d91c5e7f86436876e8ceb90e405dde7d81d2d401933053999f390bba4f65268abefd3700847964ce3ca285ce1e3fa0942cd052366dedb3ad97249f97ab36073aabbcd7c2d15def9a42b8a7a52e57ff41d4cfbdb987cdc1b5dc9c2f56bacd8fd787bf22bba9cdf1d9fe4eba92c4f2a8c9d698856b0312703088eca254dc050ccb8293e3eada39d1303746d7f9c87cc7ad059f430a016447840bdb8e4e02abeaa28930920448151386e8e85a2cc220b4eaa2738442a524a008f7c86c8abb901d2512b41f7e05dc5ef1feb977b79300686c04c105f71c39f9230f4822192df4994b61027ff107dafab36029a17f5d757e9e5cece9f121d4b682d76e4077c5e9e4a2c00e12b8116e295ab88ffc0990496032696d0718baa4576881509da31e482cde5f95d0bfa1d4ea15c8e8d2f32e357935fe269417f0adf9fc3ef8842dadf402c133f995c6aec50bfa7101a2b7a4b3a45ed139cfde102c3572c88beaf753fac27f0e9fd65d98fc2426c14fa496bca4dc4f05b5c1670616b3620295fc7660d10641988b12263652398502f995e045c1e3ae09a2a6e1bd00e08fd38c64204baaee7bdcc87a3e3a2b547f9d3e91643d1e9d4f050c6586acc396b31b7afb208bbd19473ce95c4e8f6a3abc8101657b62a69de30f2029ba3db45ce8cd97344bf82c6a0565d7bfbb6de8e41e2fba72b3bc246181226a142eb8fd0bc605b13684cfe9b28e50ab3087e1a907009297972566f6be16c7bedc51621f1ad653830b7310fb2a99bc8c7203db07f3a384d3e93b13a01bbb6cb9e11482c9e95ca56f1a844e2eba619da18ae2da1d15d8283e9250c0728843563f55739205b9e9ad6f110422d75b607a4983bcda5db11b684e63c5ccf4967c79813a827e9f13ecf10ac1f8e3ba62b414f94d0b215ba5e84b35e2089c374d9a72aece504ed9a01515712ce1e956ea9eb4a8334eba95be8e977560e90d537cb2777d4731c8252b9f48173a46c0aed949bb41839300192e166325b5c1344d7cdc8ac5e470bf6a615fb4c1ff72f3f72ec767ee9db04613cf642d8dc9cbe8cc4c1a95e38ba2d2c6e88890b72543f342883fcf79abe1d06f3778de1ce608fade1a60b4d7041e1a4d76a00bc2892b8a12446351d1db4de17ee42e5469af43e90d731c58913e95c651a5681a2c85b42d37e2b9b83a34786bad374da81ff4076bc9892282af143190074b73ff6c5aa0242e7d7df4cdda1afda1ab4706efc14b819c4b1452a58e56e331f4b7731f98c34b5e1e856c56b8a8c7c40160ef16a05b670bdc68b7882d649eb91f3f68d9223a1f92e0a9d60fe09bc50fe888294b2266419966a8c1ca10754a3e7eda61c69239173e4de43ff71a3a48219bd981a0d300af6995f5615927ac1cfa61c0ae32096ad7c75569583a0a7ef987370517f5d1d5846e58e8e2b145971bf84ef6644f9973a7909abfbecc9788bf0b3a2d84f4c0abf4d64dea157e7f164b8a0502463c836e02da6424eb0b93d15b6da3379e3e49385b3c520e7d5fecda0b2cbc1032b01c4c91be11e311207794ceec9a6becfce393967fe1701f5023860083adb4b72c73c7c0f5e77a7fcc4d4aa7cbc8976ef8e435cfdbb15d881c40c23b2df2669dd1ecd85708b97f24597c524e55a240a404f66209117bebcbe2177b3ddf9b4806c82d7714079a23c46061aff705eac0abf4e9a878d23ba4a58413ae02e256ed9d5348e647cac5ede1cb184d2c043f59534c60bf42e4fd1d9acb3a358fd00462cdefe1619ccb0fb6f43a45988c4e78036cd525c4ab50be806348af9b8f2abd3583d482f9779000096d7a8e08e0a83ac6fc17eee1df38d288bf00bbc6b3116472b123008c2895997faf178dda2cf0a91d33bc39518bcc69a0f25afc2a5a56c26c6886a4f784839ee125b58482b92e15b90f8cd29a67864c1e5129e5a023235d00f1cf40a2b2d3dac9f9b4d6ffdec533d264d4d315241f507ec379724ede40173251002c74e11614b677c188453598d3b35c7ae1ffa4bd88af9a3812a0334110e5e55dfc8ef3bfea9bc4ff30bdcb49ea53b6c2400cfbba634ae652a5877442ac0dfdd016889c234f59223a33d51127457bd4cdc7266aac7b378330062c9482c36ba0bbe1a8156ec6119258b4cec2d28075e91de08902a81993f33d8ff26146d5d7cc7b9e5fb7c22bc7510fbcb77b41d49a46d705f3a1d44e6e73f9f89d804e5c000f6a3ba50f05068c892684a7eeac3d69a8d13eade231c9d3dc2395306c627309e5e4a54cd9af96dc6282146474d2793b35655877389d448e7b39f0b3ebe2fa9deea60e11d01de35bbfbf40cc1de1bf99c38c43d1de7828643703007fbc5e0dc65889910250cd3c4c8f13dd4435d34deeea5872f2626a7abd17c9384f075fae92fadcd181598b7c421f486112f04455e7d9308f729a743eba7ba2edf79ed9bac2735ae08393fad874dcdae8767cf63c88105d43a70d996dbdfec52371cb5f27604b446690898936575c0e051f2e40b212a190cc4be2a6f26b5643a5289eed0a1b49cbc316065da64f15f00bbb8a3e1016036a803d6cd61fb2f23007c34666aa933565d02efa876c0befadbca95f9889e17cd29c1edcf6c05caa076a6f0cf8159ccf2b7f7a6624d6b1493210c0861e0da644d6e00eee0d944dba5d4d5e5cfe36315fd352cd44c0465c97cb244415d86feb4237ff4e0f1b1c87b010b0a1381de62c73659bc3354b30d2e6b8590038b11dbc5e29cf6a335f1f14e0eb66f9c5d59af1a35003cda78bd9d1dee9279472367602d35575541c71ab5525c08d9fc69d978e4ee28bc298547b95db0a09a31165f52f11f519efaf903cf32f3121bfce2e1994f98a8f457820294cc176b1be7adf5e6fa7b0f738b832b2eebea731004e27786d70415a1849f24502d1ed8e2c3de8974d0d7712b83eedf66369d6bcdc57c7f35be3169636ae8acfddf21039760614ffece6c177163a73e29e8ad08525df2dbcf8a69922a4139f466820fd786f98c37ef876c7eeb912487177a24c17f20b1e5d730ea0799af2b8b50d0f5e01be255c838e77f20ef7cad6811482b586a369a20171544434477754d0791bc29163408753ff023fd297925397fcd3f7108727097470a6e14a0d627e714fc6a12db1db0f3370d216467ca6b6f0df970dac71fc9a8639fe86ed56971c099ee28682b4725409cc1ec8be9d60835d24acea6d32786d3df80caafae6c4a4ef672086d8e87194e2f300e25db90f42f1ce94a43fb16fa1aa19f8deb07451a64740b46695ef334bf545493382a36733394619854ab545ea6e00d799624f011810bbe94efd3dfa81b99b4f53a7d767e0a5b8d13751e741a383a6ba2aa883e130f3a5f0e051dd9ba7c019d3f488e35c09afc182c4cec10da6979244ef62c50b2b3f28db7c95c546f399ec9f8db528592e8f0a8f991ba43864cb913b3c5e3e903d8814d06edec539f9add4844a90fb1ee021c9eda2d3579163d32ffded2746c8a457ac2de8578c4174edc15eff4939a3f997b0e8685226a2958ca6e6794829e302bfdabf0ba80421842e2d33c2eb84cdcc0e3edaf115ddbb4a6c8e78df9b2f0918399d24865142e2e726af81d57e7e1d6d6359b569bb2a0db2875254016d7d34dcf4240a14ab8cab01eaded7f18de691545afdc280e6c08b445d18758abb968ba214718db368656b16f6857c1a3176dbfd8dd711fcdc62c9df922a2635a985eb3647ceaf62d9a63971085fd33fff3c0581ac607bbf698a6f67d71d1546bf9d81b3225609ba21d0b613f4286b58ec30a421d6e1ab698aa4a43838594b3cedd1de935bf743c9f9dce352e922e644a1a90fff17e796b6334ec9afee1ffd0968745b4af291d85212e6e38bc39bc84715f94ad66709aef68b330cb9067c8121b3959b03137fb71bcdc06705a482321a87cbc7455cc627739ff4f0977f0683d10cf08e2bf66779235e8858d7c265539045aa07a57e01fdfc1f9f5f70896360292edadd376068dde41daf2b7d20574d4c27ce5d72e2285892f28869bd75cb0be46f1ea8522fd97006bf699d3e5ac1e0e9459388e32c1a50835a1820e38d48f5f8280bc4783c7011d733cb653bf0cfd76f015be92dde732b4212b2cbcb10985acec7094d61e1de4ec2b3cdc72e1142617e31c558b5aaf18c9938484e22ce188eed797dc1e4623b0cc3585d543ae3da181021e1849c21e671296f6d4e473209dd604b360d7681326e59c0746441c38b2d327e744857066993ff920c4ca75225c79656fb4ae243ee9799f5c9bb0cfe9f9d841778dab14bc55490754dc9c1dba819a27424728098b47f249b541163279ca59750fc11f26fd6cc856669b55011e10eba1c61b8dd683c434bc26736768bbb9dce3fa8781f659294636ea1f1a30662505811031f2d7fc0ae7a690288edc2db69b15add6d87cb9828ed5258f321cf4254d08eb0051a06a377253879c602af33e848c0605bd61a0960a2562e057a3b85cf3eafbd1de88911e421fe6e6be98df55d7bea0fc05ab00916318e31cc8bd0b56912e612ecf7a334b5f4a11bc2d7fd87c65850a1c14af5eb37f548cf8fa98a109cc6f9ee12386b0c238240742b8d159eb9afa6ded9fbd652f43959621ebc797c19fc1622c46d7c7685db55b16b03241aa9c5e545c2debc3aeadb367d294c3d910596b8599f9ee046a36a14ab9cfd83e821b846ddc6f65528f5a6f47844ee2fdb2127fd10ce82a78ea3f7de38f85491689a70a697a4992499148d8341bdec2ee36bf4ac62226e6b93b275f431a8df50973554f6a61a4b75a2308986dbee3454421830a38afca23142f6c0cff6f563e7516bca78cf345b514b813e305945dd2357d34609c24704c10239dc5f55b8d6d9190c7671605f4a5a6ccf4331d915c1bde80340852ac81d72ce589c3cc38a1b907feb04b4d03d392c1cd67e023965de96633580e4af661bd147fb42e860049f4149718726e62845e3727ed05b740c0a25f7249ffa7407b571e493d39de7814f155bd2929850d68976976f42d8a86c9c8117b3b8593496be0d81cef182de3c6cae3967acef9a0c2bb34b72720eccc311f93485b7f188b8733a70b57fcee75d92dcc2f7aba8fda48bcb29dc20efdcd961379abed3c3f9c8b751e8ad4d9631be2f2a006507dc6f0d6929231c6acfdb6ed76dfad4d6a5a3cc1a486983899ec74fcd0d4dddfd73d988e3ee67bc4ee1e6dc39aaf64612161c132e74996192ebe6c7e72ab67b84d736c1d773dbe48f6e6075b42876285c5394ecc0d9e88541e1a35f6ab35740ec48b7d49c6e68da1b68d5d4adc473aaa7b6194ff7af248a336a816d5580b732dc3612064fd41b81c5bc167a00aedb063</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">文章被主人加密了, 小窝要核验主人给的『通行证』.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 做题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 《解忧杂货铺》</title>
      <link href="/post/eebaee81d76a.html"/>
      <url>/post/eebaee81d76a.html</url>
      
        <content type="html"><![CDATA[<p>解忧杂货店</p><p>[日]东野圭吾</p><p>2023.07.30 记</p><hr /><p>最意味深长的一句话，莫过于作者在小说结尾处写下的，一份对『无名氏朋友』的寄语：</p><blockquote><p>地图是一张白纸，这当然很伤脑筋。任何人都会不知所措。</p><p>可是换个角度来看，正因为是一张白纸，才可以随心所欲地描绘地图。一切全在你自己。对你来说，一切都是自由的，在你面前是无限的可能。这可是很棒的事啊。<strong>我由衷祈祷你可以相信自己，无悔地燃烧自己的人生。</strong></p></blockquote><p>回顾整本书，情节错综，人物也有很多。但是越往后读越能感受到不同人的情节间的交叉、错综，甚至是对人生有着相互的影响。</p><p>整本书主要讲述浪矢雄治先生开的『解忧杂货店』的形形色色的小故事，其中暗线是杂货店和各位人物与孤儿院『丸光园』之间的联系。通过办理解忧业务，浪矢先生曾在儿子面前一再坚持，而最终因病去世。</p><p>但这间杂货店仿佛有魔法一般。杂货店仿佛能沟通今昔，相互来信。情节部分就不过多赘述了，总而言之写得非常圆润，给人一种即在情理之中，又在意料之外的感觉。</p><p>要说起能从书中读到什么，还要从那个寄语说起。</p><p>最近心烦意乱，总觉得有种莫名的压力，抑或是恐慌，故找到这本书，想让杂货店也为我“解解忧”。</p><p>在爱情和梦想之间徘徊不定、漂泊远方只为实现音乐梦想、面临家庭巨变无所适从……</p><p>这都是故事里的人们提出的烦恼。而他们的相遇、坚持、激励、奉献、不离不弃的陪伴，终究是他们都在某种意义上意识到了生而为人的价值，不论之前的选择是否是最优的。</p><p>人物之间的互相照应，是本只有一颗弱小脆弱心灵的丸光园孤儿，逐步迈向成长的阶梯，明白人世间的道理，最后懂得感恩，长大后终于明白了命运的抉择。</p><p>信任，在文中表现得尤为重要。不仅要相信自己，更要相信身边的每一个人，相信每一个可能为你好的建议（或许这些当时觉得并不正确）。只有团结和信任，才能使人在团体中得到发展。</p><p>若对于个体，重要的是永不言弃。坚信自己认为的正确道路，在他人的共同助理下，方可实现梦想。只有历经挫败、坎坷之后，风雨初晴时，放得见彩虹。</p><p>其实读完之后回看现实，等风雨过后回望过去时，也许会发出感慨：“原来不就是这么点事情嘛！”所以，杂货店真正解忧的是内心对过去和未来的幻想。我们真正留在当下：对未来，不恐惧；对过去，不怨恨。这时，才真正“解忧”了。</p><p>放弃天地间的幻想，留在现在，或许明天更美好呢~</p><p>不论是为自己，还是为你。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好题摘录 &lt;01&gt;</title>
      <link href="/post/441796a1a298.html"/>
      <url>/post/441796a1a298.html</url>
      
        <content type="html"><![CDATA[<h1 id="problem.1-等比数列求和">Problem.1 等比数列求和</h1><p>题目标签：分治、数学</p><h2 id="题目大意">题目大意</h2><p>对于有 <span class="math inline">\(x+1\)</span> 项的等比数列 <spanclass="math inline">\(A=a^0+a^1+\cdots+a^x\)</span>，求</p><p><span class="math display">\[(\sum\limits_{i-1}^xa^i)\bmod p\]</span></p><h2 id="数据范围">数据范围</h2><p><span class="math inline">\(1\leq a_i,x\leq 10^{18},1\leq p\leq10^9\)</span>。</p><h2 id="解题思路">解题思路</h2><p>考虑分治。</p><p>对于指数区间 <span class="math inline">\([0,m]\)</span>，令 <spanclass="math inline">\(m&#39;=\dfrac{m+1}{2}-1\)</span>。考虑对 <spanclass="math inline">\([0,m&#39;]\)</span> 和 <spanclass="math inline">\([m&#39;+1,m]\)</span> 分治进行处理。</p><p>对于区间 <span class="math inline">\([0,m&#39;]\)</span>，求得 <spanclass="math inline">\(U=\sum\limits_{i=0}^{m&#39;}a^i\)</span>。</p><p>对于区间 <spanclass="math inline">\([m&#39;+1,m]\)</span>，可以同时通过分治计算 <spanclass="math inline">\(V=a^{m&#39;+1}\)</span>，然后进行分类讨论：</p><ul><li>若 <span class="math inline">\(m\)</span>为奇数，则有偶数项，此时区间和为</li></ul><p><span class="math display">\[U+UV\]</span></p><ul><li>若 <span class="math inline">\(m\)</span>为偶数，则有奇数项，考虑先处理前 <spanclass="math inline">\(m-1\)</span> 项，最后加上第 <spanclass="math inline">\(m\)</span> 项，则区间和为</li></ul><p><span class="math display">\[U+UV+V^2\]</span></p><p>中间运算时加上取模运算即可。</p><h2 id="参考代码">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll x,a,p;</span><br><span class="line">ll v;</span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">(ll m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m)&#123;</span><br><span class="line">        v=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid=(m+<span class="number">1</span>)/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">    ll u=<span class="built_in">work</span>(mid);</span><br><span class="line">    ll lv=v;</span><br><span class="line">    v=v*a%p;</span><br><span class="line">    <span class="keyword">if</span>(m&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        ll ans=(u+u*v%p)%p;</span><br><span class="line">        v=lv*lv%p*a%p;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll ans=(u+u*v%p+v*v%p)%p;</span><br><span class="line">        v=v*v%p;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;x&gt;&gt;p;</span><br><span class="line">        a%=p;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">work</span>(x)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem.2-lis-number">Problem.2 LIS Number</h1><p>题目标签：组合数学、动态规划</p><p>题目来源：Topcoder SRM 585</p><h2 id="题目大意-1">题目大意</h2><p>设 <span class="math inline">\(A\)</span>是一个整数序列，<code>LIS Number</code> 是把 <spanclass="math inline">\(A\)</span>切成几个数列，每个数列内的数都单调增，能分出来的最小数列数。</p><p>例如，<span class="math inline">\(A=\{1,4,4,2,6,3\}\)</span> 的<code>LIS Number</code> 是 <spanclass="math inline">\(4\)</span>，因为我们可以用 <spanclass="math inline">\(\{1,4\} + \{4\} + \{2,6\} + \{3\}\)</span> 得到<span class="math inline">\(A\)</span>，并且没有办法创造一个连接 <spanclass="math inline">\(3\)</span>（或更少）个单调增序列。</p><p>特殊地，一个单调增序列的 <code>LIS Number</code> 是 <spanclass="math inline">\(1\)</span>。</p><p>你有 <span class="math inline">\(n\)</span> 种类型的卡片。每一个<span class="math inline">\(i\)</span>，对于 <spanclass="math inline">\(0\leq i&lt;n\)</span>，你有 <spanclass="math inline">\(cnt_i\)</span> 张 <spanclass="math inline">\(i\)</span> 型卡。每张第 <spanclass="math inline">\(i\)</span> 型卡上的数是 <spanclass="math inline">\(i\)</span>。</p><p>给你 <span class="math inline">\(cnt\)</span> 数组和整数 <spanclass="math inline">\(k\)</span>。你要排所有的卡成排，使所得到的整数序列的<code>LIS Number</code> 是 <span class="math inline">\(k\)</span> 。注意，你必须使用所有的卡，你只能选择它们的顺序。</p><p>计算 <span class="math inline">\(x\)</span>为你能产生的不同满足上述条件的序列数。计算并输出数 <spanclass="math inline">\(x\)</span> 模 <spanclass="math inline">\(1000000007(10^9+7)\)</span>。</p><h2 id="数据范围-1">数据范围</h2><p><span class="math inline">\(1 \leq n \leq 36,1\leq cnt_i \leq 36,1\leq k \leq 1296\)</span></p><h2 id="解题思路-1">解题思路</h2><p>考虑由小到大插入每种数字，进行动态规划。</p><p>我们设状态 <span class="math inline">\(f_{i,j}\)</span> 为：插入完前<span class="math inline">\(i\)</span> 种数字，共生成了 <spanclass="math inline">\(j\)</span> 个上升序列的方案数。</p><p>我们把安排好的数字看做一个序列，设当前序列里有 <spanclass="math inline">\(sum\)</span>个数字，我们要新安排进去的这种数字一共有 <spanclass="math inline">\(cnt\)</span> 个。</p><p>此时我们新加入一种新的数字。如果我们把一些数字安排到原来的每个上升序列的末尾，则这个大序列的<code>LIS Number</code> 不变，而插入到其他位置，必然会导致<code>LIS Number</code> 个数增加。</p><p>考虑枚举放 <span class="math inline">\(t\)</span> 个数字到共有 <spanclass="math inline">\(j\)</span>个上升序列的大序列末尾（即不会改变序列答案），则序列答案会增加 <spanclass="math inline">\(cnt-t\)</span>。</p><p>我们要把 <span class="math inline">\(u=cnt-t\)</span> 个数放在 <spanclass="math inline">\(v=sum+1-j+t\)</span> 个位置里（因为在总共的 <spanclass="math inline">\(sum+1\)</span> 个空格中，有 <spanclass="math inline">\(j-t\)</span>个位置已经被“放置在序列末尾”的策略占据），就可以把问题抽象成：把排成一列的<span class="math inline">\(u\)</span> 个球，分成 <spanclass="math inline">\(v\)</span>个抽屉里，允许有抽屉空着不放，求所有分法的方案数——这就可以用组合数处理，方案数为<span class="math inline">\(C_{u+v-1}^u\)</span>。</p><p>所以递推式为</p><p><span class="math display">\[f_{i,j+u}=f_{i-1,j}\cdot C_j^t \cdot C_{u+v-1}^u\]</span></p><h2 id="参考代码-1">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1305</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,cnt[MAXN],k;</span><br><span class="line">ll f[MAXN][MAXN],C[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;LISNumber.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;LISNumber.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;cnt[i];</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1296</span>;i++)&#123;</span><br><span class="line">        C[i][<span class="number">0</span>]=C[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            C[i][j]=C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            C[i][j]%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>][cnt[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum=cnt[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++) <span class="keyword">if</span>(f[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=<span class="built_in">min</span>(j,cnt[i]);t++)&#123;</span><br><span class="line">                <span class="type">int</span> x=sum+<span class="number">1</span>-j+t;</span><br><span class="line">                <span class="type">int</span> y=cnt[i]-t;</span><br><span class="line">                f[i][j+y]+=f[i<span class="number">-1</span>][j]*C[j][t]%mod*C[x+y<span class="number">-1</span>][y]%mod;</span><br><span class="line">                f[i][j+y]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][k];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem.3-小蓝的旅行计划">Problem.3 小蓝的旅行计划</h1><p>题目标签：贪心、线段树</p><p>题目来源：第十四届蓝桥杯大赛软件赛省赛</p><h2 id="题目大意-2">题目大意</h2><p>小蓝正计划进行一次漫长的旅行。小蓝计划开车完成这次旅行。显然他在途中需要加油，否则可能无法完成这次旅行。</p><p>小蓝要依次经过 <span class="math inline">\(n\)</span>个地点，其中从第 <span class="math inline">\(i-1\)</span> 个地点到达第<span class="math inline">\(i\)</span> 个地点需要消耗 <spanclass="math inline">\(Dis_i\)</span>升油。小蓝经过的每个地点都有一个加油站，但每个加油站的规定也不同。在第<span class="math inline">\(i\)</span> 个加油站加 <spanclass="math inline">\(1\)</span> 升油需要 <spanclass="math inline">\(Cost_i\)</span> 的费用，且在这个加油站最多只能加<span class="math inline">\(Lim_i\)</span> 升油。</p><p>小蓝的车的油箱也有容量限制，他的车上最多只能装载 <spanclass="math inline">\(m\)</span> 升油。</p><p>一开始小蓝的油箱是满的，请问小蓝需要准备多少钱才能顺利完成他的旅行计划。如果小蓝按给定条件无论准备多少钱都不能完成他的旅行计划，请输出<span class="math inline">\(-1\)</span> 。</p><h2 id="数据范围-2">数据范围</h2><p><span class="math inline">\(1 \leq n \leq 2\times 10^5\;,\;1 \leqDis_i\;,\;Lim_i\;,\;m \leq 10^9\)</span>。</p><h2 id="解题思路-2">解题思路</h2><p>考虑从第 <span class="math inline">\(1\)</span> 个点到第 <spanclass="math inline">\(n\)</span> 个点，逐个贪心考虑。</p><p>从开头开始旅行，每走到一个点，尽可能少地加油，使得可以到达这个点，一定比加好多油到这里划算。</p><p>所以只考虑到达该点时，剩余的油量 <spanclass="math inline">\(oil&lt;0\)</span>的情况时，在前面的加油站进行加油操作。</p><p>但是在哪里加油可以保证加油之后，一直走到这个当前的节点，一路上任何时刻油量小于油箱容量<span class="math inline">\(m\)</span>，并且花费最少呢？</p><p>考虑贪心处理，利用优先队列记录前面每一个加油站能加的油量和单价。注意，在到达位置<span class="math inline">\(i\)</span> 时，在位置 <spanclass="math inline">\(j\)</span> 加油，需要保证加 <spanclass="math inline">\(k\)</span> 升油之后，使得对于在 <spanclass="math inline">\([j,i]\)</span>中任意时刻，油箱里的油量需要小于等于 <spanclass="math inline">\(m\)</span>。而在这里加完 <spanclass="math inline">\(k\)</span>升油之后，会对后面旅途的油量产生影响，需要对 <spanclass="math inline">\([j,i]\)</span> 区间中的油量加上 <spanclass="math inline">\(k\)</span>。</p><p>考虑用线段树记录每个节点时的油量，进行区间查询、区间修改、单点修改。</p><p>当没有油可以加，并且到不了节点 <span class="math inline">\(i\)</span>时（即 <span class="math inline">\(oil&lt;0\)</span>且优先队列为空），判断无解。</p><h2 id="参考代码-2">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((tree[p].l+tree[p].r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (p&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (p&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">K</span>&#123;</span><br><span class="line">    <span class="type">int</span> cost,lim,id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(K x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cost&gt;x.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;K&gt; q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,maxx,tag;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].l=l,tree[p].r=r;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].l==tree[p].r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,ls);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].tag)&#123;</span><br><span class="line">        <span class="type">int</span> k=tree[p].tag;</span><br><span class="line">        tree[ls].maxx+=k;</span><br><span class="line">        tree[ls].tag+=k;</span><br><span class="line">        tree[rs].maxx+=k;</span><br><span class="line">        tree[rs].tag+=k;</span><br><span class="line">        tree[p].tag=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].maxx=<span class="built_in">max</span>(tree[ls].maxx,tree[rs].maxx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r)&#123;</span><br><span class="line">        tree[p].maxx+=k;</span><br><span class="line">        tree[p].tag+=k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(l,r,k,ls);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(l,r,k,rs);</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r) <span class="keyword">return</span> tree[p].maxx;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(l,r,ls));</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(l,r,rs));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> oil=m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> dist,cost,lim,i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;dist&gt;&gt;cost&gt;&gt;lim;</span><br><span class="line">        oil-=dist;</span><br><span class="line">        <span class="built_in">modify</span>(i,i,oil,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(oil&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;cost,lim,i&#125;);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;oil&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            K now=q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> cost=now.cost,lim=now.lim,id=now.id;</span><br><span class="line">            <span class="type">int</span> maxx=<span class="built_in">query</span>(id,i<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            lim=<span class="built_in">min</span>(lim,m-maxx);</span><br><span class="line">            <span class="type">int</span> add=<span class="built_in">min</span>(lim,-oil);</span><br><span class="line">            lim-=add;</span><br><span class="line">            ans+=add*cost;</span><br><span class="line">            oil+=add;</span><br><span class="line">            <span class="keyword">if</span>(lim) q.<span class="built_in">push</span>(&#123;cost,lim,id&#125;);</span><br><span class="line">            <span class="built_in">modify</span>(id,i,add,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(oil&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;cost,lim,i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem.4-distinct-numbers">Problem.4 Distinct Numbers</h1><p>题目标签：博弈论</p><p>题目来源：ARC137C</p><h2 id="题目大意-3">题目大意</h2><p>给定长为 <span class="math inline">\(N\)</span> 的非负整数列 <spanclass="math inline">\(A:a_1,a_2,\cdotsa_n\)</span>，保证元素互不相同。</p><p>Alice 和 Bob 在玩游戏。Alice为先手，两人轮流操作。每次操作选手可以如下进行：</p><ul><li>选择当前 <span class="math inline">\(A\)</span>中最大的元素，将其替换为一个更小的非负整数。要求替换后 <spanclass="math inline">\(A\)</span> 中元素仍然互不相同。</li></ul><p>首先无法操作的一方失败。当两人都采取最优策略时，求谁有必胜策略。</p><h2 id="数据范围-3">数据范围</h2><p><span class="math inline">\(2\leq N \leq 3\times 10^5,0\leq a_i\leq10^9\)</span>。</p><h2 id="解题思路-3">解题思路</h2><p>考虑每次都会将一个数减小，会有如下最优策略，记 <spanclass="math inline">\(x\)</span> 为最大元素， <spanclass="math inline">\(y\)</span> 为次大元素：</p><ol type="1"><li>若 <span class="math inline">\(y+1&lt;x\)</span>，即 <spanclass="math inline">\(x,y\)</span> 之间有空位。操作者可以将 <spanclass="math inline">\(x\)</span> 改变至大于 <spanclass="math inline">\(y\)</span> 或小于 <spanclass="math inline">\(y\)</span>，从而将局面交给对方。如果其中某个操作会失败，可以选择另一个操作。因为两种操作最后交给对方的局面是对立的。</li><li>若 <span class="math inline">\(y+1=x\)</span>，即 <spanclass="math inline">\(x,y\)</span> 之间没有空位。因为每次都会减少至少<span class="math inline">\(1\)</span>，每次会填补一个空，答案就会和<span class="math inline">\(\text{mex}\)</span>有关系。如果有奇数个空，那么前者胜，否则前者必败。</li></ol><h2 id="参考代码-3">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 300005</span></span><br><span class="line"><span class="type">int</span> t,n,a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>) num+=a[i];</span><br><span class="line">        <span class="keyword">else</span> num+=a[i]-a[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((a[n]==a[n<span class="number">-1</span>]+<span class="number">1</span>&amp;&amp;(num&amp;<span class="number">1</span>))||a[n]!=a[n<span class="number">-1</span>]+<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;Alice&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Bob&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem.5-present">Problem.5 Present</h1><p>题目标签：数学、思维</p><p>题目来源：CF1322B</p><h2 id="题目大意-4">题目大意</h2><p>给出一个长度为 <span class="math inline">\(n\)</span> 的数列 <spanclass="math inline">\(a\)</span>。其中第 <spanclass="math inline">\(i\)</span> 项为 <spanclass="math inline">\(a_i\)</span>。</p><p>求</p><p><span class="math display">\[\bigoplus\limits_{i=1}^n\bigoplus\limits_{j=i+1}^n(a_i+a_j)\]</span></p><p>其中 <span class="math inline">\(\oplus\)</span>表示按位异或操作。</p><h2 id="数据范围-4">数据范围</h2><p><span class="math inline">\(1\leq n\leq 4\times 10^5,1\leq a_i\leq10^7\)</span>。</p><h2 id="解题思路-4">解题思路</h2><p>首先可以得到 <span class="math inline">\(O(n^2)\)</span>的暴力算法。我们换个思路考虑问题。</p><p>我们直接求解答案的每一个二进制位，可以从低位向高位处理每个位。对于答案的第<span class="math inline">\(k\)</span> 个二进制位，考虑其为 <spanclass="math inline">\(1\)</span> 的条件：<spanclass="math inline">\(\forall a_i+a_j(1\leq i&lt;j\leqn)\)</span>，统计其和的第 <span class="math inline">\(k\)</span> 位为<span class="math inline">\(1\)</span> 的个数 <spanclass="math inline">\(num\)</span>，只有 <spanclass="math inline">\(num\)</span> 位奇数时，这一位才可能位 <spanclass="math inline">\(1\)</span>，只与比其小的位有关。</p><p>从此我们得到了这个重要的性质，那我们就要考虑怎样统计 <spanclass="math inline">\(num\)</span>。</p><p>对于第 <span class="math inline">\(k\)</span> 位（最低位为第 <spanclass="math inline">\(0\)</span> 位），我们只考虑一个数 <spanclass="math inline">\(b\)</span> 的前 <spanclass="math inline">\(k\)</span> 低位，这个操作可以简单地通过 <spanclass="math inline">\(b\&amp;(2^{k+1}-1)\)</span>得到，得到的数的取值范围为 <spanclass="math inline">\([0,2^{k+1}-1]\)</span>。</p><p>这一位为 <span class="math inline">\(1\)</span> 有如下两种可能：</p><ul><li>没有进位，那么和在 <spanclass="math inline">\([2^{k},2^{k+1}-1]\)</span> 的范围内；</li><li>若有进位，那么和在 <spanclass="math inline">\([2^{k+1}+2^k,(2^{k+1}-1)\times 2]\)</span>，等价于<span class="math inline">\([2^i\times 3,2^{k+2}-2]\)</span>。</li></ul><p>这样我们得到了两个连续的区间。我们只需要找和在这两个区间范围内的<span class="math inline">\(a_i+a_j\)</span> 即可（这里的 <spanclass="math inline">\(a_i,a_j\)</span> 只保留前 <spanclass="math inline">\(k\)</span> 小位）。</p><p>我们可以通过双指针求出这个个数。具体地，令 <spanclass="math inline">\(b_i=a_i\&amp;(2^{k+1}-1)\)</span>。因为顺序不影响结果，不妨先对<span class="math inline">\(b\)</span> 升序排序。那么对于每一个 <spanclass="math inline">\(b_i\)</span>，每个满足 <spanclass="math inline">\(b_i+b_j\)</span> 在合法范围内的 <spanclass="math inline">\(j\)</span>是连续的，而且具有单调性。我们从大到小枚举 <spanclass="math inline">\(i\)</span> 的时候（因为排过序，所以 <spanclass="math inline">\(b_i\)</span> 也是从大到小的），合法的 <spanclass="math inline">\(j\)</span> 的区间是单调不降的。这样可以 <spanclass="math inline">\(O(n)\)</span> 的时间内求出低 <spanclass="math inline">\(k\)</span> 位为 <spanclass="math inline">\(1\)</span> 的加和的个数 <spanclass="math inline">\(num\)</span>，进而判断答案的第 <spanclass="math inline">\(k\)</span> 位是否为 <spanclass="math inline">\(1\)</span>。</p><p>因为需要枚举每个二进制位 <spanclass="math inline">\(k\)</span>，所以算法的总时间复杂度为 <spanclass="math inline">\(O(n\log N)\)</span>，其中 <spanclass="math inline">\(N\)</span> 为值域。</p><h2 id="参考代码-4">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 400005</span></span><br><span class="line"><span class="type">int</span> n,a[MAXN],b[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">count</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>,i=n;i;i--)&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=n&amp;&amp;b[i]+b[l]&lt;x) l++;</span><br><span class="line"><span class="keyword">while</span>(r&lt;=n&amp;&amp;b[i]+b[r]&lt;=y) r++;</span><br><span class="line">cnt+=r-l;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=l&amp;&amp;i&lt;r) cnt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (cnt&gt;&gt;<span class="number">1</span>)&amp;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;=<span class="number">24</span>;p++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">b[i]=a[i]&amp;((<span class="number">1</span>&lt;&lt;(p+<span class="number">1</span>))<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line"><span class="type">bool</span> k1=<span class="built_in">count</span>(<span class="number">1</span>&lt;&lt;p,(<span class="number">1</span>&lt;&lt;(p+<span class="number">1</span>))<span class="number">-1</span>);</span><br><span class="line"><span class="type">bool</span> k2=<span class="built_in">count</span>(<span class="number">3</span>&lt;&lt;p,(<span class="number">1</span>&lt;&lt;(p+<span class="number">2</span>))<span class="number">-2</span>);</span><br><span class="line">ans|=((<span class="number">1</span>&amp;(k1^k2))&lt;&lt;p);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem.6-签到题">Problem.6 签到题</h1><p>题目标签：图论、异或操作</p><p>题目来源：校内联考 [SO Round 1] T2</p><h2 id="题目大意-5">题目大意</h2><p>给你一张 <span class="math inline">\(n\)</span> 个点，<spanclass="math inline">\(m\)</span> 条边的无向图，边有边权 <spanclass="math inline">\(w\)</span>，定义一条路径的价值为它所经过的边的边权的异或和。</p><p>求从节点 <span class="math inline">\(1\)</span> 到节点 <spanclass="math inline">\(n\)</span> 的价值最大的路径的价值。</p><h2 id="数据范围-5">数据范围</h2><p><span class="math inline">\(1 \le n,m \le 3 \times 10^5,0 \le w \le2^{30}\)</span>。</p><h2 id="解题思路-5">解题思路</h2><p>很巧妙的想法。</p><p>我们可能走很长的路径，每个路径的转移不符合三角形不等式，所以不能用求解最短路的方法求解。换个思路，因为是异或和，我们无需考虑具体怎样走的，只用考虑要走哪个边：考虑如果图上有一个环，我们可以任意地走这个简单环。如果我们从一个节点进，又从环的这个节点出去，这样只对对答案有影响。</p><p>那我们就可以找到图上的每个简单环，最后找到从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 的路径即可。</p><p>或许我们实现的可以更加简单一些：我们构造出一个 <spanclass="math inline">\(\text{dfs}\)</span>生成树，对于不在树上的边，只可能是返祖边，从而构成一个环。我们记 <spanclass="math inline">\(dis_i\)</span> 为从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(i\)</span>在生成树上面的路径价值。我们把这样每一个环放到线性基里面，最后只需要在线性基里面求出关于<span class="math inline">\(dis_n\)</span>的最大异或和即可。（这意味着我们在一条从 <spanclass="math inline">\(1\)</span> 走到 <spanclass="math inline">\(n\)</span> 的路径上随意地走简单环）</p><p>时间复杂度为 <span class="math inline">\(O(n\log w)\)</span>。</p><h2 id="参考代码-5">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 300005</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">int</span> n,m,dis[MAXN],t[<span class="number">50</span>];</span><br><span class="line">vector&lt;pii&gt; g[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]) x^=t[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                t[i]=x;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> nd:g[u])&#123;</span><br><span class="line">        <span class="type">int</span> v=nd.first,c=nd.second;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">            <span class="built_in">insert</span>(dis[u]^dis[v]^c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dis[v]=dis[u]^c;</span><br><span class="line">            <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!((x&gt;&gt;i)&amp;<span class="number">1</span>)) x^=t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x,y,c,i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;c;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(&#123;y,c&#125;);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(&#123;x,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">query</span>(dis[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem.7-树">Problem.7 树</h1><p>题目标签：思维，树论</p><p>题目来源：清华集训 2012-2013 day 4</p><h2 id="题目大意-6">题目大意</h2><p>有一颗 <span class="math inline">\(n\)</span>个节点的二叉树，编号1至n。你将这些节点依次删除，并规定你只能删除没有父亲的节点（即删除一个节点前，必须将其祖先全部删除）。这棵树可能有三种形态：</p><ol type="1"><li>一个链，准确地说，每个点最多只有一个儿子；</li><li>满二叉树；</li><li>普通的二叉树。</li></ol><p>你并不知道这棵树的形态，只能通过以下方式询问：</p><ul><li><code>size()</code>：返回这棵树的节点数量 <spanclass="math inline">\(n\)</span>；　</li><li><code>type()</code>：返回这棵树的类型；</li><li><code>question(p,q)</code> ：返回 <spanclass="math inline">\(p\)</span> 号点和 <spanclass="math inline">\(q\)</span> 号点的关系。若返回值为 <spanclass="math inline">\(1\)</span>，表示 <spanclass="math inline">\(p\)</span> 是 <spanclass="math inline">\(q\)</span> 的祖先，若返回值为 <spanclass="math inline">\(-1\)</span>，表示 <spanclass="math inline">\(q\)</span> 是 <spanclass="math inline">\(p\)</span> 的祖先，否则返回值为 <spanclass="math inline">\(0\)</span>。你用这个询问的次数将关系到你的分数；</li><li><code>void submit(x)</code>：完成回答，表示删除 <spanclass="math inline">\(x\)</span> 号节点。</li></ul><p>你需要做的，就是通过<strong>尽可能少的 <code>question</code>询问</strong>将所有点全部删除。你的答案得到满分，调用<code>question</code> 函数从次数必须为 <spanclass="math inline">\(O(n\log n)\)</span> 级别。</p><h2 id="数据范围-6">数据范围</h2><p><span class="math inline">\(1 \le n \le 300000\)</span>。</p><h2 id="解题思路-6">解题思路</h2><p>对于部分分，我们有 <span class="math inline">\(O(n^2)\)</span>的暴力算法，下面直接讲能得到满分的正解。</p><p>考虑选择一个点，则我们删除这个节点与根之间最短路径的每一个节点才能删除这一个节点。</p><p>那我们就若干次随机化，每次随机选择一个节点，目的是删除这个节点到根的所有节点（构成一条链）后删除这个节点。我们每一次对于这个节点向全局进行<code>question</code> 询问，了解哪些节点是它的祖先，单次复杂度 <spanclass="math inline">\(O(n)\)</span>。我们依次删除祖先节点。因为我们删除这条链之后，会分割成若干棵子树，我们有需要在这些子树中分别进行删点操作。因为我们使用随机化算法，每次的链长期望为<span class="math inline">\(O(\log n)\)</span>。</p><p>我们需要记录这条链上所有的节点，从而继续进行操作。考虑到我们还需要对节点到根（或所在子树的顶）的这条链按照祖先顺序排序，我们需要使用<strong>归并排序</strong>算法。为什么不使用快速排序呢，考虑到归并排序的复杂度是严格<span class="math inline">\(O(n\log n)\)</span>的，最坏复杂度比快速排序更加优一些（或许因为这道题卡常）。我们只需要使用C++ 自带的 <code>stable_sort</code> 函数进行排序，并重定义<code>cmp</code> 函数即可。</p><p>对于 <code>type</code> 为 <span class="math inline">\(1\)</span>的树，即一条链，我们只需要选择链底的节点，进行一次操作即可，详见参考代码。</p><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><h2 id="参考代码-6">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">question</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">submit</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 300005</span></span><br><span class="line"><span class="type">int</span> dep[MAXN],n,a[MAXN];</span><br><span class="line"><span class="type">bool</span> ins[MAXN];</span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">question</span>(x,y)==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt; p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> n=p.<span class="built_in">size</span>(),now=p[<span class="built_in">rnd</span>()%n];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; fa;</span><br><span class="line">    fa.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v!=now&amp;&amp;<span class="built_in">question</span>(v,now)==<span class="number">1</span>) fa.<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    fa.<span class="built_in">push_back</span>(now);</span><br><span class="line">    <span class="built_in">stable_sort</span>(fa.<span class="built_in">begin</span>(),fa.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> m=fa.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; son;</span><br><span class="line">    son.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:fa) ins[v]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ins[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">question</span>(fa[mid],v)) l=mid;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        son[l].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">submit</span>(fa[i]);</span><br><span class="line">        <span class="built_in">solve</span>(son[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=i;</span><br><span class="line">        <span class="built_in">stable_sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">submit</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">solve</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem.8-stack-exterminable-arrays">Problem.8 StackExterminable Arrays</h1><p>题目标签：思维，字符串，哈希</p><p>题目来源：CF1223F</p><h2 id="题目大意-7">题目大意</h2><p>给一个长度为 <span class="math inline">\(n\)</span>的数列，对于其中一段子序列称为可被删除的，当且仅当按照下表顺序，按照如下要求进栈和出栈后栈为空：</p><ul><li><p>如果当前元素等于栈顶元素，则弹出栈顶元素；</p></li><li><p>否则将当前元素压入栈中。</p></li></ul><p>求有多少个子序列为可被删除的。</p><h2 id="数据范围-7">数据范围</h2><p><span class="math inline">\(1\le \sum n,\sum q\le 3\times10^5\)</span>。</p><h2 id="解题思路-7">解题思路</h2><p>CSP-S 2023 T2 的原题，可惜考场并没有想出正确的思路。</p><p>理解题意后我们发现，我们可以枚举每一个可被删除的子序列（下面简称为“合法子序列”）的起始位置，进行栈模拟，就可以找到以这个位置开始的所有合法子序列。这是一个时间复杂度为<span class="math inline">\(O(n^2)\)</span> 的算法。</p><p>我们考虑进行简化。如果只从第一个位置进行栈模拟，发现所有合法的子序列都有如下性质：</p><ul><li>设 <span class="math inline">\(p_i\)</span> 表示栈在第 <spanclass="math inline">\(i\)</span> 个位置的状态，如果子序列 <spanclass="math inline">\(l\dots r\)</span> 是合法的子序列，则有 <spanclass="math inline">\(p_{l-1}=p_r\)</span>，即经过合法子序列后栈的状态和未经过时一样。</li></ul><p>考虑怎么证明这个东西。</p><p>如果 <span class="math inline">\(l\dots r\)</span>内的数会和栈里面的数抵消。形式化地，记栈为 <spanclass="math inline">\(S=YX\)</span>，当前合法的子序列形如 <spanclass="math inline">\(XYYX\)</span>，两个 <spanclass="math inline">\(X\)</span> 或抵消，同时子序列内部重复的 <spanclass="math inline">\(Y\)</span> 也会抵消，最后剩下 <spanclass="math inline">\(X\)</span>，入栈，这样栈内元素又一样了。</p><blockquote><p>例子 <span class="math inline">\(\quad\)</span> 对于序列<code>2 2 3 3 2</code>，子序列取区间 <spanclass="math inline">\([2,5]\)</span> 时，<spanclass="math inline">\(p_1=\{2\}\)</span>，<spanclass="math inline">\(p_5=\{2\}\)</span>，二者相等，说明子序列<code>2 3 3 2</code> 是合法的子序列。</p></blockquote><p>那么我们就可以只进行一个堆栈模拟，记录到每个位置的 <spanclass="math inline">\(p_i\)</span>，可以对其进行字符串哈希，再用一个哈希表记录当前以前的所有栈状态，统计每个位置与其相等的栈状态即可。复杂度<span class="math inline">\(O(n)\)</span>。</p><p>对于 <code>unordered_map</code> 类型的变量，可以使用<code>&lt;name&gt;.reserve(_size)</code> 进行预制大小。</p><h2 id="参考代码-7">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 300005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 5323</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> p 233</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">int</span> Q,n,s[MAXN],top,a[MAXN],num[MAXN];</span><br><span class="line">ull hs[MAXN],table[MAXN],lable[MAXN];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx=<span class="number">300000</span>;</span><br><span class="line">unordered_map&lt;ull,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;Q;</span><br><span class="line">    table[<span class="number">0</span>]=lable[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxx;i++) table[i]=table[i<span class="number">-1</span>]*mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxx;i++) lable[i]=lable[i<span class="number">-1</span>]*p;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">        top=ans=<span class="number">0</span>;</span><br><span class="line">        mp.<span class="built_in">clear</span>();</span><br><span class="line">        mp.<span class="built_in">reserve</span>(n+<span class="number">5</span>);</span><br><span class="line">        mp[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==a[s[top]])&#123;</span><br><span class="line">                hs[i]=hs[i<span class="number">-1</span>]-table[top]*lable[a[i]];</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s[++top]=i;</span><br><span class="line">                hs[i]=hs[i<span class="number">-1</span>]+table[top]*lable[a[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(hs[i])!=mp.<span class="built_in">end</span>()) ans+=mp[hs[i]];</span><br><span class="line">            mp[hs[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem.9-cow-tennis-tournament">Problem.9 Cow TennisTournament</h1><p>题目标签：组合计数、思维、线段树</p><p>题目来源：CF283E</p><h2 id="题目大意-8">题目大意</h2><p>有 <span class="math inline">\(n\)</span> 个点，每个点有一个点权<spanclass="math inline">\(s_i\)</span>，一开始，每个点向比其点权小的点连边。接下来<span class="math inline">\(k\)</span> 个操作，每个操作给定 <spanclass="math inline">\(l,r\)</span>，将 <spanclass="math inline">\(s_x,s_y\in [l,r]\)</span> 的点对 <spanclass="math inline">\((x,y)\)</span> 的边翻转方向。</p><p>问最后有多少对三元组 <span class="math inline">\((x,y,z)\)</span>满足 <span class="math inline">\(x\rightarrow y,y\rightarrowz,z\rightarrowx\)</span>​。（箭头表示连边方向）两个三元组不同当且仅当有一个点在其中一个三元组中而不在另一个三元组中。</p><h2 id="数据范围-8">数据范围</h2><p><span class="math inline">\(3\le n\le 10^5,0\le k\le 10^5,1\le s_i\le10^9,1 \le a_i &lt; b_i \le 10^9\)</span>。</p><h2 id="解题思路-8">解题思路</h2><p>考虑到正面思考好像很难，正难则反，考虑有多少组三元组不符合这个条件。</p><p>不难发现，对于不满足条件的三元组 <spanclass="math inline">\((x,y,z)\)</span>，其中肯定有一个点的出度（在这三个点构成的图中）为<spanclass="math inline">\(2\)</span>。我们就考虑能否求出每个点在最后有多少个出度，进而求出答案。</p><p>因为一段区间翻转，只会对这个区间内的点对 <spanclass="math inline">\((x,y)\)</span>产生变化，不妨按照扫描线的思路，按照点权大小排序后，对离散化的点权建立线段树，表示每个点是否对当前点<span class="math inline">\(x\)</span>的连边有翻转（即区间翻转操作是奇数次还是偶数次）。我们把每个操作拆分为两个：</p><ul><li>左端标记在区间 <span class="math inline">\([l,r]\)</span>翻转；</li><li>右端标记在区间 <span class="math inline">\([l,r]\)</span>撤销翻转，即再进行一次翻转即可。</li></ul><p>我们按照离散化的点集，按照权值从小到大扫描。再每一个点记录当前点的出度：</p><ul><li>对于比当前点 <span class="math inline">\(x\)</span> 点权小的点 <spanclass="math inline">\(y\)</span>，当前点连向这个点，当且仅当区间 <spanclass="math inline">\([y,x)\)</span> 的翻转次数为偶数次；</li><li>对于比当前点 <span class="math inline">\(x\)</span> 点权大的点 <spanclass="math inline">\(y\)</span>，当前点连向这个点，当且仅当区间 <spanclass="math inline">\((x,y]\)</span> 的翻转次数为奇数次。</li></ul><p>这样，我们进行区间修改，区间查询，就可以在 <spanclass="math inline">\(O(\log n)\)</span>的时间内求出一个点的出度。根据组合公式，可以得到不合法的种类数为 <spanclass="math inline">\(C_{num}^2\)</span>，其中 <spanclass="math inline">\(num\)</span> 为出度。</p><p>所以最后答案就是</p><p><span class="math display">\[C_n^3-\sum\limits_{i=1}^nC_{num_i}^2\]</span></p><h2 id="参考代码-8">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((tree[p].l+tree[p].r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (p&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (p&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,k,s[MAXN];</span><br><span class="line">ll ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; add[MAXN],del[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,sum[<span class="number">2</span>];</span><br><span class="line">    <span class="type">bool</span> tag;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].sum[<span class="number">0</span>]=tree[ls].sum[<span class="number">0</span>]+tree[rs].sum[<span class="number">0</span>];</span><br><span class="line">    tree[p].sum[<span class="number">1</span>]=tree[ls].sum[<span class="number">1</span>]+tree[rs].sum[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].l=l,tree[p].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[p].sum[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,ls);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tree[p].tag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">swap</span>(tree[ls].sum[<span class="number">0</span>],tree[ls].sum[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">swap</span>(tree[rs].sum[<span class="number">0</span>],tree[rs].sum[<span class="number">1</span>]);</span><br><span class="line">    tree[ls].tag^=<span class="number">1</span>;</span><br><span class="line">    tree[rs].tag^=<span class="number">1</span>;</span><br><span class="line">    tree[p].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(tree[p].sum[<span class="number">0</span>],tree[p].sum[<span class="number">1</span>]);</span><br><span class="line">        tree[p].tag^=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(l,r,ls);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(l,r,rs);</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> op,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r) <span class="keyword">return</span> tree[p].sum[op];</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) sum+=<span class="built_in">query</span>(l,r,op,ls);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) sum+=<span class="built_in">query</span>(l,r,op,rs);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;s[i];</span><br><span class="line">    <span class="built_in">sort</span>(s+<span class="number">1</span>,s+<span class="number">1</span>+n);<span class="comment">//按照点权排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x,y,i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        x=<span class="built_in">lower_bound</span>(s+<span class="number">1</span>,s+<span class="number">1</span>+n,x)-s;<span class="comment">//求出离散化后的操作范围</span></span><br><span class="line">        y=<span class="built_in">upper_bound</span>(s+<span class="number">1</span>,s+<span class="number">1</span>+n,y)-s<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y&lt;x) y=x;</span><br><span class="line">        add[x].<span class="built_in">push_back</span>(y);<span class="comment">//建立类扫描线</span></span><br><span class="line">        del[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:add[i]) <span class="built_in">modify</span>(i,v,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> cnt1=<span class="built_in">query</span>(<span class="number">1</span>,i<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//比当前点点权小的点所带来的出度</span></span><br><span class="line">        <span class="type">int</span> cnt2=<span class="built_in">query</span>(i+<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//比当前点点权大的点所带来的出度</span></span><br><span class="line">        <span class="keyword">if</span>(cnt1+cnt2&gt;=<span class="number">2</span>) ans+=<span class="number">1ll</span>*(cnt1+cnt2)*(cnt1+cnt2<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">//组合答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:del[i]) <span class="built_in">modify</span>(v,i,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="number">1ll</span>*n*(n<span class="number">-1</span>)*(n<span class="number">-2</span>)/<span class="number">6</span>-ans;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem.10-作业-homework">Problem.10 作业 Homework</h1><p>题目标签：根号分治</p><p>题目来源：2006上海省选 (SHOI2006)</p><h2 id="题目大意-9">题目大意</h2><p>给定一个集合为 <spanclass="math inline">\(S\)</span>，初始为空，你需要执行以下两个操作共<span class="math inline">\(N\)</span> 次。</p><ol type="1"><li>在集合 <span class="math inline">\(S\)</span>中加入一个新元素，其代号为 <span class="math inline">\(X\)</span>，保证<span class="math inline">\(X\)</span> 在当前集合中不存在。</li><li>在当前的集合 <span class="math inline">\(S\)</span> 中询问所有元素<span class="math inline">\(\bmod\ Y\)</span> 最小的值。</li></ol><h2 id="数据范围-9">数据范围</h2><p><span class="math inline">\(1\le N\le 10^5,1\le X,Y\le 3\times10^5\)</span>。</p><h2 id="解题思路-9">解题思路</h2><p>看到维护操作中有取模操作，且难以维护区间信息，考虑根号分治。</p><p>记 <span class="math inline">\(T=\sqrt{3\times10^5}\)</span>。具体地，将询问的 <span class="math inline">\(Y\)</span>划分为两个种类：</p><ul><li>若 <span class="math inline">\(Y\leT\)</span>，则这样的<strong>模数</strong>最多有 <spanclass="math inline">\(T\)</span>种，对每一种值在添加数据时暴力维护（添加并取最小值）；</li><li>若 <spanclass="math inline">\(Y&gt;T\)</span>，考虑到<strong>商数</strong>最多有<span class="math inline">\(T\)</span> 种，即对于 <spanclass="math inline">\(Y/x=p\dots\dots q\)</span> 的 <spanclass="math inline">\(p\)</span> 最多有 <spanclass="math inline">\(T\)</span> 种。变化式子为 <spanclass="math inline">\(x-pY=q\)</span>，枚举每一个 <spanclass="math inline">\(p\)</span>，则可以算出该商数情况下的最小 <spanclass="math inline">\(q\)</span> 值。具体地，利用 <code>set</code> 维护<span class="math inline">\(S\)</span> 中的数，对于每一个模数 <spanclass="math inline">\(p\)</span>，找到第一个大于等于 <spanclass="math inline">\(pY\)</span>，减一下即可得到该模数下的最小 <spanclass="math inline">\(q\)</span> 值。</li></ul><p>令 <span class="math inline">\(\omega\)</span>为值域，则插入一次复杂度 <spanclass="math inline">\(O(\sqrt{\omega})\)</span>，查询一次复杂度为 <spanclass="math inline">\(O(1)\)</span> 或 <spanclass="math inline">\(O(\sqrt{\omega} \log n)\)</span>，总复杂度 <spanclass="math inline">\(O(n\sqrt{\omega}\log n)\)</span>，可通过此题。</p><h2 id="参考代码-9">参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSQRTN 555</span></span><br><span class="line"><span class="type">int</span> lim=<span class="number">550</span>,n,p[MAXSQRTN];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++) p[i]=<span class="built_in">min</span>(p[i],x%i);</span><br><span class="line">    s.<span class="built_in">insert</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=lim) <span class="keyword">return</span> p[x];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;<span class="number">1ll</span>*k*x&lt;=<span class="number">300000</span>;k++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> t=s.<span class="built_in">lower_bound</span>(k*x);</span><br><span class="line">        <span class="keyword">if</span>(t==s.<span class="built_in">end</span>()) <span class="keyword">break</span>;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,*t-k*x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(p));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">char</span> ch;<span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;ch&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;A&#x27;</span>) <span class="built_in">add</span>(x);</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="built_in">query</span>(x)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 好题摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 好题摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数基础</title>
      <link href="/post/9909702601bf.html"/>
      <url>/post/9909702601bf.html</url>
      
        <content type="html"><![CDATA[<p>线性代数基础</p><p>线性代数是OI中常用的一部分数学知识。本篇主要记录高斯消元法和基础矩阵变换。</p><h1 id="一矩阵">一、矩阵</h1><p>矩阵是数学中常用的代数工具。当然，信息代数中的重点也许与数学不同，但大体思路相仿。</p><h2 id="quad-矩阵的定义">1.1<span class="math inline">\(\quad\)</span>矩阵的定义</h2><p><strong>矩阵</strong><spanclass="math inline">\(\quad\)</span>对于一个由 <spanclass="math inline">\(n\times m\)</span>个数根据某些性质、关系组成的向量表 <span class="math display">\[\begin{bmatrix}a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,m}\\a_{2,1}&amp;a_{2,2}&amp;\cdots&amp;a_{2,m}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,m}\\\end{bmatrix}\]</span> 称为 <span class="math inline">\(n\times m\)</span>的矩阵，记作矩阵 <span class="math inline">\(\mathbf{A}\)</span>。</p><p>若矩阵 <span class="math inline">\(\mathbf{A}\)</span> 和矩阵 <spanclass="math inline">\(\mathbf{B}\)</span> 都是 <spanclass="math inline">\(n\times m\)</span> 的矩阵，则称 <spanclass="math inline">\(\mathbf{A}\)</span> 与 <spanclass="math inline">\(\mathbf{B}\)</span> 为<strong>同形矩阵</strong>。</p><p>若矩阵 <span class="math inline">\(\mathbf{A}\)</span> 和矩阵 <spanclass="math inline">\(\mathbf{B}\)</span> 为同形矩阵，并且 <spanclass="math inline">\(\forall i\in [1,n],j\in [1,m]\)</span>，都有 <spanclass="math inline">\(a_{i,j}=b_{i,j}\)</span>，则称 <spanclass="math inline">\(\mathbf{A}=\mathbf{B}\)</span> 。</p><h2 id="quad-特殊矩阵">1.2<span class="math inline">\(\quad\)</span>​特殊矩阵</h2><p><strong>方阵</strong>：有 <span class="math inline">\(n\)</span> 行<span class="math inline">\(n\)</span> 列的矩阵。</p><p><strong>零矩阵</strong>：每个元素都是 <spanclass="math inline">\(0\)</span> 的矩阵，记为 <spanclass="math inline">\(\mathbf{0}\)</span>。</p><p><strong>行向量</strong>：只有一行的矩阵称为行矩阵。</p><p><strong>列向量</strong>：只有一列的矩阵称为列举阵。</p><p><strong>单位矩阵</strong>：主对角线元素均为 <spanclass="math inline">\(1\)</span>，其余元素全为 <spanclass="math inline">\(0\)</span> 的 <spanclass="math inline">\(n\)</span> 阶方阵。</p><p><strong>数量矩阵</strong>：主对角线元素均为 <spanclass="math inline">\(k\)</span>，其余元素全为 <spanclass="math inline">\(0\)</span> 的 <spanclass="math inline">\(n\)</span> 阶方阵。</p><h2 id="quad-矩阵的基本运算">1.3<spanclass="math inline">\(\quad\)</span> 矩阵的基本运算</h2><h3 id="矩阵加法">矩阵加法</h3><p>只有同形矩阵才能进行矩阵加法。</p><p>矩阵加法即同位置的数相加。设 <spanclass="math inline">\(\mathbf{A}\)</span>、<spanclass="math inline">\(\mathbf{B}\)</span>为 <spanclass="math inline">\(n\times m\)</span> 的矩阵，<spanclass="math inline">\(\mathbf{C}=\mathbf{A}+\mathbf{B}\)</span>，则<span class="math inline">\(\forall i\in[1,n],j\in[1,m]\)</span>： <spanclass="math display">\[C_{i,j}=A_{i,j}+B_{i,j}\]</span></p><h3 id="数乘运算">数乘运算</h3><p>数乘运算即矩阵中每一个数都乘这个数。设 <spanclass="math inline">\(\mathbf{A}\)</span>为 <spanclass="math inline">\(n\times m\)</span> 的矩阵，<spanclass="math inline">\(\mathbf{C}=\lambda\mathbf{A}\)</span>，则 <spanclass="math inline">\(\forall i\in[1,n],j\in[1,m]\)</span>： <spanclass="math display">\[C_{i,j}=\lambda A_{i,j}\]</span></p><h3 id="矩阵乘法">矩阵乘法</h3><p>两个矩阵能够相乘，当且仅当其中一个矩阵的第二维等于另一个矩阵的第一维。</p><p>设 <span class="math inline">\(\mathbf{A}\)</span> 为 <spanclass="math inline">\(n\times m\)</span> 的矩阵，<spanclass="math inline">\(\mathbf{B}\)</span> 为 <spanclass="math inline">\(m\times w\)</span> 的矩阵，设 <spanclass="math inline">\(\mathbf{C}=\mathbf{A}\times\mathbf{B}\)</span>，则： <span class="math display">\[C_{i,j}=\sum^m_{k=1}A_{i,k}+B_{k,j}\]</span> 特殊地，如果 <span class="math inline">\(\mathbf{A}\)</span>为 <span class="math inline">\(n\times n\)</span> 的矩阵，<spanclass="math inline">\(\mathbf{B}\)</span> 为 <spanclass="math inline">\(1\times n\)</span> 的列矩阵，那么 <spanclass="math inline">\(\mathbf{B}\)</span> 可省略一维，记 <spanclass="math inline">\(\mathbf{C}=\mathbf{A}\times\mathbf{B}\)</span>，则 <span class="math inline">\(\mathbf{C}\)</span>为与 <span class="math inline">\(\mathbf{B}\)</span> 同型的矩阵，<spanclass="math inline">\(\forall i\in [1,n]\)</span>​： <spanclass="math display">\[C_{i}=\sum^n_{k=1}A_{i,k}+B_{k}\]</span> 矩阵乘法满足<strong>结合律</strong>，即： <spanclass="math display">\[(\mathbf{A}\times\mathbf{B})\times\mathbf{C}=\mathbf{A}\times(\mathbf{B}\times\mathbf{C})\]</span> 满足<strong>分配律</strong>，即： <spanclass="math display">\[(\mathbf{A}+\mathbf{B})\times\mathbf{C}=\mathbf{A}\times\mathbf{C}+\mathbf{B}\times\mathbf{C}\]</span></p><h3 id="转置运算">转置运算</h3><p>矩阵转置就是将矩阵行列调换位置。</p><p>设 <span class="math inline">\(\mathbf{A}\)</span> 为 <spanclass="math inline">\(n\times m\)</span> 的矩阵，设 <spanclass="math inline">\(\mathbf{A^T}\)</span> 为矩阵 <spanclass="math inline">\(\mathbf{A}\)</span> 的转置，则 <spanclass="math inline">\(\forall i\in[1,n],j\in[1,m]\)</span>：</p><p><span class="math display">\[A^T_{i,j}=A_{j,i}\]</span></p><h1 id="二高斯消元">二、高斯消元</h1><p>高斯消元是求解线性方程组的一个方法。</p><p>如，对于下面这个 <span class="math inline">\(n\)</span>个未知数的线性方程组，求解每个未知数的值。 <span class="math display">\[\begin{cases}x_1&amp;+2x_2&amp;-x_3&amp;=-6\\2x_1&amp;+x_2&amp;-3x_3&amp;=-9\\-x_1&amp;-x_2&amp;+2x_3&amp;=7\end{cases}\]</span> 我们可以由此构造一个 <span class="math inline">\(N\)</span> 行<span class="math inline">\(N\)</span> 列的增广矩阵 <spanclass="math inline">\(\mathbf{A}\)</span>，其内容为各未知项系数及常数项，如下：<span class="math display">\[\mathbf{A}=\begin{bmatrix}1&amp;2&amp;-1\\2&amp;1&amp;-3\\-1&amp;-1&amp;2\end{bmatrix}\]</span> 同理，我们也可以构造一个列向量 <spanclass="math inline">\(\mathbf{X}\)</span> 和列向量 <spanclass="math inline">\(\mathbf{B}\)</span>，分别包含各各未知数与常数，如下：<span class="math display">\[\mathbf{X}=\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}\qquad\mathbf{B}=\begin{bmatrix}-6\\-9\\7\end{bmatrix}\]</span> 我们就可以由此转换为矩阵方程： <span class="math display">\[\begin{bmatrix}1&amp;2&amp;-1\\2&amp;1&amp;-3\\-1&amp;-1&amp;2\end{bmatrix}\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}=\begin{bmatrix}-6\\-9\\7\end{bmatrix}\]</span> 我们的目标是求出矩阵 <spanclass="math inline">\(\mathbf{X}\)</span>。根据矩阵乘法具有结合律，我们可以设法让等号两边同时乘以若干矩阵，使得矩阵<span class="math inline">\(\mathbf{A}\)</span>成为单位矩阵，即可求出矩阵 <spanclass="math inline">\(\mathbf{X}\)</span>。也就是说，在主对角线上的数，通过变换，使其成为<span class="math inline">\(1\)</span>，其他数成为 <spanclass="math inline">\(0\)</span>。</p><p>考虑在保证数量关系的前提下消元，使用如下方法：</p><ol type="1"><li><p>对这一行消元，使得该行对角线上的数为 <spanclass="math inline">\(1\)</span>。也就是除以这一行对角线上的数即可。</p></li><li><p>对其他行消元，利用对角线上的数和其他行的数的关系，使得其他行不在对角线上的数为<span class="math inline">\(0\)</span>。</p></li></ol><p>如此重复处理，直至形成单位矩阵。</p><p>注意，等号左右两边需要同时处理，才能保证等号成立。所以我们可以直接合并两个矩阵，更方便地直接对一个矩阵进行变换，如下：<span class="math display">\[\left[\begin{array}{ccc|c}1&amp;2&amp;-1&amp;-6\\2&amp;1&amp;-3&amp;-9\\-1&amp;-1&amp;2&amp;7\end{array}\right]\]</span> 使左部分矩阵成为单位矩阵后，右边的列向量就是答案。</p><p>我们可以进行如下操作，即 <strong>初等行变换</strong>：</p><ol type="1"><li>用一个非零的数乘到某一行；</li><li>把其中一行的若干倍加到零一行上；</li><li>交换两行的位置。</li></ol><p>进行如下操作： <span class="math display">\[\left[\begin{array}{ccc|c}1&amp;2&amp;-1&amp;-6\\2&amp;1&amp;-3&amp;-9\\-1&amp;-1&amp;2&amp;7\end{array}\right]\Longrightarrow\left[\begin{array}{ccc|c}1&amp;2&amp;-1&amp;-6\\0&amp;-3&amp;-1&amp;3\\-1&amp;-1&amp;2&amp;7\end{array}\right]\Longrightarrow\left[\begin{array}{ccc|c}1&amp;2&amp;-1&amp;-6\\0&amp;-3&amp;-1&amp;3\\0&amp;1&amp;1&amp;1\end{array}\right]\]</span></p><p><span class="math display">\[\Longrightarrow\left[\begin{array}{ccc|c}1&amp;2&amp;-1&amp;-6\\0&amp;1&amp;1&amp;1\\0&amp;-3&amp;-1&amp;3\end{array}\right]\Longrightarrow\left[\begin{array}{ccc|c}1&amp;2&amp;-1&amp;-6\\0&amp;1&amp;1&amp;1\\0&amp;0&amp;2&amp;6\end{array}\right]\Longrightarrow\left[\begin{array}{ccc|c}1&amp;2&amp;-1&amp;-6\\0&amp;1&amp;1&amp;1\\0&amp;0&amp;1&amp;3\end{array}\right]\]</span></p><p>然后消去右上角： <span class="math display">\[\left[\begin{array}{ccc|c}1&amp;2&amp;-1&amp;-6\\0&amp;1&amp;1&amp;1\\0&amp;0&amp;1&amp;3\end{array}\right]\Longrightarrow\left[\begin{array}{ccc|c}1&amp;2&amp;0&amp;-3\\0&amp;1&amp;0&amp;-2\\0&amp;0&amp;1&amp;3\end{array}\right]\Longrightarrow\left[\begin{array}{ccc|c}1&amp;0&amp;0&amp;1\\0&amp;1&amp;0&amp;-2\\0&amp;0&amp;1&amp;3\end{array}\right]\]</span> 此时，右边的矩阵就是 <spanclass="math inline">\(\mathbf{X}\)</span> 矩阵，即，解得： <spanclass="math display">\[\begin{cases}x_1=1\\x_2=-2\\x_3=3\end{cases}\]</span></p><p>为了更格式化、更方便地处理问题，下面给出高斯消元的标准方法。</p><p><strong>高斯消元法</strong> <spanclass="math inline">\(\quad\)</span> 对于任意一个存在 <spanclass="math inline">\(n\)</span> 个数、<spanclass="math inline">\(n\)</span> 个方程的线性方程组： <spanclass="math display">\[\begin{cases}a_{1,1}x_1+a_{1,2}x_2+\cdots+a_{1,n}x_n=b_1\\a_{2,1}x_1+a_{2,2}x_2+\cdots+a_{2,n}x_n=b_2\\\vdots\\a_{n,1}x_1+a_{n,2}x_2+\cdots+a_{n,n}x_n=b_n\\\end{cases}\]</span> 构造一个 <span class="math inline">\(N\)</span> 行 <spanclass="math inline">\(N+1\)</span> 列的矩阵： <spanclass="math display">\[\left[\begin{array}{cccc|c}a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n}&amp;b_1\\a_{2,1}&amp;a_{2,2}&amp;\cdots&amp;a_{2,n}&amp;b_2\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,n}&amp;b_n\\\end{array}\right]\]</span> 对于每个未知量 <spanclass="math inline">\(x_i\)</span>，找到一个 <spanclass="math inline">\(x_i\)</span> 的系数非零，但 <spanclass="math inline">\(x_1\sim x_{i-1}\)</span> 的系数都被消成了 <spanclass="math inline">\(0\)</span> 的方程，利用初等行变换把其他方程的<span class="math inline">\(x_i\)</span> 的系数全部消成 <spanclass="math inline">\(0\)</span>。</p><p>需要注意的是，如果有任意一个 <spanclass="math inline">\(x_i\)</span>，找不到非零的方程，则无解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 105</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++) cin&gt;&gt;a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> nowi=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="keyword">for</span>(t=nowi;t&lt;=n;t++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[t][j])&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t==n+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=j;i&lt;=n+<span class="number">1</span>;i++) <span class="built_in">swap</span>(a[nowi][i],a[t][i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>;i&gt;=j;i--) a[nowi][i]/=a[nowi][j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==nowi) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=n+<span class="number">1</span>;k&gt;=j;k--)&#123;</span><br><span class="line">                a[i][k]-=a[i][j]*a[nowi][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nowi++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nowi&lt;=n)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,a[i][n+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三矩阵求逆">三、矩阵求逆</h1><p><strong>逆矩阵</strong><span class="math inline">\(\quad\)</span>对于一个矩阵 <spanclass="math inline">\(\mathbf{A}\)</span>，若存在一个矩阵 <spanclass="math inline">\(\mathbf{A&#39;}\)</span>，有 <spanclass="math inline">\(\mathbf{AA&#39;=E(单位矩阵)}\)</span>，则称 <spanclass="math inline">\(\mathbf{A&#39;}\)</span> 为 <spanclass="math inline">\(\mathbf{A}\)</span> 的逆矩阵。</p><p>现在给定一个矩阵 <spanclass="math inline">\(\mathbf{A}\)</span>，求他的逆矩阵 <spanclass="math inline">\(\mathbf{A&#39;}\)</span>。</p><p>我们可以考虑如下的思路。我们可以通过构造多个矩阵，考虑将矩阵 <spanclass="math inline">\(\mathbf{A}\)</span> 消成单位矩阵，也对 <spanclass="math inline">\(\mathbf{E}\)</span>做相同操作，这样一来，就可以得出 <spanclass="math inline">\(\mathbf{A&#39;}\)</span>。</p><p>进而，我们通过矩阵乘法，构造多个矩阵，有： <spanclass="math display">\[\mathbf{A_1A_2\cdots A_k A=EA_1A_2\cdots A_k}\]</span> 得出答案 <span class="math display">\[\mathbf{A&#39;=A_1A_2\cdots A_k}\]</span> 简化考虑，我们的目标是将 <spanclass="math inline">\(\mathbf{A}\)</span> 消成 <spanclass="math inline">\(\mathbf{E}\)</span>。因为矩阵乘法具有结合律所以我们可以同时在<span class="math inline">\(\mathbf{A}\)</span> 和原单位矩阵 <spanclass="math inline">\(\mathbf{E}\)</span> 同时进行高斯消元，目标是使<span class="math inline">\(\mathbf{A}\)</span>成为单位矩阵。即对于两部分的矩阵 <spanclass="math inline">\(\left[\begin{array}{c|c}\mathbf{A}&amp;\mathbf{E}\end{array}\right]\)</span>，对左半部分消元即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 405</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n,a[MAXN][MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) w=w*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) cin&gt;&gt;a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i][i+n]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> r=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j][i])&#123;</span><br><span class="line">                r=j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r!=i) <span class="built_in">swap</span>(a[i],a[r]);</span><br><span class="line">        <span class="keyword">if</span>(!a[i][i]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>),<span class="number">0</span>;</span><br><span class="line">        ll x=<span class="built_in">qpow</span>(a[i][i],mod<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k==i) <span class="keyword">continue</span>;</span><br><span class="line">            ll t=a[k][i]*x%mod;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=(n&lt;&lt;<span class="number">1</span>);j++)&#123;</span><br><span class="line">                a[k][j]=((a[k][j]-t*a[i][j])%mod+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=(n&lt;&lt;<span class="number">1</span>);j++) a[i][j]=a[i][j]*x%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            cout&lt;&lt;a[i][j+n]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四行列式及求值">四、行列式及求值</h1><p>行列式和矩阵相似，都是用来解决线性问题的工具。</p><h2 id="quad-行列式的定义">4.1<span class="math inline">\(\quad\)</span>行列式的定义</h2><p><strong>行列式</strong><span class="math inline">\(\quad\)</span>对于一个 <span class="math inline">\(n\)</span> 阶的方阵，它的行列式记作<span class="math inline">\(|A|\)</span>，其值为： <spanclass="math display">\[|A|=\sum_p\prod_{i=1}^n a_{i,p_i}(-1)^{\tau(p)}\]</span> 其中，<span class="math inline">\(p\)</span> 为 <spanclass="math inline">\(1..n\)</span> 的排列，<spanclass="math inline">\(\tau(p)\)</span> 为排列 <spanclass="math inline">\(p\)</span> 中的逆序对数。</p><h2 id="quad-行列式的部分性质">4.2<spanclass="math inline">\(\quad\)</span> 行列式的部分性质</h2><h3 id="三角行列式的值">三角行列式的值</h3><p>对于上三角行列式，其值为主对角线的乘积，即： <spanclass="math display">\[\begin{vmatrix}a_{1,1}&amp;a_{1,2}&amp;a_{1,3}&amp;\cdots&amp;a_{1,n}\\0&amp;a_{2,2}&amp;a_{2,3}&amp;\cdots&amp;a_{2,n}\\0&amp;0&amp;a_{3,3}&amp;\cdots&amp;a_{3,n}\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;a_{n,n}\\\end{vmatrix}=\prod_{i=1}^n a_{i,i}\]</span> 由定义即可推出，证明略。</p><h3 id="某行乘系数-c等于整体乘-c">某行乘系数 <spanclass="math inline">\(c\)</span>，等于整体乘 <spanclass="math inline">\(c\)</span></h3><p>即： <span class="math display">\[\begin{vmatrix}a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n}\\a_{2,1}&amp;a_{2,2}&amp;\cdots&amp;a_{2,n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ca_{i,1}&amp;ca_{i,2}&amp;\cdots&amp;ca_{i,n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,n}\\\end{vmatrix}=c\begin{vmatrix}a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n}\\a_{2,1}&amp;a_{2,2}&amp;\cdots&amp;a_{2,n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{i,1}&amp;a_{i,2}&amp;\cdots&amp;a_{i,n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,n}\\\end{vmatrix}\]</span> 由定义即可推出，证明略。</p><h3 id="交换两行符号取反">交换两行，符号取反</h3><p>即： <span class="math display">\[\begin{vmatrix}a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{i,1}&amp;a_{i,2}&amp;\cdots&amp;a_{i,n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{j,1}&amp;a_{j,2}&amp;\cdots&amp;a_{j,n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,n}\\\end{vmatrix}=-\begin{vmatrix}a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{j,1}&amp;a_{j,2}&amp;\cdots&amp;a_{j,n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{i,1}&amp;a_{i,2}&amp;\cdots&amp;a_{i,n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,n}\\\end{vmatrix}\]</span> <strong>证明</strong><spanclass="math inline">\(\quad\)</span> 不妨设原行列式为 <spanclass="math inline">\(|A|\)</span>，变换后的矩阵为 <spanclass="math inline">\(|A&#39;|\)</span>，有： <spanclass="math display">\[\begin{aligned}|A|=\sum_p (-1)^{\tau(p)}a_{1,p_1}a_{2,p_2}\cdots a_{i,p_i}\cdotsa_{j,p_j}\cdots a_{n,p_n}\\|A&#39;|=\sum_p (-1)^{\tau(p)}a_{1,p_1}a_{2,p_2}\cdots a_{i,p_j}\cdotsa_{j,p_i}\cdots a_{n,p_n}\end{aligned}\]</span> 可以看到，两者的唯一区别就是 <spanclass="math inline">\(a_{i,p_i},a_{j,p_j}\)</span> 和 <spanclass="math inline">\(a_{i,p_j},a_{j,p_i}\)</span>。</p><p>由于 <span class="math inline">\(p\)</span> 为前排列，所以可以忽略<span class="math inline">\(p\)</span> 位置的影响，只用考虑调换 <spanclass="math inline">\(p_i,p_j\)</span> 对 <spanclass="math inline">\(\tau(p)\)</span> 的影响。</p><p>考虑每一个 <spanclass="math inline">\(k,i,j\in[1,n],k\not=i,k\not=j,i&lt;j\)</span>：</p><ol type="1"><li><p>若 <span class="math inline">\(k&lt;i\)</span>：调换 <spanclass="math inline">\(p_i,p_j\)</span> 之后关于 <spanclass="math inline">\(p_k\)</span> 的逆序对数不变。</p></li><li><p>若 <span class="math inline">\(k&gt;j\)</span>：调换 <spanclass="math inline">\(p_i,p_j\)</span> 之后关于 <spanclass="math inline">\(p_k\)</span> 的逆序对数也不变。</p></li><li><p>若 <span class="math inline">\(i&lt;k&lt;j\)</span>：调换 <spanclass="math inline">\(p_i,p_j\)</span> 之后关于 <spanclass="math inline">\(p_k\)</span> 逆序对数会<strong>成对地变化</strong>。</p></li><li><p><span class="math inline">\(p_i,p_j\)</span>位置变化会带来逆序对数变化 <span class="math inline">\(1\)</span>个。</p></li></ol><p>综上，变化之后 <span class="math inline">\(\tau(p)\)</span> 的<strong>奇偶性</strong> 会发生变化，也就是 <spanclass="math inline">\(|A|=-|A&#39;|\)</span>。</p><p>证毕。</p><h3id="若存在两行对应成比例则行列式值为-0">若存在两行对应成比例，则行列式值为<span class="math inline">\(0\)</span></h3><p><strong>证明</strong><span class="math inline">\(\quad\)</span>构造符合要求的行列式并进行推导： <span class="math display">\[\begin{vmatrix}a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{i,1}&amp;a_{i,2}&amp;\cdots&amp;a_{i,n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ca_{j,1}&amp;ca_{j,2}&amp;\cdots&amp;ca_{j,n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,n}\\\end{vmatrix}=c\begin{vmatrix}a_{1,1}&amp;a_{1,2}&amp;\cdots&amp;a_{1,n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{i,1}&amp;a_{i,2}&amp;\cdots&amp;a_{i,n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{j,1}&amp;a_{j,2}&amp;\cdots&amp;a_{j,n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{n,1}&amp;a_{n,2}&amp;\cdots&amp;a_{n,n}\\\end{vmatrix}\]</span> 可以发现这个行列式有两行相等，设其为 <spanclass="math inline">\(|A|\)</span>，可知，交换两行后矩阵数值不变，但等于<span class="math inline">\(-|A|\)</span>。故原行列式值为 <spanclass="math inline">\(0\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『初丶晴』旧忆</title>
      <link href="/post/b6814f85452d.html"/>
      <url>/post/b6814f85452d.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="欸? 这个『通行证』看着不太对, 再试试看呢..." data-whm="密码不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="f6bb870c458ce7bc775ddc719732e489f61c58f88799ebfb054de645c1c37d03">8dfed501bcaa90b15714e3bdc993ce4cd992d53dfa3b2cc635d9ae939003f1ddcc424989075bdf424c5cb8f31000e57a9db4b0b97597d7d935821682bf3633fffd00d5c963e68ad05871d197e65a01321f85019fd432b205f717ff68148ebc12c0b49a072407ab0677d01a937dfceb2e0a2e14a4984b60038ff67269d4921698512bf2c771ae7bcd71038c80bee8545adc71622332fbe3847f4be15490d5d6026b95a1bd83f5f8a92d20f21e7611929dc818dc3198c2a62c85a6f3104ab0c940e4e2f06a2d537f321bc84189b6ce308efc4b670e4207fd2c181973dab3024b8722245d5b1b12d92ce8152e6db968c59d67266e22b2f3116a0cf468cdf89f38d593492529516303569d3c9789f3540608117ee674d6dd97cca3cad96662fea97efb44a4fe3610eb3c283bec16b5f35b329464b881d65241dc1211fe17ef06703329b2ec82e93d5ed3e6e9d654a543804d10f69d89e57aecb20fcf80ebb35b597685a583d9a4d4624d623dcccca4b44e0975536fa46e905f726fbf8906821721b46733c56202be6fd94dc48bfbecbef74b19ae394aad6f64865e32b4885fe1f7d3b70f2a3c1eac07d4e62f22dec8e3e62480899afeb0e0c854fde4a375a2a472ea1df69ff2f0b0ac26d4c7435fad86a833083d4ce77da44f65e8f4a9488927f43f10554ff3f142fb7e2d84a0107ec7d4b18f42361c62fedf37cda92869ca87e9afa724ba7c5c2212fd5b9fdf5fbf9e13209f92ff6f398ea47e7878da198ab248fdd0b7cfb6739f5573f8cd092d89ab5ebe8df2559ab68840878bd40c54a2d76f1b08941d1eace032b960698ef55ee0db931c0b2db243d78b8b45fc2fb084907e5128e18b2c451d78214d7f10a83c262841b74db9ad4901d49f29f92bfce0f07a766b6f3d092db51063921f13bc1da024dd401873c159768ef4806758f077177b7b91d42aca5675af3f0e7a4ad3b1b9a4b90576a50131ec8f0f7a127d17f8ea54ea5cd96e7c14ce4eb14b9295ddbf4d3ad2c458fc33cdcbb2d56a5024ad025d96297df62eb80b17c4a0dbeb26a9736fff59bc61b4db7a6c7304c47f5c8dbf3ec091a40af4ad81884f51042bff4d66459535d55fb7dfded96a76dff2643755e572e3ed51786ce9877a9b4aab7a93560123f884121650238ed69abb7313d0a7eb8327694f1a8d8764e256d18afaa828fc3f18f491576bd3f73529b176b2c3f41fa03f03f636b0fe5668d18c44fbeca089060d56116c394321979dd473f1abd21567bb341d93a4ef4c4467851bbb6365263eaa5724f8c036fe00b02ab13d0a10163e130400e2b3f8235bfa74cca2dcd6e7f4a9de8fa1067cef969895e168e04e024d472373a67b97fdc415cec3a36a8c2f418b769e9ea00227630eeb3ad70ef92133f0e317948909dd895d3f2e33c13d4fa16fc0807ba927670a12deba0f60c54f28ebc6eeec42d6072228d25d9b6beaa6127a97afe5972230b29d353fba22511b95c1a027a1219ee2529a2f5fdc6fd914373246d1f38cb89e48c95f4bb24ab968c7318a6d53fdf28d8271fae3f9d2cfe63a5b4638cde99d2efb4c6e50a13324f916bfba669ec2c055128087a494e207bb31a1addc6b30d6de2044614b7b4af8832077def68b08e69973bedd1340de9a57d465a25237da91b8a29f22cec0f34a0029d6783a99f43dc3d2e9619287aa879d853807063bb3409a20683a1ec769274572331b07da553faaffbb5a91c7e862d0ec5d202207dc5ea45be44bef6f7c139c9bda93836df92a6118b155aaad7dd4c6f122ae8ce2f2f001d9d5795f16322f0aaf079c78c2e35ffa8cfda00ffa92e742200b229c7004a86bb121ca9e7798ab7bb2d5a6b3dec4c6a4f6bbbcf5acab97c860ed3b0c34e016699304f007c4970627744439694aa92d2d1c2c6678f42716ee429bc6b173e833c69ea0755d92d815b72b4115560640b4a39163290f279137184eb7df169b8461338c3dd0df3f10b0f51e4a85768010f841b67ef8643afd147584d42cf9947f670d622882921f93f84d4453aa2185cae6f90a9c3d658f1a7e46660996c87d8988b8b972767ddcf5bf6f4e31df1cf8ed704dc27a87c3f30889ed0a9f577440e34ed5c88a3d847bd11d930da398cc18359750c595fec530f22f2e7875e49fca0e255d88f4d3b59d9f097539c35a165de410775c2bd74dbb406d4768d598b9481739818358f167158f5262986a32e9bd98f1536284c9fbd17603f6cb2a7980755963d899fb774f5a47cc65eca74012fb8dc88ca63a0823cb0602637cd6492d36936d0f67238723e2d226dbfb5fe58b1e718cff52329a7087407120477ecd9fcbacd366f0fcd6d18383f594f7a910cd941b43192f3bf3a9c659c1e6e55c499813bf930e3d60f05fa7838c1099ee6ac3e224f4181ab7ad6d4799f9291c617a129e0d4002efbfb93d2f815b33c3c230e310a5c4384e4d1ff4b9147286d6b7e2f222000dfb7b98f5990bfe1f4e6812990f38eba7ed8d47e4233273242a135f941f85360c899ee7081db0e81131382fc9bea444b105053006576655ef73d9672182a90cb61e4342a5a798b2cc98da895ee37098b01c24dcc58a03c6642decfe14c1fc1ab8dbf63b84b9a3e701f8514f87ad1f77c9c8db1ed4b831c550411d167acf80221176423a124acea22c76d5fe3d7ab63f72e38bcf196390295a1fe90e3cdefc14c06452c83777ad1af168995b99872f5cc4532cba31ad585e12b00790d2eb33b5347d84861f3a7b8dc7ef6f95dfd1231cbd13af1b36479ec0a4a20eef490debb7bc355b4c1d920483dd0a8a8105edda75cdbd9c73271c135df3a61cad9a42e5f0c199c3f1b97457b00bde4aee997ab79f6b5a8ce856721fe9c0f1836a080a8ff07049bdd78ce78fe2a0e8524f42d650366917c0c2c785f30dd7c8fb57e65cf4051c99e1c25ebeade2c7c0fe0a10023345a6facbc20d11d5a5766b641201a8c80f1ec87645f6965f00ad613602e88323e4388bebc66efe1dd1b720045e473944121f4afdc4ba0ad8a3996d9add2a39bbb4e3b6d82a815b9ce7428a3e798194f9101598e4aaa297ad90e6a3ac5466a24f5630f3efa673aa78322efe58793ae97a6fa57182ae15921d4a70b3470485bbf74b69e56ad2202b6180fbe3aab73c2d7f9ff74074d368bdbbed84d3d7a83f0910cdc501a7f1c9699bf874aa70f1825d415a9e6a7362b3eb1dbd389039a18d4d4f0e0f07c286e1799638420eeaaf39c382a20fdd354a7a7ffa80fb2c9714ea59bdae1e22d3c05a641b84019271902e86b98029bdd554796ac836c96b36a80881b6109cd7d063237de301609a74fe3831b0546ad88dfebed97b2bc2f5d14e2333960646283d77c9a77ec9272354a0ff31b7e841fd4c0cb86a56eae7684d1f0f82b6781fc4442d904219232c07ff531e1e92331d728028c69c4fd006699e03a46acae5f4196e21a95286f148733b6407c1e2793fd797ff83de4592aa627219aa887e0994b8218a0674f44fe46a4939d53727471434661d177a2fc6fc0b2b0a056e29490ace58d2cb46b088711e1210ff399ec91a5460e18cb64ae3895c5ba1613dcc363a8f8f0199cdff1fffacc7e96931e13889f844cd56063a6520a3d92dfa0cd496c94cb00f08326903ac7a03e31268f3e402e079f07da910e9c7fe0ac628eb66f8b4dc7b74041a3a253f47385395bcbda2aab5752737a692c1e0dcf712bd9e9c5133c447e1e2af20d04414b4ec2bf0d8e2e9ce2b6d18b70ddba08dd44c254ce2b1dbf159275b45f8d72a1311ab6dcb55a202e416e474e7d6fb49257a153a1ca5c87d79476f4a70042f9beecc814b14b7cc9e6102ecd33c02820cc661606ee784c390684e16455f648d896e10db6d41ff5dc7e5b938c12f29a9b5250bbb5c9bc61953586cd7b489c7770990827215792a62207ebb467014769c10f0bf88f3f7725c94fd4f271b2e82c899c9025453a1df00089bdfe45a173f6680b5c7800a6c273ab14def0657345644dfdea80cb7fe8a7785286c410ac29aef71787be2349691746eb051d5af7f11ce807ad94ced87f73327355525b874a19dc0b4e931371fd21c2b9be35c1584ebcd7cc6d80c71f73621141df100c30d479273f83bf2dd473be1163ab6eea26a91ee9fc7dbcd915d52a572bf2b38277ec5960214f9403c8afe7b5ed0111325c9abe9339e12d849a935210856246adfe3911375b6fd593176997ec3ffb1aabb7926f13b23789cded09eeecf52694036b81a72cdc414728cf9880af910efafaf9dfa76f0cdce7a506ebcfa0582a966a0182c6847594e7712ca171f71f1054c295a47602edb18a28f9fb05fd58060b336f0f443a6549767f5175e4245be39f3af042cb2a2c0f28afc1f870d4dc432681228dd67954c451c6a5da527ec2862ca1fef5d14d6a867eaa9d4a5d8101ee8c4fffbdf80c40676c3c20c1f15210a75d0cc600914fb76e091c3b48b228a55b1287192072becec4a698b441a89c7386d70710f02c022c50488432636a3a0855533215c5e088c831d9416f238189326d376a186f023683af0b6195908d2c3dcd15994ce258ec6f5b7992bd293bd2e7b68f8424b52dcca222f1714cd40f4fc51866214726c2ea3e9bce13c01f57c331ad0cb2928236864f35eb78739214b8e13f463fcdf65360ff17e8a5f79b591032c57dd8dee12a34bd6b67e976fee3fe420875c6d3133a7d3772252374a26a029ef2d44f39bc8fac2d492483e7a9600cf88f58367dec8c7bcdb08394c2a5832e857336957767b61980da287e70ffe2e9f87262faa59a7b82a638d8ec9ed33654dede8a15aec24b1ebf23e6c6ada740eea556e3e5b0642a8a214b9980cc242ae9673682e893e863c8cc075bb564b66864a4d5abc02f6d47629082e7ec6a4b221c5011db7694c3de6eb616c6611e7cdf29428b551a011ff89de1ccf2039a8942116d9bd71cbce9659c25585c117690fd362bfa8b998e29bc8f53ea41991e53f6a074edcd303d08ca7270dbfe1f0396a9a5bc45a40cf944f9908c12450699e3e7d3cb7148948e604bf36d9ed7bb662695c3ff626af7bf6419ba3347e5b72d5b7489fd4ac4e7138467fbd7f524eb2a080fe866193507d0114bcbc539e19e41cca4e458406d08d592d6fe2024b07666ccda25fe28498e47511ea7d6928a0fc573a4508658bcefd2c32b16ad4144f8882387f13233f6d0ca61cb729ab00dba58a56d5555eb8f542befbc4fdc8417699df8bb880dbb24b70c39727b2b64946438c2f06ee2004a9ba202a427312e2ae75d8a151e169d66d930a8abed6d30adb0179d103186103fad4417788e227adce0d4c66b1240b641281b8c9fe1c175eef9c414f90e4e3bbce1fe5380e3d24ec32ebe40add8c81f7c11dbaffaf3b8bbd8f614de3e3bba88962e5494704ecd13bcf249ae39949b33d2f6095037d1b3cef84c4a73d99ee4ed7b23f68f64b2753f7a45af8f82aad702bd4dfd9568157b0fb205d322f6569ed2d747766059002d91f8ec2436c23f8872e729edbc3c6d5a27e11d806ec861e7ce4760bb29315a074f7cd03ec0dbf521655612dd87068094a9edcc5ff4bfd4c27d6ca072eaf15ce3d33176ae3d9fc33f69f202d35dc8ba90aa2b1f209f5cbb5cc232bd24442c85c5a1989c7bf5c83efc58ac76301b4ca4377f616b7dd71a7291dc9396766b073e8b54d7a7a853d1e3453682912c27ae4a21e59520293e9f8417eb935d7cd367ab5c3e43c169a49702f2f06db4b4016dea35addba6f8e712033798f878e7796013e2a2b77d5a58e1747691bb9ef914f31b823458a8bbaebef6035c657e9c1f6c4a1d6573ac056a5d5f43eb0af48f00264467b539388b32e040a8d4ab42641243edc7b85eadc5efa7d025bb979cf2ac45320758d9245426dcddc0888cf278c72d303f1085049966c9005f9c5e095e5e2d586e9064772c70fe63b71779f3b7c803acaaf5a862c6b294f434d1bdfaa0d7f5973400b82edf2be4b980e9c4857563e5630a4f1594a28b586e95efda1a90a86361a3d9b064232ed08e6b40193a69299d92bce6a1223787ab14cc85a3c059defcbcbc52cb5032a839350f887a3de9c2fa8de5807591a35f904e4341590bcf541eeb2a3be6f9e926a18c80a374923f7dd4d62d99fe6761511abcc91219bd1d77b31e8e4a29e112470b38a95576207d035c6a7b5aa6e378b679e9371a4c1893960017ae981753fd40ad107cebec8aa8d76f073a3b038cf8f273ba09aaede95dac1da2bc9781c2197bb8568044f48a134b3a45ddca89e6d311fc595bf67970c8a1be07d0970ac9cd1db1061e3f87da297adeb844956c827d1a453dc75a7a71b4df93c5457738475236ae161baff5e41c09794aea7d8bdd1c1f5224fbb0b48b93cb3e52d2e60f5c22fdec71488c0ad2e716d3e8bb975ab87cfe7ab753aad59664455fa4dc97e291a3ab6b87fe315b99b7476c30d817e331fd6f8587698563bb74d6dc3eb45feeba3db0568dec62bf4523449b9a5e2c4e3a9945ebd31e193f0c3b4d7ab4e7f5123fd29b096d145eec812a8988f7d34be5954b3cdc9068b0e0698d621b154f61af066242733f7f72ed862c299ee06b3694753e94a76be5e2aedeb1ed72bc912336ddb48a1e15a9c518623fe1b4204faf64d7fbcf438ca8a75a7e80e94434d5063abe2cf38e10f3221f0b804125c4407dcf0c1cfbef2e9c1b02328d0bdbd9746d87f874ec5ac98916f92ef608bf02f0acafa68440df9e72211569d772109692b5d17f7732107c1f645e7bc53355e1bc67e577b5c8688bba4887af9bac5e4589326e9677d3d7c053e0e3bccb17636cb78b2056a9e8b2a6bf9fde822217a081ed372963f439cb62935e6720259321f27ba5fa3d3fc36711cb625abb415cafd7328a70d82b67529f7574ca9eb45ae603ae3fcb45b5a4f61358499665e2fb36575fe442f9e468d132f3ea4b697f311a28211e6e30a30181781177ea426a438d0824b242d4a7a74e463d2aa12f8dd70a40bcc81843cf268a26cd6b416bd58bcd02ae5053d34d73f1ee866de6146eb058e41d0e7a747775982f51e92fdd021898c627c2a1621480eca8204bd194203e6eaf0158c0f8daed5bff18ca38f829ec0c6954414c8d33abd9a6852357dd432c496e6db61481dd70d882f9301701d23abaf67328d87d9ffd021457629247ff25d137e7b446a16383ef98c43e5815edb5ef11ab3fb456efdda90a6798744524a1e61c7e0c61a5452f9bebc7b1397b5ff13d5527d787a0293f8bcaec4d10e3c5a2aa452c8280da4670d060ee2234f44c7be55a580ff26674649a01d1d20ebf57ecffe34c1a975b4e40254d419752ef31df6018a59720fbd74bbe040000bea97cf4c9af585f36a2347b443e74132db5f882f96e79b5a9fa841b709d8beda94fdd4eaf19cae190c0b9378800d071d896a7ea511f955d5cbcfd0bc93605eb09e25103fc6c2d491f085ee1ff3b6e8cb27a90e7f0442757b29f0161149fc5edca1a1246500461745977f850628d394f5e95056fea5d84a1b4e653f75651aa428bedd497b7eab70c7290f918e8274c6ad353ea9a2c6b00f39186f97ab735d932e35a9de3712b8882947cbf40974fc767fb2642976e20cb851b013d15eab7796b8a61eaa9eded6f2f05475270af17752f3f75170227019cf3b42b33a228e28d2460a9fe13b48ed77b00dc385b3c6b6cd786af8157c93a8557f66b511fdf07056dd653c7449a17ea6c9aefd76365a6956e5800ddf706127ddcd2337647dbb9b2b5c2103837829fc1dd1ef1b7131e430ecadedf9d27fad851314ad1edc4c8e610700ba0f1ce91a415eff275af7e8c6343da07a5d3e3990e06527f54eaef978ecba6b7deb54fcc831d6afeb0508fae917b827a1823d11aa50094a1660229c4448a2fc508fe9217848964c667c52ba830dbefcc24a423b49b82831e849eb365f0e20af52c8a0541f150af8d65245707476520aa63785fdbf0313ef1049d62564e44b01a30b1ff445b55b069b84b81b82811268ff1aa4450da80694071d0b81e01b92dbbf2d7c7e0ac9c4a698673e21e1a551d18b3de99cc1d1e656dac2b6c49e62189f010c8e5f06b575b20f635bf0dc3d180b31e2e79d7194205cd8f8f4f5e87f27eb432243ec6f960dfb445baebc742f93fee52c10facb98ad519d598c01df09cef14ba09af9620d8a4b227167c8bc2e4b71f59e96256f17e996efe2e96ed97178ca609d16056d000da1341991f8d74ede9499aa1616809d78e062d76c2a5f076495971c1d5d7c4266c0f333e88d315781a745ad881a73b37ae56b132d62e588cad844bb5683df276b3bd41deb2b19ee8b85fa997cdb38f9723c134e2789d6d6429d0a20741ea42239738c6f8e7afec5d0b0eceacdec9ea6355032d36647103603efea91844f926d7742979f0a17709d336aca919201cb71569fad62ff0d5486665d4188b85e79543c2ab1ba7db399270a605bd82272c1a37224bad08767b60ffd34499c1553ef6e582243a6cccc6d09c5dfad77f2402221bd756504cd0de0ebe642992ab7201fd0ef090400e15478e0befef89bf7d3e12e34cdcedd8f571bc95e72225e96231eeabfae6bc77acae2da329bf403f15de7d73ecd6fbab05bb453f9f3cca391d4eea41b8886f02368ae0988ba5a1e17592765a75d7891a684746085e52670055d905d42255b552b47c5ed995dc1d7b64172ce2dc23b21ceb6fed5abbc43cdcce63363025fcb36de89a057de4d3fd9332cb93d94ef7df309e1e22c4d1234bd986dea103008f4cc1ab7eae3fbe7130673fcd27413b9d18c48c86d32c13585888dac5b4fd324ebed666ec70b2c975b168d5da19b71e392205a6b31e93fd9abe92488582354861aa7b08cc3e0ae21fa42f0acfc7ae78977e704f6902d5c4d181a4c42f603436e58123483a50ec4e676ca48c7ef697f0800a257d9172c0d85599160d73aeacf612ac743b068972d57b95ab987b211ebbae781967b4f2fd33a72f1a17e6ec8c693df5b02492edefb4d4cd05c10f27405364fc9e7fcffa317410f62e429f018b3dba1c3477f06e3a830d9a0da8d2cc4d89c41d4b26778900ab4f010a1613508a19f5385e75564ad201adf08d2d37daf9f64adf8e99e817c18d9a5d4696622a1f4a0df1fa9d1df397638237c7515f44bcbced4c9b15f75b971dff19c120ced4ecba8bd42db6160fdac64a92e4f6c510cc0d0dca61265d32076d6543f9d0b502f249c0aa5329caacb6a4f2290dfd1323fdb24836adfab062d64a06a83b03cea0e9d25df2f0083a5debbb771aa226598cc94f111ccac10bf7abbbaabdbc6f876dff26306a90a9410a72c10254d59a8d5a1af5a3d2a502d7256917bb5572122ced8cd9770556815f6e570b745b44cc0f509be0a2e93301b4d87eaf9fdd0aed07de4a090b0f4fd57519933e50d04b20471cc33f4ab371676f12a28ca0e7d082470349cc67dfbce4b6379df2983a44e2c69d3184226b37efe42bdf352138a2a21fa23077ba299e1ad1a363e7dfd83ae0915bced375c039b5298f5689602cd5f69ab27f7a5b0fdb298c4d5e3768351a91bb92703445cd485094e7fc9a25161a4e834d5d7ac3a05cc797ba6a547c4cff2b1c51a9ae5ee6922ca35c101cfd5ed9b85739ec67c266d59c64c4e376b3801b5e47ed3b24feddb8b74b67b49c9f004a1ad95309f3d94a7974690d1cd786d253889e68dc383fca111bfc893e8ab1fd1bf6777b2ad7490123e8436e7e1f274caa7436d3c00fb395142927ee48d5dc99693c81bbffc995ea2b8390e8aee99041836ab9f51bc3b3b008a6d5c6f1644b9815c30a053b04138f35e5b7aaf0814d2cf214fcef69de0fec1c8233d48d322faa8b403660bf22eabc27e4a708b29b6d3a766a5a8d19f4438311eb2f2ff5364f20c3c51f106e063766847aa0f4ab98b388624f759df72a9cbe35e750ed0e244e34e37cd2eeeddee8933f431f2e94284dd8d1b0b10a0e56e9009247add2b549f36fb8b4711a28d284d6e3e2994147b9554df87cbc745a9c17472f931e7a835c43b5a5f2c4fd5ad329f57033b41125d40068da1849db21231aa60c0967924225c2fe6a10045fd087c111a09788660c058090944edf55c29e7e2785a24115117caf59928b88374ec2c65d23a722e1d222677a091707a2539e42fb0242a1126e8818c208a019b970d4ad98ef02fd43503c67c6b673ef57e095a1cd0e562e0049eb199f97e0adc872ca8cd1ec4d28b0bf9ba421be744f326b20bd4c45ae40d81b55a64fa482cc6abebd7f3f3cd4b652d99fc9d66bcc588be0bd896d2cbf7f1adbbc8f491d671656bfde26299552461dc96dbcf83b7d5d61bd252be74b382f57ed60072028043bfb984ddfd51d93d464c9a4c51a399492b98f892b870549a979d01e220edfbd4dcf1bfd4cb5edd0d8ff376e1c6038b9edbe45c5e331e2148f4c727374696c3223e24e09a8e52291333faeba54156851d41bb157431b462e9acb23ab872ba02b47b10b2f77015bfcfe3f2bc76969e85ca20d19c15a26200f9f7a17a0dc1f50a2bcddbd75efae3df272eefcfab70aee3f515bab49f86a288fa72c9e057d22723a74f789c915907fbbe9a6d5dc7e76c7fff7126877d64c5025a13d70d428fdfd45c19e9453366ce0fd02302d6a3847826099936c3b0fe0b02fedd64d4e43e60190683dbe2c4973c934d8bdc463ccdd269c941838c22d30b124afbd01feaec53ea583ebcab5a30f4fdadcc856cd68f4314882de07a52e4319e0c08c89a14f1d74f10d26fad5f1c3f6d9aac6145816411e45c78820b2bf8c3cce05e34d3a76f0c257e93af1550b53e2ffc5bf047ef76acd50626b681be83e640c119b3e80b160953cde64d462a78e28f35c553a7bd4e0749294da1c0029595d80120465724095bef5dac9fed0ff77b8f5dfee329ddc0f42293a85c7d8538391e3b4da0670a26e40ca0a9a911a35bf24560df8bf01a0736d9e218ded4605ac6700a53965e241f2b9266231c898363117094472a8b5c24aba93a745a30dc792190dfa87bb2649e2148059f982501eed6f43246a8919e5d3bdb8a54b46ede05e0683c1621c70da4d2725a9002c6e3ea2da33a135a9f1ab16e8b55cd9bab838bc7fc2c5e3f342caf4970f225f47f29811ec94b01f472db1fd131c05ddba81c12f4a00a8ca45b9d2d0b6df5d7c69dec3d234cf35ebf781183d73a9ae48cdd703b582ff7020f3fd3955b811799f04f8557b9e5d0e32b547e122fe00882a44fcdb581061094157b0015e6f0dbd531890b28ebe2a961f5f6bacf0a7c405c896c7222ca6ba24c9673bf475ce51546c73ef56526ec69cfec4c8400be9665c83b8353451756d9986e17ea7e982a8768e131a379aa5b97b8ae969a05be9c8ca92ef263262537af47bf87f0cff301179799595ef456750f5c52054a3dfb75a63f25afc8a93bfeca4b9ce334beb6f4b0717d4d79ebb28f39665ed98a8caa1292d8b2332a708eac7af9b3cb624f0eaec59df49783df1083f2c4a6684f06de13b7e8c5897f7dad79440df1fb5c92ab155e9e4dc730541b8be7237b54e6ce10649ec850e1994b54603d611f01ca7f86d4927db48abd98e961afd2d5a008abf27396ec6c78e6b7ef64f260a78961b0f9266f9a1af0b10007c711050ee60d2f2e5328acbc5c5d7540e35d6b12b7067a5671ec285c04af98fab3debe2c4c97f9ec6f46a1e3588615a31c946c167c8a9bf6457698c68a7744c3a197116c58458dd1cf40fa6c7bc03de6b5d05442d6aea71918c24b4b9ac596d645af25b41f19b2c28fb9aef9fb26eceaf5463e018d6f1e75823bc8d79f937fe5b2bc2357c57ed740e98bcf463471f9eff427f5983e8cd6c7ce42ecaa392224245dce3eeb3a49ddb9d6bc37f9c2e0e2c80ecbdc06e65e4e6ffcd6ae667697baebc108fe524589075bb7516cbcbe50c4cb9c48b58929fc8e5dcd199e0dce9fe11ec42ad27b02c3469cd59ce75d2c2300616551f368c6008bcfafd805593b513e1834658cca1d64a175df2e005200f1a3ae8ad6d35904906dbb71be76332bdea8c6ab0927483f4da3bb029f116826f892ae5e027eb178d378a45d6e71e2bd78c921beb6718b15706079164f49319a83fc6675e08bf62b4268341abfd16a90ae72e594c605bf3af11fb7229888936a0eea2baa595c5a76f5fe5a0d3373c2c651c67c2973a96fd9b08da62b59ef95562fafbc485eb9d9235d2df889a05d1b1be6de7d8bedd464e0a807e3b3f9a0fd2216e0ca2d5ef8c3aa9b8a7275967db3edb56a8987c1fd5bad83ec4281737d39f49612a14d96adf623ab486d4717e15a8cb08d987ac57691467701c9074081dcace5df9c6285618d8d3aff5a6634aea5af245fd83e5a889439c873bd36e19e410b692e6580548e6046204dac11833d54f803575daf6488c9b8769e9b4d10add6f8fc0192f3e4bbc40a5fb7cac376c975e59e0a92d6a843d0f8b1b8bc8eec3258d561e2b5ebe7903abca0ec30e455b515eda9225ea8d67865f1dfd524707fa1e34b420ead241340b94a90cb4866f67962085b69914ba95b400ba8be7888468699888323d7ce9a95f0e03fa863597a5c3fb258756b30b5e6bb4f29c2c2f692d5222e7773f215ca5f1358ac999a5a393b64758321c51811845eafc85c85fcc20baaef07538ed40651c3069cb37215a52b5de3fbcd586730dfa62f37200c757e8a0a1ec0ae39f3dac9813bef97ce7ba61c09d271bb1cb15dd7adb291403403a4f0c700b9df2f41f71e8dd509c7fbb595cf1f07624dfab2eccc54f10513a9a4a7dabbd415c2db9a5326bfe88a164f81bbda7881e568fa57b6068243c7a056f797f452a65636707ad2c1178e6963001a6b4ae86d6db8b588d61c6e56ba92e6d15373e91a05a50eb524bf54851f18fd436756dba6cfe9dd321115a8acc79fe179f762f3798d2077155c882588a1d620d3af2bc80ef8d9ba7bfaf8b8bd5ade6ef6390954c21d2c81c3657f0c07912bdf2f390ca4d208693f02b839eb65a62d57effef91dc2eb7ec6491fa30129c6d0669b9ea969797b095de12c5bd9d896c400989e4478842ed3fff6c592b177c5cf8caf3058588e94a20cce919865760bd60d323494f0c29d75e2de03115eed78a299aa8fbf550f7a63696c3e928a0f1f22b05c839fcef6fc84c0172b152f5377ecf8b6fe9801e6d9d7928826d472f4833851a1dbb0b911e25c074a9dae9cdc2b3d8736e73821e8e9057f7f3517613fe6d5baeede08f1a5998d21ecf5c29d216b3155b20e79119b3acf16fb0719b35699215efe5e142ee9b71c9ae2fbc2dd8d9be7adf5e562822b66dfb215abb94d23f899569b1821ac78e11a394172bbea7b24bf9b2de1c271c73373f5314e0863f930048571111c5bb98d528e1e109311a9488eca69aec9ff02ab7275b60914eff4d7b88577f59924fe28960f54bfa5e78cff4fa1af3bbf9d948ee1e26a4f660e636784eac04cf1389ace8d22dc7ec868af56faf39a622cb7f607b28ff012016b5c95e47994abe66b20a97a6818a49b28863b65115b4d9eeaffee8f8e991b0e4270c8ef870992f39b6115059a3a96767af66483f869d752f3efc580a7343617e853bea042c5acbf6eb9aec0c425aa5e72ccc44cdd961a23e272c24507f0f06c34a2e857208b3237cb3841da803beceae820aaa3eb73e96ff6d699c6a07d73dda40bdec7e17a0ba38699345bb81b173d2497f0ff3b0e64a00d64ab3aed93f9e98791235511c6635073bf7b65896ce3cabe4fa88c5707a5e92e249c509c6483d81dcbf6ac0d31e6333461b9b373a4a51172bf811c182db384aa5dd16c5cb434463a251b85f5ffe25b8607befbaa6bc5d3caa8f47a9a83f19858e87190c32749416ec458497b73b2dc01d7706db697f351eedd935fdf85989c1419feea1c407ae93d00562b75346a34a2bb219d4b7395c99c8f7a9a69ddad58b8064d553817690b4887efbb3c600da0d74f699ef8903e983868ac250dd601f20c96f5d6ea596207cf7ff898b306a16a28ba7fb12ff48ba4d184318d795316fb8950cae058e0c0f70840a93d54713712acc18d2de605d220db10e1f02b6018db125b2c824c5ef9c5d822a98223f2bc26ef1c61daa68f4a2354821bf4a35e566c82fae494cd9ddfa90941696ff46725c046eec0d55db5758d2d3183ab10f855893d461e44133fd74f002971252a9fcbffe711c5e1e092ef40bb37be550da14c96cf0f382f3c647b051e78ed52995332883536d3989e3286a0ff2eb0bb5e061bd76c39fe48ae45df3dee80d688eff8912beebd0486b8bcee95bfb594f1f73ccc20bc1ae06fdc1523fa6e58b7edad84339b2ba8f378bafd6dc7c780d2990457a227768b438e3b8fd2b2af78fe567a5d45f1e2e749f95f3fb8d302747523ece0d061372684443a8ded70995beb384449682e3997bef694108c3693f53e59faf797216ea9055dec9dcc50ebd363d60418b851c71ad813d5c93820f6d643f701c963865cd4deccde5d14b4bf5f9269245efccd91b3dd54bedcde6587136a793dfe0f61300414da0eb050ef3deaa56ffe53dcc78f5ec9a654eb5c5103728258bba21dbc4fd9bd9386406c9b23c97a74434ccc9f67a53b9902ba7d45e1cad09ee20514c1c351b4afa13b2406804a6fbb1a4e7da582ef62f73cba1f98210579b16b91d325ccea0f971657439281f3a335a74931762f8ec4548fdff38e86f67350cf9c409dd73ac41df21df84d3e4a5b4c79d838589206a9e4055a4604e86d9fab9f270e5e3ae7fa1d00db4d28828a40c91d980ddd7e5ef29730496b6a5e97c059517d5aced760e980121195bb111666ed937f2052806ef41fbccbd8b7eff4a3ee18256800924638331a7a53989dd39210a5f89cf8e5bbd134947c144b7129fbec394e66afe9326f2dab4adbad64b4dc7c3488e656a57d02c10f7c3598254f8151d7acccdc4cb89a43f5b29adb42b175f7b403db4510f444d221f1f652fb96dcabd3f9a73876756d712badfe3c92aac9df424678933c1e0f9817495d84594ad079def4f12f95eb6ad31e374bcd547adfd5040cb6d556731a5007a39c909ed053017cc9033d0a0e1069c442b2a1af7de3773a8990eb10387b9b98b4e7159e096bb688afc13920a0fccf3a33d73f8484a261252ba0726b4adab3075196e7660cd093869153d7cced407005b330b250bc3f0bee2483e224bc3118e3931a82437e49edeb49e265956e9287cd404a2aebb501c639fcc9668c96d8f4eb06355ef4e6f580b17ee305dbaf7e393387b87c9c850d382d4345106b7451fb27dbc7bca142830b440fcb7eb1a09fb8a8d58f53822d050596397eab74865275d2a7a828e8ca6f0692b12647d5946354d5280573cf2482375a4d3a6d8af2a66497a7f0a30def2aa85776b5fc4d7ec2fa85e596c7f74803b074a32e60825028bf88b2c7ccc8bb74c6de904701232f721ec9dbe76fcd8d9c21cf96f7435857eb519aba8fef27d30fa94448367f0b3f625e3be9f7fe30463a5bb21006dc83e5166f6b09f4f93445bfd8d52cefe8f33ae49a253ce3c0cc0268dee81e64c5b2cc21c0c9b5d970a280d92e74ffabb077aa4aac2283d885a242bdd99e17f855b37e6c2db4b3951e4d4afc7273887d8a843d714046554c5f235cd81367fe4fc7aabf73907f673242ee1dd941330b69e044beed7d9799df78412dff4f420013045500c6480773ae17d0fc2ec72d255962f05ea712d804a80bfac8297b727cb12438c405b8c613f748a283983e99980a372cb97ec379f87435d13477a65fe32182dbbb7ec936e63bee2ceebd1c13b4e19be8cf6cd2f25d687f076ead1341fbefb0a941bbf36e092e36ffbed81177b66cabaf8eca59e0926b2c0b7a766c064cbe4d1dbca34cef1a36ac2281ffd055d487ae3e948f269962c2f23f27d211746727ef73c2bd3408fca1004dfd3d1fc0dc0bce164b684250befbba4c01d2a53a188da9d54b9077d1e107068ac5b5f67c90cac4a1dbc4a1060d744ad8f26f0d7d2e14c91966c758c7cd6e545f13d7b643a8affd72385e2fbd52dfde18cb8a5f951e984c862da41df26b5a89d87f27574c6450245e5d6bfa598d7ce22edac23845f7a96d232d54dd543eb8581a79f86d23b599bf6b3874dedc9bba4e3dd8207dbb6c7a6c6c652b423afa6a99b3bf485e112129f60f2a1cb6e25530b51440d930f2bdea9f4ffc8c3c6689b38491b2f97b35254e87620fef50fd0d158cbb5ceb74cc9cc59700b2fd6cafc2deee75e3515e72c0884f7d6c8109dfe46d4d8f390ffc962b86f0e01d3afef2c5a2cea26fba73521b85f09fa887396082f843de0557e5a5dcf8b8be9a1320222541bdf4e7bd8dc6b315a408eb15374ba29e7d9a16caddb30ea84d5a6e36e69b2cb7e76575a6e44ae389b8018ba143a6fd8c44d37c400fed056ebbb4a7bee2e927af317de5f04c10b243f087f4cd8c50730783b46eb03deff3bc244a853ee2bed4f0c2731b9376318dbdf4733f44af35bd27f9ed07ef275acd155c499e32d4300a9912f5654a24119776f5b6d458dd9d89ed16cc01f2eea6ec059af56ea921ba35c3ce37853ad279c37295f222c4325b572226444e28670b6819c25c6ffedd19f4f01164a576b0abd8fb105d21b7117259c2823cbad04662106ce1bdbe0d1fcc76156fc35bb6492437f4eac4d105fd7e1384ba6c0b5936043b6b7f640224b7c7e0366aa6c03377fa323124cec429c32ab526fe0fea939e0d317ba442e10614c34ab408c66b2a98d5ab8cce4184e3c99baf3ce97a568e85d36f41e9f6c60dcc9096a07d2a33c663a774e4e22f6fad008aa2ab3297438a989f5f529e6a34f8a700ffc7c1b0cfd42bd0c53b59159abb792aaed7f00f2af1883075fcfc3154a94f9aed93bca75ae58ce3f15e476281f288ee23ba7769a887a4948a3c83832d2574ef330d624008bf2a613212d29c6178cd9de70d9c375e5eb10a66dd2aa5e3af64f78a3f8acfd85bb47adcc72937b9c8b9d74edfc3a65576154c971fb0442c5ec14b9a6ca5e7931d3589101722ea4696494989c3885d1297069a50bfbb5cf8b3395500ee200bfe137ecab866995b4d768581a39da9987ccee7f67f7bd7af43a519ddc76bb201db259e39f06fe95f0d1fc89d6017cf197e371ab54a4f88f0f7bccea89b943b4163c6574300fa2936148cd91750a74a8f867d08fe75effb26e7a2be446abc8fb57de9089e381a99ed52671f951a68929de8e51fe943f84cc699edca0c71588d758c825d0c2b1285cd7ea57c6c3ce3e4f00541dbd8a64b6b22257042aaca85c46a8dfb40f0be2b2790b5545b0cad2704670972c28e3faa3c197622ea99ff0878f4b12268f2d703887333176d63d21c2ef8af3bf5c4e73262eec8897665cbf2e12ea90cfda26e335f396fb8a448aab8cfd8003584135c7ef43d1fff68b7f85a43905d927074310685165ffd7bab062062c06192d7fe6c04d19bbd9bd91b53b54f2ff0118988efcdb93638dcae629450a42e858ea0fe065116e9a2dc5f2131a0ce0614da3f1c102df771ba5eff84f4ee317bf3a35557920d60e8cd9113cc07a28c6c6733bc78caacb1dc5c29bd7f92fbf3e01dee847385db9e6451736eb6785da568711f987760b605824b4855bae58b5ad9d95c91cc672cf4258d4114b5aeb1bf6a88828964067f64420f58c675f69f4327dd09a0edf30b2e7268bcdd3f1cdb31a39ce2eb5b0e55823ae66abd7dd0a19ed753c3a01af05b3d5f15c73139d40635137ac16734838ea8214c52be33a78f29e7a26f4224c0708a93ea55fba6d469b8e5863f4ce80228e99f305993f709e9ba3e6d0efc4ab6fb8ebac91de54c83d0ce66f7099fda093c925c152c81d52fa53c3cbfabd988ea5b4607c150906a8a6e0bbb4f9e6255b6a29d12428c939a1ff3c25a305c834bdd9ca7bc03156627d3d8a36e9daeae44038a0c6ecd5ce1701feaf5596d609cf7edb125041860b3deb661385344992f2f83ad48c608935e63f597bd3e139c5d7e643517ddf64c42168e2bd1372bc5a77481343e700acf66874b8be3da7fd46c5bc6e964a11d681913645e986de1aa55bce7c33617e645c1e2513494d4a875f1b27ec1d56210e9d9df5b7e4010b7fae304a3d53bab1c5d43c4b64f7ad7027c64f5d9edcb809a1fc106f549af1115e45e5810b607cefb53bfbbf6bc6bc5cb04c52cee8981ea4857f7bfadaabc40280051b51b56704e5ce4c71ac851d3dcdef10da63d0de72395bee9a870b90c4d06335bae36f4c4709647a75d501474e9fc34423b223a8edb832fbe60a4c0fb50b9f39376ec3a888b50548e18b56903845b2fa13ee116f2143defb86a982f7c9b449aa6008d69adcbef8642f9d47a08b60153e5004ab1099b816da6eb5d9a82b4af2a286d8d3a48a1fd455a9d2dba27ca17057ad9e9bff31ec778b2bb42539a3709083bd6a8f8fbc42dc3233e5931fdedd8677a1d24290f2572b4d85596d99a0a57cc29808494dd1e431bbad2f20c59c4be05c201d7966d761edb1f38dcedf906954f9b6d17ca7c068361916e8899f6763f7dc4129c6b3bfaf7acaf6beb2f67d2704b2f0fea353ce021234a966aaa49f4cd5e9d1ffa651f273dd493f158f3441b677554c933a2470366ac970e0ac17721552032f34552408ba9181ce19c157be6b149c50a3a49623970c62c54eac952855508f7b6fbb7bf0b0f41d89c3dc6996f254c803ea133cf0e3757cbda51e27923c183eef5c3e78a0bb0ddd901ff423322264a1e960943cff490d63a6433258fb7dae7680c77ddfc2a0a0d454638fe59b4fc2d0ccf55975184d3061a5ab49d9e0390f77c2583918275a473e7ef0c5e0ffc376d5e0fef3bed50c6cffbfe455cfff315f230407a0b862539f3fe49d872f1bba30dfaaf524764200e57b5411724d967152bb7c623d9c4c9cbce68030930516d7be3b56b7926e5020edbd0ae3d774e08b9bb2c00da0390c58db95a60cce06ad7173c104c4ed80d968ea41ae269d269ecc54e5b891cecf502ce2c7fe941499a2d157399d9e8c5bc9229ef130af5c00dd0cd75eefeabd9229fca7d8384f44bee2f68aa11dca4e9052f4d06385b331c19146d835b32779142fd890dcffbd8e196627e661f9ecd527e640d651c8480f8fd5c42c41ddea4ee2c070562fe4a80cce2f2a7202a3c468144059ec76cba548ff4d41e181b6f6fded03187dcfe749ed3a4f6224abe189c5733e40a914cd4f31c0f11dae7cd34f498e888f8583a55a4bd4c2a0e54c8fe4876a1b23d8c1ce09791270c45960e3995ca888fcfec9032f315db7efba8bfb376bc49375357562c3494983fa495691e72f0af9a32e0d60de82299f3e63b0726b44e1cd1626bfbf7717af12f35e9818f1ae1fec9886abbb4dcb909bbb6468eb0d0249afead582b3452e222c4f027bcfdc89434ab53a8e5bdea25cff32adf25d27068473bd7a2eae0d9191a4a6538db16c150172359380c980bac16852eecedc3ea8e1258791344d2ea684b82f01b24a07dfe9842fa88436dc3939e6aa5f3d105c05f8f5c87d0670a21113ec2f06eaeb3494176faa843dd47afd5c11fdce2904d1881d9f52862470ce288dc0c10f0a12831aeb35ecab19adb13a9164407c841d8c303e19d4680c267c5c361ead118a54018de1444f2a14323fda11e3af77c20b1fee3e98ceacab9542d6494150b81c84c50e3f00ae8771cadab1e7190458fb795cb6c639eda1c1ada6e3cf023bd84e25350faa4f0da0001b9680d6073578d92d54972c3acab2fca744fbb5b336b7134005349127edfb6b6ec6aa090169444ef8c273492a0e1ee360f096ece526b6e62ff28615376131eb003efb2a57835a142467d6caf9976b406c8b676d89d801209404bb4e0c9d0cecd4dc1d0b139a59551adf2e82a525f7ed4d5ac5ffc73c3933d176ac11c3d2ee16b9a4486aa1ceaa5047bf1becbf563dac37ab26700b3160b223e29510b6482cb55ecacae4af14fb93fac51d1468c4a241d6102a34e7cd614323b7b668ce201ec7493db4df35196ac4f34435d90ec66fb86586c29211b2672b19202805cd14c3c45648810543132b2ed24bd60c6c349ca631fa13e059f69b56d60c509d4eb23b863dd142851d7281e6708cbc9f9c575a8a3782240670ce968a93e72781646ab3a8b979679c29768373af8c5bbf3e5c40b4f2b42728ee087c6e23d8a5efd612c51e0480a37f804264c2e63624f992d961dc2df1521065222944c9f7e9646f3ce105d09ee478a3f385efcf1cafb7372b9f4b0c1711406916755f6a634fce91651e61f7280ab5c388ae99c55b16d2548b71870cb6c7978e4efd5fd337cb8a2819e2ef96c25fe1c43c74f929e7f47187605f9a9c232a95fc19cfd93ff05b04747c41f2b4b1ca91ec8370139c917ee6693735446a3c312bda3b985913e408c1155e9f2abc92c8bb8bdda764bf810d188f92bcb84fdda440e8906b2ff0bebab5adea8f98d7c80ee2a4bf49bf8185d0195c09480c76b556de325922878a03eb3e0468ebf75f156db90138625ff38d396db5b4eaf3718dd94f4c074fc832c8db5b685c0b19fc0242c437079107d71a8229c692b283a89e38e70d38a251bc7e725883f7bc765c74c6cda6888f97b8df3b35f838ee8edbb995cdb094db9215bf39cb25c56b0e830ed1ce98dd346dcdc6e70489ea68b97fb3c6e533916447cbe3915883d42d69205cdbc7e90c71de9b0e3acddd73e3ee5b238dfda42c85e0619945534e829b04c43268235d7ce2388ffe79f4fa737ef86d0ac2b806b111014e98c873fb8103e589fa697917c34630651cac5fd307e4b6a832601871317126a580314a85fe4038265fdb58fb1b0ba093a8ea3bad92361fd831cf49f48480200147d5369c3e875482ae8e72e345b0daeda570f87b76a8285ad3b402dbaadcd23e88db84ff596a3f989979469c1dd0ff0238ed842bb9511197aa26826119e8179ae0500f2cef99d365d654188d1b6b637d4ec6a2d8e40cd280e2cc32f0b6a0c16165cae2be6852966cbd2d49b5e919bd6ba4098abb67783d80a910d0671c1e5ec41ba96737abc8a792eb010f52168986a3c9b77ed06a80bf2d340bcf8ce4fe93acd296ed9caf69b6d6c5a2af06b469cd5b179356023774ae5956424d4aec803493fb4b97224a36fc42023da25365c55f3b3e3c94a8dbe073f3cfa138ac90147a05a4ce609f753253bb94d914a04f6ca1239d09aa0c092b5b5fefe14e5fb7c7ca8c44bb32ffad8f86c8da3188c4d6d0ef20b1ee9c23d0ebe4ba15b1277728e702d232caf5c975ea7a502bcba77cd212945ed5d9466ede26d6eb57b6ee2193c451ae99872450e5a59efcb259c2f9469d696555d8bf7faf14985917f199e86c952a39a9265e8425c4dc2f1e15f4f5d2609b14a8b8d85d57591be90be508bcca7e49184a73da653b732a689d8ab4f1bd97d114087b4497389bccdff7338891aabe7ceab5f7c313b95e19fd410cff9da97e116dc28067ee6329f2fa73187556d9c9f2761a11657a0796622a6d6b1f43442f375c4f5e244fa2d660ced394458b311419b98925d3f4bddbfcc54f045e25d265e120f204c7a2f34af50c70dcbe79f0a8bcbdd9a57b8fa6d0efa0c78ae8ad1ed964148f16ddcf64dd688e1fa978062a10c00e6721c854b97b1e0ccc89108d136396c27df8c50ecce77bdb6f09dbb71b4437e0425895aeb66b27c9b769e8e7685d99c0d373205605e3a60da6b7f77daf20e37e94cd4576a4b5d4ebfd8a1a7301c12c1902d4550bbf73f9d1de8d914edd5d9b5fa90d65f665ab83f169b5634650156f409f0e0d69a97f6bbc774e86cb824baaaad088ff6359489a4e0d651a2e4e26c35e4fbe1420b36ff0ccb4977b0a351bd6ef600eced03c137365b7eb40bc4794ec794f681f03bcf8f4b94b32ffb77b8456cd201bf05c79f94df0efad0c0eff5f6f98981b0ba83d6f7fd28f0b00c90770d25eedb3268a74bc7691d50fa709241d820174eb1827132a12e21a111e7d5307a2f5829a3ed712f8990538d883a2feb5d98e101c23ae1fec74dee099b40eb22f346f404c6441af42e58db43e5b16c09f49070f6ba719ba9b0b416452a514418ed57385710ac9e46f19c88c359f0f652b217dd4a32239b7149591df0569d5583824e5e49d8932151293b6c17a12bdf4197addcc0a0085d50295d93dc76e1914f97f49ee33acc10db1b7f1bb59af1a3ab8cb757609a6f749d59cac2e3bca3578376e49ba49c5f79959525cd39ccdd08fa9408704091bcd834f8489b6a12cec8df75b4d4fd3237b36969d079c7ae0d2dd03b36235e611abfbee34a13a6ee36c96e534ba73e20eb4c274510dcbfd3d7d7cfff2118a1748a5677b27e040ca4d6d3064e446c3ebf33eea608da9ecbb219f35d126e7c22ab1d8a18c941b97d0d6b7d5aaacae4c4db825751d0a9bdaf1b6c31f2c9ddc8f3ba811aa9e64029c1bbaad8d09cb1bbcedc39e3ddd69bdf9a0093860f9a34b930248cfd14ddb67b30eb6937b6eb6811c5fa84a850777450477b0625033e47846c1c164662774de82bb95d5803f60eac226255554c6753c7f0ccba15c4ffd29516a033718035a96b6f52b1a4dd700fead729343f7473f18ee44ed6e6dfb81e12b81b2f1fb2bb575d5f2b9dd92d0c1ee50e231292dca04a7dc27479605cf624d242038d59f9c081da8bec7f971cba2d2fb9fc88c5b8baeb939733dc0c2da1b85d252b8970c86186507d50a8fd8da54f56a34a9843d5f42c18940c42b5407edfe44062b9d897b6e888376ff0231c83df090fd39c8765506defcb7f9b676daba8c0fa8d6629a05f8c3e332ab6536c4ba4ec867bb51ba7f6862828ce46ab42a4c4eaf90042abf8c7231dbbe64d1ec8dd12d8307e7fe8854b7623045f308ded1f283b23014b679ebea2a17f1e0e2cc41b1fd82a4e210fe5fd43e434a448e7a4e28f0beaaad63d82e798b9c4f274eb988dbbababee14fae3dd656e09bfa6dd5941b48da4771c7077509ebcaa444d7a769f65d3001337ac342f0e93e19164baf2c93601dd3bd7a9ffba9cf3c27b5bd1ed9bbd677d983b1a7a26e07101e7ba6327aad4fb8e3808f6085d363300fbe7b180b1716410056cf270a283f10ec1c4db9f5b80f07da8ee37f082e10d7e58252acb188aebe4b6c5b7a1801e266fafe44343e98dd6c0a6a694e36cc17bfcbdd72bf989a308366b34e6d14a96b73fa6c2196bd654df78e0c0976872e966cf4696945cbdbf94dcdd825be8985716afd1e75f7c7379cbe625cb78cc7ca6c1850ac81d0f37e1b2f05a94e0a1f902174190e420684ed16cb07fbbc6c3a588ab49ff8d58f04dd0ed8c1d54158658098d70ef22740db687e66c41d083d1c3c25164b6c84d99847cd1cc76fa80b4553f3cb901022057a1750476b76b2b58705cdf993c05ce9ef38a4c264badc171ed9971239c77497910bab0ffac7f8ea059eba7032d922aa516514de0ae70fe5844b190400dcae6cf8942631b56599daea2004993ac3c059af821cb9dc1d998a92f6ccf03734b36b96b780824afea308157ce01aa08e5096d9a2384644f120f0805076cbd862a7a59ba0ea7579f9bc097c2ffd038dac89cdc7c84e9027312f4528e7249c069059509ee8f2b347da80baadb1a30f2e6bd9cffc80384b3943e6e0e27ad42f22195a6892a5c7d017eabed7d160f8a15c8735258434d761db3c0897e9685589a1d6e1cb465dabbf12b4fc45ad9666a6de456d0966f2eb657b23fa61ccc24cad70930d6692ac0f1885a5bd71c0825512eca275a1f3edf2b2857f302f6256aaffe8e62747fd4a0de4159a490c221308d9ddfc7aea50d35e7e001336cc25d148520d9d1034c1a8d3b27ab47a15dc9dfe5a696e193492823c426103dde983ff473c48df0437c9fac0cec38099324ea62ba08c155004dd6343769ae017284b4c38bea423e32353a30ec51468c6a7b8fb12143416acaa9b1b30a8ef3e3bf957236297ce507f3a88aecf9b6c5eb969c7d6d0fa8dcea3f30137c2cb129a8f6890fc5d1ddb175537fa50d4b319a4a709f65773f30a49116c16df1024e8106d4498bccb2766c8646ad26136de433a701c36dd655d99197019f1a09c80c118b5b624b112dfbbb63493909b416229615b2eb709561b56e5c54d3d093b33f2f5dcca513df60fde3e2f95e41ccba6c32e9c3526eb68d3e62af076c62b58b4b065101514e615d4ecba709ebeeb5eca284b4c7d359db42728f4ba469cdef8045fa09a9a122ea40ff33c706b568663fbdf73223ed1e1176791e36626d1d7aa96792570babee836e7c888da7ee86b6251717f41657bc685032f7b20d1f40ec3477a3ace44c9154ef5e154910f4545ec2152d040459da85c5ff3bbbe621116d74efa32d95ba263de0fb1ae6d8c2e0c80a459790ccf54776f3580ad837ebe564eacb3d876ac052639b8795623cc8653806d9f859470084793521e334f97d0d10dbd11305bb24335662e04f7e9758c5c561d508461a69f1894c055edc07197368480242c14b2a70f4837683b6986104c622bfb1182753efb58febcaae4abb63c5a4b7785926f12397243ed84917f974a9328f053fdd5f94d33a8ed524e936f3cdcd1fe505c28894428121e2a8cf1bac75d9783dfea8971d280e7fa8a03a58ea290016438a7c606055fab236f1303292c5c02bd6aa63c02d6db75787de7e817ada1a566b432a49beef27899f6c52c013f0f54e3873b9700c7a950d35721b66f88422033c737c9194a66b27fcb1d7960db32c0db7f4f95856c0e19d781a592f97f0c69eab1d64ec21e40bca6689a148d7c1aaca918c9d0ea8f67510dacd18ea8f578af3961d4ae401b632489a135ffee35c5cd813502fa5b37b603632cee147f6b6a9a3964ed5c343f74f4607e5abfb1c3f9f16797cc28a0293885765f58e71a81a0849b64157cc94f68a0c8f00b5396aeb290d1733f401f4cd82f15745643e36d2431f6b04a786cae79cba65416b7387ccca1b20fa1951a3cd0a5572b5b901bfca57fcb2be5519458146894f3dfe61886ba31f65f7f98a60ff416fcb3774e951b37cc8b6aab01faf8d5bd8a6cfd4436caabc782fcf260e553c28015f554f0d5b74955059665f65ad6f8690afebb3015ed46bf1a67f7533a90e2781e5bb396727b3197e60a18abbad402929e540cb19bf2a95e6811650b3744b9416623b294b629ec89f7da7524936a8b9d440522582b6f1170b87c926d2dab59fe9d978dbe4e01cd20ab161c10ca23877daebc80cb20ae5d4c2ee793178c613de14fd5b80ec041779bfed3d19b1c90150af88d7af941e51bbf69093fdbaba051d5234a1249331a6a0822c463e0dbed57497dd7db3f372e41df4e2cbb3de26f549a435365c858cf82ec91de2ec8950fa97bbac48c78d6eee40cf4c572c1c7534b9c5bca6f3fe922fefccb09f19f780058351f6d7073a13ef29685f725cfe8600ce21f8e29a7b02daa32a767e128e307aa4f6557575901c25053784dab09cbf378ca8bb074fc59bf49f8094929bb037b33bc4d68210d5499808bc30290abfd304942cdf6453c9f616ef305f8f3ca4808ad166c228cfc043956afc776a6b1d0a6c791e240c84c3c3f0d6b0598ee68feae7ff3e04d3bb3eaa5d3bbe8dba49413b95aaa9ca01571224afd7490cf3529875f55d4a9528287b21df6798c2b5ac913e011ada025f26aadd5739c3d7ab577e3ad08a9a6722f0f93ce1a8d571669db97bac928ca111617a033f0fb9da91dc8a670fb09c8374cb395cd79d68e1bfec9145fbd1d2249f593e12ee79a1d7d4479b979bfe7d756507fddd7362d1ff91c9e305c198346a4eefa5a3295ec231825eb46cc04470bf8693518f4cee5f19472e24ba9f859b612079719a8598bbe1eb4c40e1f5c2f617103f659dba847171bed7e66eaa748b2b004efe39d54eeef4b674960e6c2468e60f2ec538e7a1e6833110112d6fb2cea0c0b14497592ba58ba348dfba424f071c94b32c3ba750245d7387adf3358b8a562c7aba14f3037659b0e14988fd30388bf09f051621ad342c5727d6e6d884ea7132f480bd60e23394d7fbceb250f63f5826da765c7aef88d2045124984a625175675cb0d24f1b325f955077de3a5cdb1ac2a710003af48d4938d66c8eee1433ddf0799af2f604946648f3455fddd0e8bbd777ce9c881607412621652a1685c227851294893e4eaf1aa5cc6f730742ae396df012b655828985653c9810f97df883d02a3bef651700625793f024449c12c9f977f197f6c287fd708f5f549216c65cec0a84c7ecf14f57359e27bfcfbcdd596c6b71f1aef91447b1a82336e49c0b00be013fd2a2b01fa969fc9a1a865ef57f68a2cba17f42f12f77ce9a1d1c66968d652b0aa53dc6fc256fc0e82de2d3813b03c9a0749c1c704d307c0d1b9341274ba45121a9473ce2867ba71941bfc8aa9fafbedb182a655022d41a57b843fc68b868fbfd7160b7263d9273d2eeb006504957f006194a7dfdaac80195a11aaf7e223f158d1cd48320949fd2ff1d25d52bf2b4f4f66045b19a3668df7991afae8c8a7521036aef725a2b4d4a0b456a99c530af845ea097d7ec20e0129468807a56e5e1a07e0cef00bc61809846121360c3e8aa8e0d0b8157e94717b1fd28da966e2e8cc6e2232a891328af253129f4b8ccbbdd4f05683a4b9eae1986f9afe772cf1d83f26aa114d3da95e98e0573232d9c8ed6178dc0ace2742a3893a3d963fc31dd3642654ef01407cfac8d00dcd63509dd3bc8cf406a422e066b6b07438bb23f2a7965c6ad562a7513b4abad62e2f420c0b2e127d8b1fbe87bc3265b70fef34b2173230beae2dd7ac4db611c065ba8ded7406c1fcfd98b869ee184262e658a01c798e904ace8e0578553e6ac8c2a004ee74fd5aae77489da7d0880fe00fb5b8480291935f78f7f449fcac9ab0586d7d3d21370529b136214d0256f157574a9ca69f1d1d196e6abdd5ee44e8282df7ff3d1118a08e7a811a2a04bb3388f4444f757305f550deb7c58fe0de8cc27206d314ce892e4945feca3b6403e5cecc8f7b93a084d6df02fe706322bc9ec2f8eee1ded03e7de996795afb539fcd4a0db69730b28eee1308176fec519b58906f25173618fc25c5592863d587a7b60747be2bd28bb627d5340ae7d2ec7a1a6f97b4ed78470edb885f51d550371ffa10b891cc6ace687e65714eafd4443c683ad662dba9dff3839c11adf2a5b17d2a82c9b1c547461ca7bfc10020fbeb623b41040eb1115a61a9240baa4568cb74b2152828247f0e509d38372b7b9b37c4d8d7b12dd8bd5d3a023e6a9c12e3fb49eb7f54fdca3959251ab2f09bec3ad7e7eed7b095935ba8d9891389547e196eaa24f10bb98c829f17b69471e1f01c1b6af5ed7329b10258d3ba70ea4271ca5919e2d6732a470597a318a40a679b3c1ced2161fa0de26cbc8dbd6d7b7f8f262fae4b72262d2f98514238230080d7366f3616d72c6de770ed01b87a42e3c54a7ddffaa26dc1b1116ed7237abde211504a49b0a31dcc490da09e0d2078d7474e0fac7d4475463bce4d63c66e94be3c68622591749e8c260a5b7e2e9d2789993f17e4f4b58400c89eef1110c51afa4f28577fd0ee1de00b3e90516053a86037723f294cbe542814d5fb0184f858192f81601feee6fc9b059557a0b029c624126415c5c03261d158b5bec9d56aa99f67aac61127cfc2e327ac67e68aec7b384d335630b43b8d5c3f02f4c36ebcdf795d146e7c1da5654f91aea419e9899160b690ad234f7082fc7d09c1f7a2b1e4c4a6b48b09e241fc370a803d1f372560e5884e76b77797544b39198a03424cd4a8b5e089d8306c3a0602f25f464528e2a70d18b59f9a4ced8aa8fabf1d85e26de795950c7337f7711dcc5736fe92e20049edd6fa3f4842f0ee58efebdbae455b4393d95a34d30e4271d8680a1d28b23fec3aa4a2894a3e22dc101ff938fc34e3e1484f5c462bfd4074eb275636c02d6f15ae8a06a2167f21152e9d8d31ffaede3f9d11b89099dd2497074cdf66de3a878c631fe7f9c7676a10289b245bb26e7b78f36ddfb41ce76c57f9f79f0a9183a3f36bdaa97f5d12f6377e73c01507fffa29a96599de03a49fe9e0480fad475ee346dde580157e42966dbb927fbd619f8c547416175301ddd0e3d55e306230f147e9dc6f662328e1699dbc37b6d37799d336330010d956ce8f226f11dcd10f024fb614cacfcefca14a99ce0f72f8ec2442767841dac7dfde946e893760c36c25dccd9ed4c851c54bc3278759081609b4fc122ac2bfd45eacee5a827e6183176db4b06742fe4bbe76570300d23b74c100d7ab7984be00e1994b00dff6862c075c3357ba5c61db2349269fecc10dda67b25205637ad88705466428a1d3a1f64ff8f0512fd4fde806acd922680260ec95560ce51abf2cb9f597dcc5f25c2226359acfccf72e8fec20e85d90230f5abfc7b3863902e91a07ff02d66d5922209236c0758e1244424d08a307bb822afbf1689edb4cb58a2d6f4013521d8e33efc9f532b9066a05b641c050c40a6dea6a92e036f62f3d89048438d8f73fcc3c979e18edcaf61fabd002e4008ca724a8f94bbcbd34e5590fdecbe7546edfe1888ca02a6fe94257f553b542e07249e1333d308a1b315e68c5c18b23d154a80cd5855310fbc1ba860e529dcac1c3344912c46b3d4e4c9e952dd76a8918efa4fd4a7794893d09aec1aaaac2dfb2f04737f22f2ccb7a4f837eba607dfb49efc75d05ae2ca6a27e757a8b9fdbb3494880f2c0aee425bd843acd6b2a60e94bd4ac69035b745b838be8944a96dd19d8cb69046781badaac2bc306256e8d9d5c050b624417e27efd96f4b4eee9c8a3f1abd9dbae80705cedce5cc1be44eb2b2bfa8852c39e392e40fc770c586d8bde4d8f7bae65a7e42f107e5f605706a28debe75f7618239292545390e15ae2a35b61d415d3238a9ed8f8f75a4c2d5df4ab556a7fe630e52a2f405d7a9001cca3cbe782bf9e7a40b565bd5940cc7e95e0412956ff937fb0dbb7638fe4db66f2dfdddf301b8cdd64df448d670ad45588a16c38b2e4ad9242da9f43228172e8920f52364dca72fab6355bc44c2079d0c8170a3f505bb4559ce7eccb12df15191cb7e62e12b4d81df13be502dd926651ed968ff3c04a9207828b5f047107dd0ddda850e1160d7f21421d1d822c9d005fa9db9f8a16e8ddff768a36d92777cf98f68e1920b8dd91323eefc9e2a8312df1d0224251b7a1d581e5d683383263b7e67a474e6c289cba5f179d14dee97dd4e60c66b7e3eb5d9d36cb69f633870d24f482cce5feae4f8a8095c5a01aa830a5e649453b3cc5be5dba581a37ea548db33df3bb74c2b0713ef87204811074f812340f6fd7e2cf593834c59bbb434b012f41757805da9b10c197c26aaf63659c4ff9e135e7e979bb04d157a63e2e62db2076874507401d90871550fe90f2ab0b6b78c7731616fc7996131aba5cc7c6e2321b68f3f2c66e02b8a50709ed3096359bfcd3affa7b91e94ab436079f6cb19bd1f0694b77a55b07e21a9eb95c9c0c8d3cb0ab8055e9a3d2db03020fd74b22ef5799d1e438c89e2423e8d0f68478739b914e6e75b8dbfbcfa461b90f09b54310c7932af25ab72edfae1723f20931c99b454a3511a86d919dd8bf6a4e65854ac0f181a615ff4f3503e309adf3b887786d2133e79684c05a59a5394929e8898d94a78740868d07f17df727f0832199ebf24df345b93513c4ebf1cfe180929d721265c7a8b6652911bc31877be71c06efe4f3d33267bde4a10adb5a37c289f02e33b5e5d4457249049076ce67ed91129cc95e5389658ff58899d816c5366277ca03d13c792f6726283ee0414392fccd416b4e0185f182a3a19a531db500f8e639f8bbef0c2026981f827091562b4f57c24d5613ed111ebc44d8599d5849cfb0f9feeccdd9fa8fc53f01ab4a89eeb82a782c3651ef9cac4f755d38526df578f4a2ea5e8d417316af6cd1454283dc4dbe5ba0d13a1e632439a46ba2fcc8764a83e6b60d5076b7a1af399917ece4347438259905b89aede6afe5c5f6a571fbf556fbe93b2ca7211b0009e3f0928b277010c10c54b409f8856d77ccfed19508aee5c0d11e679d40e336128a258683a3f0acba1be81f7d7a86a294096be58dbd2e470a171a23515554b2503112aef873cc64adf0b7873462f3825c33e8c4bf98b4c3d3f948d5cf1dc86e27e7c7e08b70d43604e576bc397ff117eae14436f1da4bd31298c059fdce07f713b0d2f0efafec5a1c0a011b7547f84056adebfeb36ddaa8b1b2c007e1037b393ff5ab244f56ebdbf2ab9fb1e6a655f181cae5ca693d2512771e98e3b5c5a7a16617f62452b1f912845f65635a3acb6f8e6bee5ee8b2d603271a2363c772ca8a53674cd97ee468b779639f82d1e71038e7df63dd0aca03dc9079dce4d65fdaf7a25e7c758506feb72589d38f496018bbf709e44f569917dc98f1296c08850a91c352a488ef6a8a8d9d394f7ad0ec9bf43b3f4a5bc207dc28a0035463256b87d8720b810403c9fba9273023801af319870a348befdd3794b8461672a0740bfbf90de4f51f271f02600bca088dc38680f2aea731837d32e5dc3e87432bdfc88b679782e570415b80f80144c6082a9dc7ea37c7e958346667bf594c340380cc57f66ef17e32ae9c94be482378efde75f775d252b9dabe0ed2fd6348fb2206d1eefdd97ecf96f707d8d0e0f3d2d2c98f3a7af7fa150f692ab9b2ad971c89ab46204cbf9078e5f24a93c1dee7a99eb4111741c8b0518fe9f8c1e14294144f015e861cd1f8e92300fd1c6df17aa2989eb47b1b3db316bc8e19b4918aad01f166a36cbb51ba3518c602d517b8d157ba5aa12861e913e9da1dc1a1e99ccee974e82db54f9babbfddee17d0b5db6b33f2ed781bbe8613d22efe1fcf0dc1b4bbcc36e8c8366740688c3c414b951f49161554efaaeba04b56b6a5cb2810e7155011728b4c09b1005da546f139867d2062ec3742c2fc6190dedb6d8475ec1ae74c7b75d182ff4f91f53be299697e61f28e3f92f1a83f700a08c4cb0f97089b8e1bc1778ab1e38354cdff991635a38391552eb101e66e9a5b61af8783cc79665cb5aad36bc554215efe5e6d5b013928d3da939c3852dcf888e19f2f7b095faa5c70522915d55986fba3c949db6638e92d7c598785f1f5abdb11a7e603ada144108e94ea38b38a77f777bd8dafe36d79bf4149471cb70612b9769a325b1d265524b44b47dd2869a6f70153703244fa199146fca020d5628139410bdb51d1ea4c4b24bde9fdb661face36f15dd4548b87c8c53eae5fc4c85b2c1a6e00285aae279d4d3dcc4baea8a86b53b54ee9eaa4f3656879b6fa64ed3d40fba0092580aa177d9eaeded16d14034992c4cfe7efb77259636199acfe018f833bb983c7efaa5edd6bdc6e40cc10b3e09bc1519c5b13c22da5fcc319dd48922112cbc2bc202188cc3071237784dd6074def35fda27eae6f1500a3b37dd0bdc5b444fec9e5964a4b6eeeeaddcdd698d38908d84fa9d88e284a95ea86a0fca20242541774b2e572c88f2b34e54fec5431eea01fe37090111ca5e8c1faea203d7ca31c6c444e3cd77c217c1744462f9ec462a40b1b2d9e2eaf62e11a7d51a475bee3b04102bb8a5cbb01ed330ad7c3ec2e18a0dff63b42426c24cd2d2beb33c786b64dc69df705534d243cb423e026b4c4e4f99035e8869be2693ea199d4b0d9d3f57ca71e957264e09545dd25edd141fbe60537020a66ea68e8f95a98fcfb57308a3fc36acbc9eb8639d63669ba9c8337bfaf848a3ccea53850b138a78e70e0f4a298892f7d7fb865eddfe624ee2c17e204b80ef92b9a0db574fe9463aebe3e52354002203a4c535bc46e19500ee48872e967917f9a9a579ebfc56eb24c54b68941b29eb072b36d4c17640a98cedeea9cde96d0182bb3670d695d703ff741a7298dc74d1824d709189997d1a065bf5c0dea949ee4d762168b4e5ba50445106ad60f7816c12480a3c89a61706ff3e8e4ce11a1b253ed5432d3f5a251f4578f766998c767c4aa64cfcc38901ffa333d537c2a59ad29f2ed7ee6028a273cee6f45d29eb74edeb8ee3d4ba59986fcabd85bbc71d714f9c90686f4923b1a311724bf5a8beb2e5bbee91ba51b74be7efc8bb56b7f949c6ab7b94e147ad290b69041c6d86348a296a26cd81d54a3e82156bccf91f324ccc1dd6e6befbde39e4b912b3793bbfff7007cca4147dc2ea3c2931b1dd4296f55904139af9c21b8c6a0f36ef8784e6aa60c907a48f64bfbb291c994c5258135c240f11b9f025d5bc47fbcfedea254d820240f93b11b7cef23ed9373e835c9bfae206a147e40adbd113187fb34efcd6a1f58c566655be1827ab9934c6739fa22c35c171229061edb61bc7ec98b96239507c16b5d84053078caf25bf8fe9128f7499782ed808174d0a8956b0336e374f4048aba843408889c8c62a2dff18593c15611a89d3c85f3fdc6336311c61b00bae656c819b609233d65e26089589df616e3074501da925b3e264cc729322e4a9162c6148431dc79bcf067fb89633b5d9508b2fc397e10ee61e4de49162128c2fcdd5149d41275664f0083ba7641e062eba4a77d627a9651983b29c1572a5685aeea2a5a497e58ad09d887240269a798bd2e00ca3e98525b5b3c54df00b83f6d734d1fc2064deb347869d56ea6c12d56f8304dda2063a3d9fc51b438644a69a5d64713ccc5bcee139fb5afd093a433e68cc1788352cee0c08aa154debecb5c4a3a1bca0d51a67513174702e7515cde3642c644034b6deb9bcaeb6ea0ab17f2ad5dfc28f10692fa13989e06624885ab2ff244969b5eceafce80d7c570e104be30a20144eede6356b700f8d8ff2f84c53a6b55636e7a1429d8e0e28576e6ca4893f6dbef3234464554dba879e714afdea73e3b8727efb1bc36d7dfbcb6e4327e01ce6b23bcd329cae99de4166fc5809f1ddd6748c9adb33b9c671e7bbc5562e887bf2701e81c264b60216a6bb45d0d274b85a404268dfcb49c84e2739020530b0c708093f349f71d5810840df5059ee04a0a98f1a50f16def3286905c50d31da4112b330d55cdb955f1cd0b75650201dfd35594f40d751fe9423a37f90437a373a8d86d01cee2f0fc5f8ee2c88c21fda0631543b35cd5c22efffa9b47aa936bb4c42c7ce347861bf82e3bcba79bdfdde36a831a6be52f4ec4713c3da41f3d6817c416f59727ffdb462540402fd98f00ab99a26b1f3f82c248c545cf7dd6fe397464cefc3d841257e9cc23c6f298b60e2a7a139e6f2519ae767101c74be110341a0efcb7efbbe2daf719e748d936edc2bd2869c0fa40a455050068ded966930013e641658f1db96ceed31b4f24470765edde5ad8c52c56838ffb0d1c341a743c741ae2e7620d40cc23562e645e1bf740b9f57b17f132a26dac9faa1b2c2ae2d9cafe9ef1b368b86f457283e7ada1590259901301e3ab32dd6df32af4d88d4b6bb24d7a6eae66abcfb10d278e35b52dc5abe8d215635a92b33a302f8d5d3b8709a9d4bd587c8f97b69740fbc3c85fbdbf4a44ad39b4c80b334f891160fc9a2736c388d4115ec2433f7c7c4e61370d0c0ffb28733e08d89b888c1168ca5e86c61b83d97135517af5776ad4a2dfa71473be1a518550fe6a69da3c2b8c8a6de4853a8bb6ccb67d91f83083dd34e2e27fa239ae66d1c725d84c4942ca7c07d657db5540a64fa7a2f9da7d6142bec11e7af595521bc88da7ad8cae0e283f9e5a0869ef3fdf8eb14bd0734d9817d17c851c40da1aafee33006657856c721ce108654fad5bc39bc8a96d485d22c8c48a92c431474a63699a7e746fb9c6f3d969628e083894a2da98404247e36f590ab3622f3f61b3b308d875179e4aeb14b60f28eb57dbcb54c5e00a0894b97204e1a5292276f42d5d36c443f1569c725d8ab03039571f01ac2e36f84102e6dd3b920affc0764a2e49ce42156f522b0585748645b979000a6a576f41425e831753a582bf9b8ca5008cfec904b1164eb754b9aa219d17727994c0b9084d6ddce76d6439a2586222b0c0282cd11091747ba984ad428f2831dbcbeef46196da98021f5fbc834dcc6c8b72e1faee645938aedb5176839f3624d93860ca8499bd1b1b563b2307b4d040e91859199d8d977bf1f497b0629fd793e4c0f115591182e6105c14bcc2ec83e9bb3d0e52f349d1bdf95665f7bce0124373ee612abd402e35514b2deb15acd19a67344c893927313de05fae9abba3c3ad145b9e577014eb00d4a5b9f95676981283ddd0b5d6b3f153c502fdae0b7270b860be6534c314018e2995f8b2636ea05f376663d1033732fde1b17d07a8952cded696391ddb5ce88a668bbdfe86c6a1cda910bd8964e178bfc4bf0bfe58ecc947e9b8509a3c5e26e77995949dbe5c962c2236d844ddaa8254f1ba2d99931cdae99b2b28b19b2c97388d910d65c5c38afff8893477cbfedcb7f1be3070da794ca5cb9042e10ecd19788d75e7b872597baa10d41b501252593f8c7559b66d395a6c77ac708956accffe39a1e15cbe6a6cbf4f80a1784bf8e723e0b1b567f88486e3439e8cf37727b00c1230d86ca07e8e86990ef9d9dd7cdc374da8fcf2b6838349af45ef24a4eda6a6dc76bfbdaff44bc979e64725b4480b19915d41d930527c67ff78f89026833d74130487d08acee9999a8f059711c6193a19dfac125ab86848956d42b1c14aa8d4ce3745df25eff9cdeab6614b71e1db831f850595b447e7b93fa8daedac17d6cad6e480661255d511a93ea41f6eced99052e1765b7c10a2325072ec39b0744b577854fbd706bb28cc30ad55e492b2e8bbffc74ef87f0b0b6f04d8c1b96f2ce2e205d812f4ae24cd5e3b9f4efdf8521564cbb0946b8b08b63b8b99b1647ba62dd33922d073f0cf8dc98eab5789468f22fd449fd36b94f39eb9fcd899f605b5f3624b25552243c46ab3fea663c041dbc27bc90bbd41fda7def08c0a51135aff39e693912b39f70870a1e3bb35652e098d3c316eb06ad931532095d509a34daf91a175d52884f65348f5c9781ba3feea3b2fecbb31f084b7d01a7a2755a0e24c010c41eb2c630fd0a33ce7c36f4db399042363e0b67f33934252f81b6682b2f8c865711c5c16e48a6bf7306ea3882e14c6b0a480ef4f4875797717d0ed59f68b5c8eeba198f1a5c50f75b8dbe310017c543599b7fed68711eb217e70013b0ca2899f895d0e0ee334661d9ec6d2cb8bfc455ee7cee1e7a6e95dfc284ad5a2ff908ae5a10518783c37e0168b63585aae861d8a65fc93e7ac195ca175532f1f4e897aaad0694bb985436035595b3a49998fa0a25e8d84820bc818a86196ed18a354da0524ed67e790c3d5a6281891ddf7f5da09e1e0d3c6ab3e99842575922043b2970f5ccfb22ec9bacb8fda519c1f921c92a1a6e12e117ad5a85386d8cfaed38ddee58aed3353df8f41c648bf2148ec81d6a471da68310d25b86799a9a7009b36ad5096ca4e97d11ebc22e742ba524d912295d836cd3991b8f323483983e4029af4b15156aee6dd5bc93ce1190269fbb9a454813504efd89deb6fb251fa5e010177537401d877d1b90f8e04968a56c9ac4018f90ac630cd252f7cff238d9e0edf5483cc1aff251e57d86e95d666213cedc1c900f9b9316ae5d399378d47d11590e90a332550f4e7ee437ecaf5e6e9314c0fb09cf7c57e6ea0d714a3ea40f2d3b994c9e044d63e0e77c82b0a9f1c80f8d02db4cd2f0956f26731e6e169d6ffdb7e8615a3d066293c3263fccb533a0d5063462b0f21449448636f32981b85f132beebb3ba624fd45bde4dca1b847f76d6661ef5faa80e1083229b37ffabc511e9de21f5c7e139ca0cb481e7260a81ce9a97fa378a9677e02247e008dd20fe485bc9b42aa08799762afbcbc88502e796e5fa3b592a5ac4dc0b8d98bd70458ba53dd69226bf3c18cd8c95267f1169dcd662e00ef15429286df02a8cdc7dc2891da364b86a69fe667dbf063b0f0e8e477426c2e87d552bd1229ef9c5806552c28594dddebbf564207347209c3f8364caf4e9e9cf72b66759535c6f8f8285d1109a19efd4a9634e852368dcb3550a83a026e155a8c6f911dcc041fe48aff419efbd1c7c0e40448aa394d727a8b20c603782e129899cd9e26726ad3f008fab7a0d20659ab0a69603147c8593f7219a36e7313cb027d5b6d683807cef41f3e54a2946996acf69379cd8ee66212fbfc54e3c574629089f684321ada1da1088674df2e52b1ee8710bc92c5128af66c82a24915440950628a2668e3b9282ed77f98ccfcfb314607a6691aa1ec4daec7efbe38cc73dd72a4e194a266920bf44516500b0e8df5f871bfa29e25009573cc06bcdd90fac101146087f4f9b7be692ae7720e3c43751ebfac78d6e4a4ed0cca95b98ed1e77486ad1c7c187292a05423d2c2b341217896936ce83234f6e3e751e72d3087c8c6ec9093eb0ae7a2989781c99d86a221df023df92fd23bcc784ed79d8e122a378a49d0740dd05c6c5315f7fb7c2ad948b1d5b02582fc76c9c83c1bac896c7705077b2f638d3f16c15957bb2dc3ba627fb48de23f61d7f5a4ac058e996cabd6776df850b0ee40470d160c027fc01b8090e54de0a982eab6aebb94d3e7c77c838ed62ebb890aa4c45f8d46c177a32099707a9b6488136d62da6f94588e7778f99fcdd7fac4a2f5b93cc478e695b1578ceca522476294a6de019a4ee10992649374b2cac8f7533db30bcef7e854de26f077a3bc1b0d48b837902dd97ce78fdcd251b9acce653984afaed6ca3fef8af1ab398eade46d6aa51c26acc27690622cfea4476fd92c8eacd4d68783b54c82706a2bf194e5f4fd90d60c77848a2bc886107ebc267860fb8161e3fe58c54f62a92698a60c46bb0078d30251e6d8e3b1d4c3c7734591db8c821636f041014c5196ba5e6e0ab45d751670e1aa37df288f835b61a391b9bbb6210d43d27d30140a1313d1d6059bcec7385365eb0b246770a896bdecc02f827ef47417bc7b3e5c44a8526fbc17cb61e7dfce6e9c55d618fd1ebd5616eb7bc6a1b85feb22772784683736ff520ebee90413ac757162a62a6aa3d67b6d36dc694d1e94d1d8e6a1e993b076a813f4e2c03bbea596e4f55515174b32e893536200fc7c3c10da2a6279544289c8e71af0b54b5f858376e7bd0222bd46c8129cb41a2f3fbfaa774391a7cbd880dccecd0731f2e842f329dde6a7fb8d5525fd424f4ba9730d35d2b0e912d80fc56edee6a0f511596371546ded4efb5446e34e2e8f4dd7c5288da5362273fd22f83010efd28d46f4b1057427f3aeb249c31c1210bd3f97e28317b93fec0a22f1f9e4ec11928761d5cf4698c98155bdcbe92ca0e0538e0a983d1ac50c663944a73d0afae2e991b5385b6ad7dd63da6fbf2d0f4fb7d475f65c137ef1db1555ce733b5e293aa48f18764b4d2148c60e1eb900ee5bd0a0e27bc0da46333f15d43395cee661a645ab3d1e88a12e131a5ca9eea84c955bad8071e78bd24b0fa95231312efbeefabc5066725ee4f777c6f90539d2be4b54a5fe0d06471b67fbbfbd228b75d5997cb245ea96e653588fbe8129ddf0d1aea68418d016fb29d632b4ff0a2edf941404e599cbb0d431bafe3e7ca2990d928a53a76b7940a2b22c7f660c10d2ce052f6561a8e221dc10cc0c0993c65aac7f55f271d254e2200f9631884c4e3fb6977ccb4859b95198056ce560b4e5b9de48fbbc860971fd0a2e9f9e1f0805f00f11e7c7667f53cfc17e200b8909bc720bc0c87274c2882d009e6c736698fc9135a2e708e99d067fd71688de328ba5ee334cdeb43c7680a8c65fd8ac0c5c3f111d3461ac38dc63ab95c62ce74024284d0dbca5aaa031a43d34116036eedc354548dc88334b7845943387d75debae8e0b87300982d68409f53422a6aae94af1fb8e1ac99044cd6a9430dfb707a333492024f90d78293f77e506eb599c1e098e0e5c23de7e29bb421228149ccbc109f6c134913a021ca77649e4f31c064b3977c7e837fb5e581e6bc37267e4a90917619bada4a7843d8d5580b90c69a46b1d6f2584ba2b0d3f047d30aaa7f56d2417d96499fb0a47b8abd9110f80b4ef182ec122b9aeefed49f0216ee7b6f83fa9734e52be2e2804a51b4dedd3d543a01bfb81802bdf1bd67adc4c636c7463cce4791da494135bce83d0ed545092d7bd3bb66b8312a19f885730e7ec00b6b1ba6dd8007389945f6f4515e685b683af9244bd503574dc3d7e2134e38a46589f0e30fdf8f452b40544f11f47bde2f33780b0da3c49a0b73f5aadfe02dc730403b8cf133a62cadb3a7ad81a305b46e9709286c2adefdf92b32657ea782420dd500710a6b461b6d60950144b5de223adf6750afd7bf27dfa7af72d843654738ef89cab7c0b52d3dab062ee2186dff2b063ce214dd24a3482146eee0ca606f93ff0005daf786f1215183542b3701b023e762d0f4f63c9d1e958b71bfca39b0702046f0260d6cb1e7422125fcdf03cadc26d7ffcd0346b4cbceebfe59e9f4bee6de7356862eddcb263f8748c36243a6793078dfbc86b3c321b467df43188ba3039aa15ea26633099f4db735d4b7912c1cd21e6fed12f801012ab81d9d8097096326338120d3ac84e20d9cd58112c75cc9bac61b0ab2a1e416a18e6d352882b1ced7a18083c02fe01ae209463d0b3cedda5df48f1fcd9ac3f87ff4dadf6667dd6fb81ed6117b79f8bab65d64e80c8c7dcd7501fec7d1bd49dce260d9755606c20e6d98007e6331fd96f0be92aeaef6ee8af31856e027438683e93938d16c42e2f27cce207d6fe06143813d40fc49420029cd5d270c8937ba5804b84e2ef681e94bd65de6e38c2f5e1d28028fb929d09c5de329f44f523894d3e69b86a04c3da9b5f2745a237470198147fac05314d2a2cdccb0ecb9b35783b058bd99e1d2a332b2b5aab373bc0f747021b2f88605d7ae7f4dc447599c9f4183becd64f0e01e80fef91f94b8e92944908bdcc1a87db3565f4f10ecdc36a985d58d96822f8d9574014a9788f6cd019988b8ac9ce46932f2dc0c7faea42accfacab7675aff47fc8842369607679d685ff3ec46e3bb7e377fd243aeede4981d9b5d008339f8611e69649e3fa750c0b97c8953f7ab5b43c14fefa99f27e76ceb3c6869d6211e4767136781fd2e5772a83838fa3af7de8d4e981383a818bd4e84eab31af2116ced9bbd2e36f46cda67e0020105a4d88dcc37b396930418d49bfea67da16dd01bc9e5c1df6ec236c102e93b1e12c2cd09f711b7f686c295a2991ab0ed563d099220e3e1ae6f4da767105f62864190f2f17ab67bab1e6db5dd223b841526cbce5ce55324145dfa7b4a33975d6fc75cdf18845106af04cfc2d47c2f68d2ce742496bbe0a6ab5b790b1e9c11cc92c3d4817cb3a24b7f0e5b2ca0111e5c8ebedddf68bf6e5f5d74d9739f1563a9251eb114d3bef1fcc619f89e47bcb2b481b5d76b680a3158839f9616ad5b55ed3258c77979b365526f52ade3785b5d18c45f0826e48f9cbadeda1edb0d9d7652fb2c898121715c21557777b1aa553891e6be512589e2fe0c1692d486bf19dc9f1b65d56cf02d989d215d5e3dfad5cb7d121d459b72668323bc3a447f15fd1dfca9cdb564169f4957edb6c4744f803af6ff1a655839581c897c56127b48f6f1c551936d5ad488204da32a55e4dbacdcf26a4c7be2c5214314bffe2446adb51e12608048598d53ad83699e8d1ac02e5265425695283e5189f4820f93e5ad29267994f5bc342d4ab09ff8852eef81f55793e51b5541b8cff6665667306ddbf5cf447cfb7f0e221250606e0b65f4614e0e21af6b2bff1c1c6c972aaea2c28ff55fd6592039946c4422b271b39b6f77ab7eaaeb21ff98e20dc66f2d0fe88caf78019c0bc88c116fa3d658dc19a434a08b8ff6b7a6048310b4787578a61b67ed1b116d44e82ff7da66d5d9319a8311ddb897999ecf1297d472b874a68fa761689aeacc2ca2b744c7eedad86055b978d062ba50c6de1bcc9dea08e315a33fe9dc7a6fb8371e9b1f8e07fc346e028e2959840f20803c18b573765e6757267f6a98bc9c2201aef751c9226e7f7acb62988c206e698c5511c0941e5ba86b9275a23f632f289370dced4b8dc8be3eb7a084923b7c53c4fad2a948ceded1cf4620252608aa00a46059441b40dbe1d18628d8857382f9b6e14d37eeaa7f4ed2ec947e795029845dc4292fcb86bd472a50dc52fd2dfc305c8a4d061b4577f93a2b6d762f8893416d6a519034297d2029052f13f79a29f065dc94e51d772c81d0cfd82518256e5c0a523573d6850fd21fd407e1566fd539bd7a70d63ce90cfa90fdf81f2faee84e0e316141c37f21b9f50e34fd52ce341046c1d330d6f41eae145abd0807753c99effa587790a5dc89f23c16ae9e21a195756a0e3ca6efdfd751459e3a42745ab2e72a554a6c980f9146d62b1fda0d46160e528b3da332152e26ec17536978bc70d3d5e5e369ed51685044e8ac44aeb99d5b8f5e1676ce66ce52cdd8c565b800ea27df192478cabd295899ad3dda52e7f7c4615c2a3f2c9a4c7a3733dc6f74388007ad5a3c15b38daaa32dcc41cf3293806cb19bf3dfdcab223778f2a2b1c68f991e0261333113dadda4f94b7633c9b3f7734d42c5f6e85818a7697d25c9e5e51b7f17d68c77d08c4528786c59fd2641b023e3542645fa44d46d606e683dc8dcae0645d04d1574c87d90e54c99b5f2670491c5db36ca595bb13bd948702a0e3cc94a03095953898f3277eadfd9e1032234019291647cbb4abef700af490c94848ae346c4208deab4c66d874798c2b027fd582367f230b54a398d205601fa24e8917eceb6dc55c969a9095a06e881a1097dc563de30067c1feedbdaa433dfbc870744544824d15e0aa60e540518f7d8df251481abf3afb8113a86b6be9dae4d848e71874fe5938bb2a83420976409146246aba704b52b79d6967e9c78f504e56c1e6f7747581f4c409fa0e0b5b6243102113d724a231cb8a5feee709423d2c1ddefd7466741ca9db1c7d0eb62b1d14c20a1be8d2e3111692a639e6a3ef3582381c4f0e6c0d5723380798993b9197aabf1e7df82f362d8d7c66ead8015be2df8962b4fdcf537094acb88900f4ac01236a8ea0534388bfc2107c8716569183a1b798603d8e9570ab757969b5c685957c717fa5a1aaa8f3e51eed6be0fd65a1be87aa25c80ae72af464a74b55b18340058e27a3de911bf0fa8ef8d40f921d16de56b469caabb1cbcc70ebdfffce119df4ba07fedcc8459071390431055548123e8ff49d944d3666a9bfa23ef4db31fe9179bf6bfa71c0558421fa178862389d58a685853387fb369fe4222d54118e9a74fcb5b3b3493e4195f03fbc2eb4007691e997fb721272728e44719c1a3e2efecc4f1efd9da15f2eb5110f580340d9996aa2b15201039f4d04f7558b5708dcb8c3921433b8a03767137442d4fb830e08ecde955d7159a655fd7242d62aef47c85a1829926b6768e651382b42c183a01839966e94a90305d07e05a9c391b2276c43f87422c003f2b9d5f603748098020cd864b2c39df69a93e9b4a37a43a01118ca7bd36c28d7ef43b7b09a2411dd4d747ea06a4da0e27cd2280bb6bd4c0391031040716c69dd0a05dfa0130a059679218a8cc9de7c901c04d114936da12d5db9ed8cc102f691db696ef95b5f12361bd81d26e633d52491f485e4467f428c5718ba4ae80284d4df5b0b9ecc99f06332b6004b8ed6bf2fdba9e5855b3b80884e7e767c75612ed22ffdf7298bc2443dc211528f2b93cb0dfd037f81fccfef94bf9eff79045897f046bbb5e548532ce299b6289419e5d145f2d2214064e28ce76464a103f6309c99bad0b9479869c00017b0b341e1faac57d9675f64fa49b408b5bd908cbedb56dedf01d97bbadec78eb753ade3ec7e6f7a16ea3c4d9572526f35c2e15358a02d75a5924270f2f11b4718af840cc11f965878b30dec0f38a87f5f4fbfc20d009ac96f5b080fa7d6e986071f4933505e477f31b668015e7b08b420d38a9f2745127a78a39abee0fecb8488da2e9fc26b19e6bd9687ecda085367bf4c497f106d9b318ceff3091c084c0d1c3f1541f995ecd2886c1770ee2db0e2feec06e90e9b35dbd28915f592fba732f5b6f52acb91aebd508e5d61a0d2d8f74f99fc2d5ec173b51a651adf596dc0294600bfe4998c960eaf1d8d33273a9562740cb46c2368b8ee2eebd8fe5b3c476813ef34c290a2039cb7645b77955d4e1dea52cbb2eb5b4ff935a0a4b2c709aeb1469174ec0ee76acfe1d4b8b223e35e6e850a015bc8d17683f030281f1398d125df3220c7082d3b8f83d1dc642ea5b6e854df1a2b7d3d825dcf5413425b23285c981516ce44e7b7249e3c11cecfd6dbe2af1f1f0e78ce0fe36f60c403057f1b31b3fa837897b517a7d9397fa75d1115566f593f999871b1859622134bdced570d5c7baf118f75afbeeb0c6def40e0a7978151e37ea90880112c3d4a3fa1ef741d166828b1d2f1eebdd2276a1d7d53b572e6aed1b4cfe26c79f1bbae267810b3843dd8dafc0dab528f6824d2f59082330bc465e3f89e45772b8c5d1ff2dc6e1c3620f75fe54425e1442061edcdc66347b23d76ac8a582c7f2e5b6c0eae499d2aad2db98984de6254db6633a1242564dfe1f8f82bbcf21ebe5a996daa04672785e7fb18a2b6794520dc13cd7c4ccd44c74e4fd61bda730e2d44c83c44393cca7115e39c330b446e5348ee7b8a4ded3b217cb569e72b1ec1cd4a4b6c78d2fad2ab5da19e77fcab495a83c2e5d362cfed7f8941a7cb77fa54dbd80262b1dbb2d5088858ef83f01bd1df26854d131b1a4fa007363e6088c544a648620769bf13922abe0ac79daf91518c9d71f6bbeb8f87517fa36dd9e905c9d80b8ff1cc1327a2de8313bf445549ebbbe3fc4b421471eb43b3e283062d9c067a411e7c8b29ba934c2920cd296386490d599aab5b793a547ce76261b24c262b6addc308e9d11abf64f92d187ae4808f3af3fcafefff0564af1cd7efc784fee7314befa643be0b3a6b848de9ffd8830645aac60105362a3a8b1c5a4e5b884b5432329ec8e2148baaa1ea26793f97fd8fbd4d90035d07f38fb6ce3d6b04ecde2dc10999fe5d668db9cd43abc92eeead6d80cc829a639854f0c957c13654bbe5c1fcd8a6b7a12f9310973495ea4d30d2db23f39167687b8138107c8233feba5290564aaf9b722610abd8b80757c66464c300b59adc73232954c85c22f97fa190cbeca073cfd820312c134a766074796ea6562a638800931d5080683bdba3b4df01f822d61be0e4b730495be8865f8210fdebc1cc15b69ff9665d0162b76c932f03291226f7be1694f6aa5612f9d752e4f8afcb707a9e99eba11a8b2cdec775cfb03aba9a905ecd960165328e1b176e4db850f2744532dda316fa7b56dd12682905ac77b7fb31a6f3943d1c3aa16d37a3d39420dd78ad88ab35b612a38cf5bf83777a2af4e8dc43a4ed4b64268f0bbc96b9c60bc06e2208893451788aa0b1f55adf6fe9393b43d8edd0a87e28143905efe338b311b98987adde30a916013f5ab29ff12593a124976dd8a1f51f16be79add271360c90066335130f3b3aae2dd94cfc716036e113795372e7e0310e2a8312e0048023fb5e35464558ddd61e076c203fd3da459114088f35e0a63d43ee7f6d03e6d3d9d7c36fabadc0a56755f232dfae209275d3f28845999afc648b58275ca0c61315780da968e4fecd77fc618b97d33851d462b31d332579569b3dd74fdbd4bf0ab0b6c75557bc7afb82a978a8d05eb286a29fa7fd7be9c6426e512caf21981cf52ebe501ed1385de9195981433f0907f33715ee6453aecae3e37d36f6385669f963e0abf21d186328e9ed52e57e73093ebd82e54dacd51a162a074a906f6f50a694e7c0f9cc031368118e88d6750ec3843ad396e191339e6d5471e8ebbef3b833ac60ab2594fd2a07a8d16620af33bc674eda5622a564d2cececad83f997867ef8992d0a2b27aac10e0fde74e7e24daed3ec07b125a00f8237db53ccb909ebc59c795d5dec3ef71e9cc62ff356b9c36cf100c325fda36df76c3d438222423edf2e95bc23e2fc365c9806cd6461d407383cc7de409d5f523e16eb614ae815f7c92e7d869505ebb44c2ddabed09a5bb938527df38298e81d5344d7b19e375c11d8614bd0b3367cbb0784fdf83fd0cf59ac19da47350c556d8f88d74adad06dfd4fc534c2d688452bf672fe76a03d8742d94e2388bf68108bdf01988e31ba7d78c231dd90b713835a9ae568ae00287e4dd7b1745a7906c12f7a2cfb2c6896c0635234bd75e2ae5d14fca969e250d990a5d8a2d97cafd1102056b8ce95e429fc82da8c31902605b42d32d5167b9fe759e6e4443ad8d9cc6cceef392bc70202cd6e4a5c0815f73ae024469534bc57d754ff564f11fba7eb03d8274ecbf86a20b8b83ae34b01d48e4f988673a399c351e37512b953ec7e0f65706ee7f7dbdecc33d684d3e7b69d667c0de1b66f49a13a6f47ee565bba4a1b5d2e240fa8d81b26bd4d0b72e6814807a31c707fda8c4d54abe2c71e5a9bf063697d6358341a4a9e9ef4e3f46111f7bbf1ca456fa65bc2d0f57c6e0133e2747a56ae01df4d37838c8ff6fc3e49e15487c3ff7b0cac3e9d32423734a609deda208b8577ce8b8268de4b6e6c8b786fd9cb8fc0a9bd0d467e4b121607f277e477718a9f8a41e395b6764259b0dcc2c2768b5e5bbc587ba79987439dc7895fe59152edde2c228671526a42dc54fde60f59aa3625ff580d23811155705dc67e805eda3c1e8438b573960b84ad66f3b9385d00748f5f1fd3cfa2176cab2905e514c7e3d922f5cb084d63c7fe6e05e93533702732ac4649c591f3ea72977afa91c1857264c376c0c4e9c51f3f16782c33800f55487c75651510095a14ccb8f2cce47ac70ea54d706f1e4891cce376bcf6bbe62d2061fbc4c5d27cc34a774eb6a0b45bce4d819aa875b5498497b549a3b4806e57873750dd966037ec725dd3b477c25be727db8a6a677435ba9589281bf6eaa287a1300df68992a8c0f230cb1ddfc121ca9604982cfc1f06d8737e7ad82483e640ed365f1261f331234140e913be135957a86ac5c2c879e53cd91bb8e6d1fb0556b69aa40a5642d5cbc354c0e443c1fe0f22000def4108afe0e375cab4ec0da4ce76a7860b089a76cbbe05c505ca4c4490d254ea2ba64f55c7aabaa8d897f83e329e5e48db75303aea96a97f5d83e584ce2d02834f67bc505344b1c2432953afd87aaa8a8745fc6fbf8006362ed8fcd7f5ede279f14ad295f355c74b788c9f913df84d0e2e6beb30335648952479514b25531053e644e412f15d3b14be9e857fba754449307c03d93741aacc10c9d799fa0062a13a20daa</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">文章被主人加密了, 小窝要核验主人给的『通行证』.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树链剖分</title>
      <link href="/post/9a0cb8b2d897.html"/>
      <url>/post/9a0cb8b2d897.html</url>
      
        <content type="html"><![CDATA[<p>树链剖分</p><p>树链剖分，就是将树剖分为若干条链，用来维护树上信息，常搭配树上值域线段树，如：</p><ol type="1"><li><p>修改<strong>树上两点间的最短路径上</strong>的节点权值</p></li><li><p>查询<strong>树上两点间的最短路径上</strong>的点权和</p></li><li><p>修改以某个点为根的子树的每个节点的点权</p></li><li><p>查询以某个点为根的子树的节点权值和</p></li></ol><p>其中，操作3和4可以直接建立树上值域线段树解决，操作1和2需要进行树链剖分。</p><p>树链剖分有三种方法：重链剖分（复杂度 <spanclass="math inline">\(O(\log n)\)</span>）、长链剖分（复杂度 <spanclass="math inline">\(O(\sqrtn)\)</span>）和实链剖分（常用于LCT维护）。其中，重链剖分最为常见，因此<strong>本节主要记录重链剖分的学习笔记</strong>。</p><h1 id="一基础定义">一、基础定义</h1><p><strong>重儿子</strong>：一个节点的所有儿子中，子树大小最大的那一个儿子。如有多种选择，就<strong>只选一个儿子</strong>。</p><p><strong>轻儿子</strong>：一个节点的所有儿子中，不是重儿子的节点。<strong>根节点也是轻儿子。</strong></p><p><strong>重链</strong>：从一个轻儿子开始，沿着重儿子走，连出的极大子链。</p><p><strong>轻链</strong>：不是重链的子链。</p><p><strong>重链定理</strong><span class="math inline">\(\quad\)</span>除了根节点以外的任何一个节点的父亲一定在一条重链上。</p><h1 id="二重链剖分">二、重链剖分</h1><p>重链剖分，需要我们维护一下内容：</p><ol type="1"><li><code>fa[MAXN]</code>，即节点的父节点。</li><li><code>dep[MAXN]</code>，即节点深度。</li><li><code>son[MAXN]</code>，即该节点的<strong>重儿子</strong>编号，如果是叶子节点，则<code>son[p]=0</code>。</li><li><code>top[MAXN]</code>，即该节点所在重链的链头。</li><li><code>sz[MAXN]</code>，即以该节点为根的子树的大小。</li><li><code>dfn[MAXN]</code>，该节点进行 <spanclass="math inline">\(\text{dfs}\)</span> 的时间戳，即该节点的 <spanclass="math inline">\(\text{dfs}\)</span> 序。</li><li><code>w[MAXN]</code>，即在 <spanclass="math inline">\(\text{dfs}\)</span> 序中，该序号节点的权值。</li><li><code>tick</code>，即 <spanclass="math inline">\(\text{dfs}\)</span> 时间戳。</li></ol><p>前面几个信息可以打包进一个结构体，然后线段树需要另一个结构体。</p><p>重链剖分要求重链上的时间戳一定要连续（方便在线段树上区间修改和查询），所以需要进行两次<span class="math inline">\(\text{dfs}\)</span>。</p><h2 id="quad-第一次-textdfs">2.1<spanclass="math inline">\(\quad\)</span> 第一次 <spanclass="math inline">\(\text{dfs}\)</span></h2><p>第一次 <span class="math inline">\(\text{dfs}\)</span>需要处理出重链剖分的前置信息。</p><p>从根节点开始遍历整棵树。记录节点父亲、子树大小、深度，还有重儿子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    T[u].fa=fa;</span><br><span class="line">    T[u].sz=<span class="number">1</span>;</span><br><span class="line">    T[u].dep=T[fa].dep+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> tmp=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        T[u].sz+=T[v].sz;</span><br><span class="line">        <span class="keyword">if</span>(T[v].sz&gt;tmp)&#123;</span><br><span class="line">            tmp=T[v].sz;</span><br><span class="line">            T[u].son=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quad-第二次">2.2<span class="math inline">\(\quad\)</span>第二次 $ $</h2><p>第二次 <span class="math inline">\(\text{dfs}\)</span>就可以剖分这棵树了。</p><p>我们进行重链剖分，记录该节点所在的重链的链头和时间戳。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    T[u].top=t;</span><br><span class="line">    dfn[u]=++tick;</span><br><span class="line">    w[tick]=a[u];</span><br><span class="line">    <span class="keyword">if</span>(!T[u].son) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(T[u].son,t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==T[u].fa||v==T[u].son) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quad-建立树上值域线段树">2.3<spanclass="math inline">\(\quad\)</span> 建立树上值域线段树</h2><p>因为子树的 <span class="math inline">\(\text{dfs}\)</span>序一个区间，我们就可以建立值域线段树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].l=l,tree[p].r=r;</span><br><span class="line">    tree[p].tag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[p].sum=w[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,ls);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">    <span class="built_in">update</span>(p);<span class="comment">//整合子树信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三维护信息">三、维护信息</h1><h2 id="quad-进行子树加操作">3.1<spanclass="math inline">\(\quad\)</span> 进行子树加操作</h2><p>因为子树的 <span class="math inline">\(\text{dfs}\)</span>序是一个区间，可以在线段树上进行区间修改操作（<spanclass="math inline">\(\text{modify}\)</span>），修改的区间就是 ，其<spanclass="math inline">\([\text{dfn}[p],\text{dfn}[p]+\text{sz}[p]-1]\)</span>中<span class="math inline">\(p\)</span> 为子树根节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r)&#123;</span><br><span class="line">        tree[p].sum=(tree[p].sum+k*<span class="built_in">len</span>(p))%mod;</span><br><span class="line">        tree[p].tag=(tree[p].tag+k)%mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);<span class="comment">//懒标记下传</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(l,r,k,ls);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(l,r,k,rs);</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//in main:</span></span><br><span class="line"><span class="built_in">modify</span>(dfn[x],dfn[x]+T[x].sz<span class="number">-1</span>,z,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="quad进行子树求和">3.2<spanclass="math inline">\(\quad\)</span>进行子树求和</h2><p>类比子树加操作，在线段树上进行区间求和（<spanclass="math inline">\(\text{query}\)</span>），求和区间就是 <spanclass="math inline">\([\text{dfn}[p],\text{dfn}[p]+\text{sz}[p]-1]\)</span>，其中<span class="math inline">\(p\)</span> 为子树根节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r) <span class="keyword">return</span> tree[p].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans=(ans+<span class="built_in">query</span>(l,r,ls))%mod;</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ans=(ans+<span class="built_in">query</span>(l,r,rs))%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//in main:</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">query</span>(dfn[x],dfn[x]+T[x].sz<span class="number">-1</span>,<span class="number">1</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h2 id="quad-进行路径修改操作">3.3<spanclass="math inline">\(\quad\)</span> 进行路径修改操作</h2><p>根据重连定理，除了根节点以外的任何一个节点的父亲一定在一条重链上。所以我们就可以进行重链到重链的转换，从而一点一点地在每一条链上进行区间修改。</p><p>考虑每次选择链头深度高的那条链，将该节点跳到链头并区间修改，此时就改掉了这条链（也就是路径的一部分）上的值，修改区间为<spanclass="math inline">\([\text{dfn}[\text{top}[p]],\text{dfn}[p]]\)</span>，其中，<spanclass="math inline">\(p\)</span>为该节点，而后跳到链头的父亲，此时就在另一条链上了，可以重复操作直到两节点在同一条重链上。</p><p>如果两节点在同一跳重链上，则可以直接进行区间修改，修改区间为 <spanclass="math inline">\([\text{dfn}[x],\text{dfn}[y]]\)</span>$，其中<span class="math inline">\(x,y\)</span>是两个节点，且防止无效修改操作， <spanclass="math inline">\(\text{dep}[x]&lt;\text{dep}[y]\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addOnTree</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    c%=mod;</span><br><span class="line">    <span class="keyword">while</span>(T[x].top!=T[y].top)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T[T[x].top].dep&lt;T[T[y].top].dep) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="built_in">modify</span>(dfn[T[x].top],dfn[x],c,<span class="number">1</span>);</span><br><span class="line">        x=T[T[x].top].fa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T[x].dep&gt;T[y].dep) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="built_in">modify</span>(dfn[x],dfn[y],c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quad-进行路径求和操作">3.4<spanclass="math inline">\(\quad\)</span> 进行路径求和操作</h2><p>思想类似路径修改，只不过把修改操作改成求和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSumOnTree</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T[x].top!=T[y].top)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T[T[x].top].dep&lt;T[T[y].top].dep) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        ans=(ans+<span class="built_in">query</span>(dfn[T[x].top],dfn[x],<span class="number">1</span>))%mod;</span><br><span class="line">        x=T[T[x].top].fa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T[x].dep&gt;T[y].dep) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    ans=(ans+<span class="built_in">query</span>(dfn[x],dfn[y],<span class="number">1</span>))%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四参考代码">四、参考代码</h1><p>本代码为树链剖分/重链剖分模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((tree[p].l+tree[p].r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls (p&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs (p&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> len(x) (tree[x].r-tree[x].l+1)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">G</span>&#123;</span><br><span class="line">    <span class="type">int</span> sz,dep,top,son,fa;</span><br><span class="line">&#125;T[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">F</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,sum,tag;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m,r,mod,a[MAXN],dfn[MAXN],tick,w[MAXN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    T[u].fa=fa;</span><br><span class="line">    T[u].sz=<span class="number">1</span>;</span><br><span class="line">    T[u].dep=T[fa].dep+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> tmp=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        T[u].sz+=T[v].sz;</span><br><span class="line">        <span class="keyword">if</span>(T[v].sz&gt;tmp)&#123;</span><br><span class="line">            tmp=T[v].sz;</span><br><span class="line">            T[u].son=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    T[u].top=t;</span><br><span class="line">    dfn[u]=++tick;</span><br><span class="line">    w[tick]=a[u];</span><br><span class="line">    <span class="keyword">if</span>(!T[u].son) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(T[u].son,t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==T[u].fa||v==T[u].son) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].sum=tree[ls].sum+tree[rs].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].l=l,tree[p].r=r;</span><br><span class="line">    tree[p].tag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[p].sum=w[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,ls);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tree[p].tag) <span class="keyword">return</span>;</span><br><span class="line">    tree[ls].sum=(tree[ls].sum+tree[p].tag*<span class="built_in">len</span>(ls))%mod;</span><br><span class="line">    tree[rs].sum=(tree[rs].sum+tree[p].tag*<span class="built_in">len</span>(rs))%mod;</span><br><span class="line">    tree[ls].tag=(tree[ls].tag+tree[p].tag)%mod;</span><br><span class="line">    tree[rs].tag=(tree[rs].tag+tree[p].tag)%mod;</span><br><span class="line">    tree[p].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r)&#123;</span><br><span class="line">        tree[p].sum=(tree[p].sum+k*<span class="built_in">len</span>(p))%mod;</span><br><span class="line">        tree[p].tag=(tree[p].tag+k)%mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(l,r,k,ls);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(l,r,k,rs);</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addOnTree</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    c%=mod;</span><br><span class="line">    <span class="keyword">while</span>(T[x].top!=T[y].top)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T[T[x].top].dep&lt;T[T[y].top].dep) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="built_in">modify</span>(dfn[T[x].top],dfn[x],c,<span class="number">1</span>);</span><br><span class="line">        x=T[T[x].top].fa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T[x].dep&gt;T[y].dep) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="built_in">modify</span>(dfn[x],dfn[y],c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r) <span class="keyword">return</span> tree[p].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans=(ans+<span class="built_in">query</span>(l,r,ls))%mod;</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ans=(ans+<span class="built_in">query</span>(l,r,rs))%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSumOnTree</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T[x].top!=T[y].top)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T[T[x].top].dep&lt;T[T[y].top].dep) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        ans=(ans+<span class="built_in">query</span>(dfn[T[x].top],dfn[x],<span class="number">1</span>))%mod;</span><br><span class="line">        x=T[T[x].top].fa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T[x].dep&gt;T[y].dep) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    ans=(ans+<span class="built_in">query</span>(dfn[x],dfn[y],<span class="number">1</span>))%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;r&gt;&gt;mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x,y,i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(r,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(r,r);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> op,x,y,z,i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">                cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">                <span class="built_in">addOnTree</span>(x,y,z);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">                cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">                cout&lt;&lt;<span class="built_in">getSumOnTree</span>(x,y)&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">                cin&gt;&gt;x&gt;&gt;z;</span><br><span class="line">                <span class="built_in">modify</span>(dfn[x],dfn[x]+T[x].sz<span class="number">-1</span>,z,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:&#123;</span><br><span class="line">                cin&gt;&gt;x;</span><br><span class="line">                cout&lt;&lt;<span class="built_in">query</span>(dfn[x],dfn[x]+T[x].sz<span class="number">-1</span>,<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合计数</title>
      <link href="/post/425aabd8d0fb.html"/>
      <url>/post/425aabd8d0fb.html</url>
      
        <content type="html"><![CDATA[<p>组合计数</p><p>本章主要记录基础组合数学的有关知识，包括加法原理、乘法原理、排列组合、二项式定理、卢卡斯定理等基本知识。</p><h1 id="一计数原理">一、计数原理</h1><p>基础的计数原理包括加法原理和乘法原理，是组合数学的基础。</p><h2 id="quad加法原理">1.1<spanclass="math inline">\(\quad\)</span>加法原理</h2><p>若完成一件事情的方法有 <span class="math inline">\(n\)</span>类，其中第 <span class="math inline">\(i\)</span> 类方法有 <spanclass="math inline">\(a_i\)</span>种不同的方法，且这些方法互补重合，则完成这件事一共有 <spanclass="math inline">\(\sum_{i=1}^na_i\)</span>种不同的方法。这样的计数原理称为<strong>加法原理</strong>。</p><p><strong>例</strong><spanclass="math inline">\(\qquad\)</span>中午可以去A、B、C三个街区吃饭，三个街区分别有<span class="math inline">\(6\)</span>、<spanclass="math inline">\(5\)</span>、<span class="math inline">\(8\)</span>家餐厅，那么中午吃饭有 <span class="math inline">\(6+5+8=19\)</span>家餐厅可选。</p><h2 id="quad乘法原理">1.2<spanclass="math inline">\(\quad\)</span>乘法原理</h2><p>若完成一件事情需要 <span class="math inline">\(n\)</span>个步骤，其中第 <span class="math inline">\(i\)</span> 个步骤有 <spanclass="math inline">\(a_i\)</span>种不同的完成方法，且这些步骤互不干扰，则完成这件事一共有 <spanclass="math inline">\(\prod_{i=1}^na_i\)</span>种不同的方法。这样的计数原理成为<strong>乘法原理</strong>。</p><p><strong>例</strong><span class="math inline">\(\quad\)</span>餐厅有<span class="math inline">\(4\)</span> 种主食，<spanclass="math inline">\(2\)</span> 种配菜，<spanclass="math inline">\(5\)</span> 种配汤，那么可以组成 $4=40 $种套餐。</p><h1 id="二排列数与组合数">二、排列数与组合数</h1><h2 id="quad排列数">2.1<spanclass="math inline">\(\quad\)</span>排列数</h2><p>从 <span class="math inline">\(n\)</span> 个不同元素种依次选出 <spanclass="math inline">\(m\)</span>个元素排成一列，产生的不同的排列的数量为</p><p><span class="math display">\[A_n^m(\text{或记作}P_n^m)=\dfrac{n!}{(n-m)!}\]</span></p><h2 id="quad组合数">2.2<spanclass="math inline">\(\quad\)</span>组合数</h2><p>从 <span class="math inline">\(n\)</span> 个不同元素种依次选出 <spanclass="math inline">\(m\)</span>个组成一个集合（不考虑顺序），产生的不同的集合的数量为</p><p><span class="math display">\[C_n^m(\text{或记作}\dbinom{n}{m})=\dfrac{n!}{m!(n-m)!}\]</span></p><h2 id="quad组合恒等式">2.3<spanclass="math inline">\(\quad\)</span>组合恒等式</h2><p><strong>恒等式1</strong><span class="math inline">\(\quad\)</span>选出一部分再反选，有 <spanclass="math inline">\(\dbinom{n}{k}=\dbinom{n}{n-k}\)</span>。</p><p><strong>恒等式2</strong><span class="math inline">\(\quad\)</span>考虑枚举是否选第 <span class="math inline">\(1\)</span> 个，有 <spanclass="math inline">\(\dbinom{n}{k}=\dbinom{n-1}{k}+\dbinom{n-1}{k-1}\)</span>。</p><p><strong>恒等式3</strong><spanclass="math inline">\(\quad\dbinom{n}{k}\dbinom{k}{t}=\dbinom{n}{t}\dbinom{n-t}{k-t}\)</span>。</p><p><span class="math inline">\(\qquad\)</span>辅助理解：<spanclass="math inline">\(n\)</span> 个人选 <spanclass="math inline">\(k\)</span> 个队长再在其中选 <spanclass="math inline">\(t\)</span> 个大队长，等于 <spanclass="math inline">\(n\)</span> 个人选 <spanclass="math inline">\(t\)</span> 个大队长再在剩下 <spanclass="math inline">\(n-t\)</span> 个选 <spanclass="math inline">\(k-t\)</span> 个队长。</p><p><strong>恒等式4</strong><span class="math inline">\(\quad\)</span>枚举最后一个选在哪里，也可由恒等式1迭代导出，有 <spanclass="math inline">\(\dbinom{n}{k}=\sum\limits_{i=k}^n\dbinom{i-1}{k-1}\)</span>。</p><p><strong>恒等式5</strong><span class="math inline">\(\quad\)</span><span class="math inline">\(n+m\)</span> 个选 <spanclass="math inline">\(k\)</span> 个，枚举前 <spanclass="math inline">\(n\)</span> 个选多少，有 <spanclass="math inline">\(\dbinom{n+m}{k}=\sum\limits_{i=0}^k\dbinom{n}{i}\dbinom{m}{k-i}\)</span>。</p><p><strong>恒等式6</strong><span class="math inline">\(\quad\)</span>枚举第 <span class="math inline">\(a+1\)</span> 个位置，有 <spanclass="math inline">\(\dbinom{n}{a+b+1}=\sum\limits_{i=a+1}^{n-b}\dbinom{i-1}{a}\dbinom{n-i}{b}\)</span>。</p><p><span class="math inline">\(b=0\)</span> 时退化为恒等式4。</p><p><strong>恒等式7</strong><span class="math inline">\(\quad\)</span><spanclass="math inline">\(\sum\limits_{i=0}^n\dbinom{n}{i}=2^n\)</span>。</p><h2 id="quad组合数的求法">2.4<spanclass="math inline">\(\quad\)</span>组合数的求法</h2><h3 id="quad-根据定义求解">2.4.1 <spanclass="math inline">\(\quad\)</span> 根据定义求解</h3><p>求解 <span class="math inline">\(C_n^m\bmod p\)</span> 时，可以计算<span class="math inline">\(n!\bmod p\)</span> 的值，之后乘上 <spanclass="math inline">\(m!^{-1}(n-m)!^{-1}\bmod p\)</span>（即逆元）即可。当 <span class="math inline">\(p\)</span>为质数时可以利用欧拉定理和快速幂求解逆元，其余情况可以线性求解逆元。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll p)</span></span>&#123;</span><br><span class="line">    ll w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) w=w*a%p;</span><br><span class="line">        a=a*a%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m,ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (a[n]*<span class="built_in">qpow</span>(a[m],p<span class="number">-2</span>,p)%p)*<span class="built_in">qpow</span>(a[n-m],p<span class="number">-2</span>,p)%p;<span class="comment">//a数组为线性预处理的阶乘数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="quad-递推求解">2.4.2 <span class="math inline">\(\quad\)</span>递推求解</h3><p>根据组合恒等式 2 <span class="math display">\[\dbinom{n}{k}=\dbinom{n-1}{k}+\dbinom{n-1}{k-1}\]</span></p><p>我们可以递推求解。下面的代码求解出了所有 <spanclass="math inline">\(\dbinom{i}{j}(0\leq j\leq i\leqn)\)</span>，表示为数组 <code>c[i][j]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        c[i][<span class="number">0</span>]=c[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            c[i][j]=(c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三二项式定理与杨辉三角">三、二项式定理与杨辉三角</h1><h2 id="quad二项式定理">3.1<spanclass="math inline">\(\quad\)</span>二项式定理</h2><p><span class="math display">\[(a+b)^n=\sum\limits_{k=0}^nC_n^ka^kb^{n-k}\]</span></p><p><strong>例</strong> <span class="math inline">\(\quad\)</span> <spanclass="math inline">\((a+b)^3=a^3+3a^2b+3ab^2+b^3\)</span>。</p><h2 id="quad杨辉三角">3.2<spanclass="math inline">\(\quad\)</span>杨辉三角</h2><p>对于每个 <spanclass="math inline">\(n\)</span>，二项式定理拆解后的二项式稀疏构成杨辉三角，如下图。</p><p><imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/bisgz7o3.png" /></p><p>可以发现，三角中每一个数为其左上和右上的两个数之和，可以得出 <spanclass="math inline">\(C_n^k=C_{n-1}^{k-1}+C_{n-1}^{k}\)</span>，即恒等式2。</p><h1 id="四卢卡斯定理">四、卢卡斯定理</h1><h2 id="quad卢卡斯定理">4.1<spanclass="math inline">\(\quad\)</span>卢卡斯定理</h2><p><strong>卢卡斯定理</strong><spanclass="math inline">\(\quad\)</span>若 <spanclass="math inline">\(p\)</span> 是质数，则对于任意整数 <spanclass="math inline">\(1\leq m\leq n\)</span>，有： <spanclass="math display">\[\dbinom{n}{m}\equiv \dbinom{n\bmod p}{m\bmod p}\dbinom{n/p}{m/p}\pmod p\]</span></p><p>求解 <span class="math inline">\(\binom{n}{m}\bmod p\)</span>时，可以利用公式求解 <span class="math inline">\(\dbinom{n\bmodp}{m\bmod p}\bmod p\)</span>，同时递归求解 <spanclass="math inline">\(\dbinom{n/p}{m/p}\bmodp\)</span>，需要预处理出阶乘数组 <spanclass="math inline">\(a\)</span>，在计算 <spanclass="math inline">\(\dfrac{n!}{m!(n-m)!}\)</span> 时利用逆元求出。因为<span class="math inline">\(p\)</span>为质数，所以可以直接用快速幂方法求出逆元。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100005</span></span><br><span class="line">ll t,a[MAXN];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll p)</span></span>&#123;</span><br><span class="line">    ll w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) w=w*a%p;</span><br><span class="line">        a=a*a%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m,ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (a[n]*<span class="built_in">qpow</span>(a[m],p<span class="number">-2</span>,p)%p)*<span class="built_in">qpow</span>(a[n-m],p<span class="number">-2</span>,p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">lucas</span><span class="params">(ll n,ll m,ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(n%p,m%p,p)*<span class="built_in">lucas</span>(n/p,m/p,p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,m,p;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line">        a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++) a[i]=a[i<span class="number">-1</span>]*i%p;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">lucas</span>(n+m,m,p)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展卢卡斯定理">4.2 扩展卢卡斯定理</h2><p>此部分需要同余基础知识点，<del>貌似与卢卡斯定理没有任何关系</del>。</p><p>因为利用卢卡斯定理处理问题存在局限性（<spanclass="math inline">\(p\)</span>必须为质数），不能处理普遍情况。此时可以用扩展卢卡斯定理解决普遍情况。</p><p><strong>求解以下问题</strong>：对于组合数 <spanclass="math inline">\(\dbinom{n}{m}\)</span> ，求 <spanclass="math inline">\(\dbinom{n}{m}\bmod p\)</span> ，<spanclass="math inline">\(p\)</span> 不保证为质数。</p><p>如果 <span class="math inline">\(p\)</span>为质数会方便很多，所以考虑将其拆为若干个模质数的式子。根据唯一分解定理，<span class="math display">\[P=p_1^{a_1}p_2^{a_2}\cdots p_k^{a_k}\]</span> 所以考虑拆分为 <span class="math display">\[\begin{cases}x_1\equiv\dbinom{n}{m}&amp;\pmod {p_1^{a_1}}\\x_2\equiv\dbinom{n}{m}&amp;\pmod {p_2^{a_2}}\\&amp;\cdots\\x_k\equiv\dbinom{n}{m}&amp;\pmod {p_k^{a_k}}\end{cases}\]</span> 因为 <spanclass="math inline">\(\dbinom{n}{m}=\dfrac{n!}{m!(n-m)!}\)</span> ，在模<span class="math inline">\(p_1^{a_1}\)</span>意义下不能直接利用逆元化解分母。所以考虑如下拆分： <spanclass="math display">\[\dbinom{n}{m}\equiv\dfrac{n!}{m!(n-m)!}\equiv\dfrac{\dfrac{n!}{p^x}}{\dfrac{m!}{p^y}\cdot\dfrac{(n-m)!}{p^z}}\cdotp^{x-y-z}\pmod {p^k}\]</span> <span class="math inline">\(x\)</span> 为 <spanclass="math inline">\(n!\)</span> 中包含的 <spanclass="math inline">\(p\)</span> 的因子个数，<spanclass="math inline">\(y\)</span>、<span class="math inline">\(z\)</span>同理。</p><p>考虑逐个解决。因为 <span class="math inline">\(n!\)</span> 中一共有<spanclass="math inline">\(\left\lfloor\dfrac{n}{p}\right\rfloor\)</span>个数是 <span class="math inline">\(p\)</span>的倍数，然后递归处理其他因数。 <span class="math display">\[n!\equivp^{\left\lfloor\frac{n}{p}\right\rfloor}(\left\lfloor\frac{n}{p}\right\rfloor)!(\prod\limits_{i=1,i\not\equiv0\pmodp}^{n}i)\pmod{p^k}\]</span> 将 <spanclass="math inline">\(\prod\limits_{i=1,i\not\equiv0\pmodp}^{n}i\)</span> 拆分为两个部分：不含有 <spanclass="math inline">\(p\)</span> 的因子和含有 <spanclass="math inline">\(p\)</span> 的因子。 <span class="math display">\[n!\equivp^{\left\lfloor\frac{n}{p}\right\rfloor}(\left\lfloor\frac{n}{p}\right\rfloor)!(\prod\limits_{i=1,i\not\equiv0\pmodp}^{p^k}i)^{\left\lfloor\frac{n}{p^k}\right\rfloor}(\prod\limits_{i=p^k\left\lfloor\frac{n}{p^k}\right\rfloor,i\not\equiv0\pmodp}^{n}i)\pmod{p^k}\]</span> 所以考虑设立函数 <spanclass="math inline">\(f(n)=\dfrac{n!}{p^k}\)</span>，所以有 <spanclass="math display">\[f(n)\equiv\dfrac{n!}{p^k}\equivp^{\left\lfloor\frac{n}{p}\right\rfloor}(\left\lfloor\frac{n}{p}\right\rfloor)!(\prod\limits_{i=1,i\not\equiv0\pmodp}^{p^k}i)^{\left\lfloor\frac{n}{p^k}\right\rfloor}(\prod\limits_{i=p^k\left\lfloor\frac{n}{p^k}\right\rfloor,i\not\equiv0\pmodp}^{n}i)\pmod{p^k}\]</span> 边界：<span class="math inline">\(f(0)=1\)</span>。</p><p>这样函数 <span class="math inline">\(f\)</span> 就一定和 <spanclass="math inline">\(p^k\)</span>互质了，就可以直接利用扩展欧几里得算法（<spanclass="math inline">\(\text{exgcd}\)</span>）求出逆元（ <spanclass="math inline">\(\text{inv}\)</span> ），化分母。</p><p>然后还需要求解 <spanclass="math inline">\(p^{x-y-z}\)</span>。考虑设立函数 <spanclass="math inline">\(g(n)=x\)</span>（ <spanclass="math inline">\(x\)</span> 为 <spanclass="math inline">\(n!\)</span> 中包含的 <spanclass="math inline">\(p\)</span> 的因子数），所以有 <spanclass="math display">\[g(n)=\left\lfloor\frac{n}{p}\right\rfloor+g(\left\lfloor\dfrac{n}{p}\right\rfloor)\]</span> 边界：<span class="math inline">\(g(x)=0(x&lt;p)\)</span></p><p>这样就可以求解啦。式子变成了 <span class="math display">\[\dbinom{n}{m}\equiv\dfrac{f(n)}{f(m)f(n-m)}\cdotp^{g(n)-g(m)-g(n-m)}\pmod{p^k}\]</span> 然后用中国剩余定理（ <spanclass="math inline">\(\text{CRT}\)</span> ）合并即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 10005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n,m,P,A[MAXN],B[MAXN];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll p)</span></span>&#123;</span><br><span class="line">    ll w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) w=w*a%p;</span><br><span class="line">        a=a*a%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x,ll p,ll pk)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ll a=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=pk;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%p) a=a*i%pk;</span><br><span class="line">    &#125;</span><br><span class="line">    a=<span class="built_in">qpow</span>(a,x/pk,pk);</span><br><span class="line">    <span class="keyword">for</span>(ll i=pk*(x/pk);i&lt;=x;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%p) b=b*(i%pk)%pk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(x/p,p,pk)*a%pk*b%pk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll p)</span></span>&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a,p,x,y);</span><br><span class="line">    <span class="keyword">return</span> (x+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">g</span><span class="params">(ll x,ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x/p+<span class="built_in">g</span>(x/p,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">CmodPk</span><span class="params">(ll p,ll pk)</span></span>&#123;</span><br><span class="line">    ll fx=<span class="built_in">f</span>(n,p,pk),fy=<span class="built_in">f</span>(m,p,pk),fz=<span class="built_in">f</span>(n-m,p,pk);</span><br><span class="line">    fy=<span class="built_in">inv</span>(fy,pk),fz=<span class="built_in">inv</span>(fz,pk);</span><br><span class="line">    <span class="keyword">return</span> fx*fy%pk*fz%pk*<span class="built_in">qpow</span>(p,<span class="built_in">g</span>(n,p)-<span class="built_in">g</span>(m,p)-<span class="built_in">g</span>(n-m,p),pk)%pk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">crt</span><span class="params">(ll cnt)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        ll M=P/A[i];</span><br><span class="line">        ll T=<span class="built_in">inv</span>(M,A[i]);</span><br><span class="line">        ans=(ans+B[i]*M%P*T%P)%P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">exlucas</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll tmp=P,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=P;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp%i==<span class="number">0</span>)&#123;</span><br><span class="line">            ll pk=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(tmp%i==<span class="number">0</span>) pk*=i,tmp/=i;</span><br><span class="line">            A[++cnt]=pk;</span><br><span class="line">            B[cnt]=<span class="built_in">CmodPk</span>(i,pk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        A[++cnt]=tmp;</span><br><span class="line">        B[cnt]=<span class="built_in">CmodPk</span>(tmp,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">crt</span>(cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;P;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">exlucas</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同余</title>
      <link href="/post/2f4ed4efbf3d.html"/>
      <url>/post/2f4ed4efbf3d.html</url>
      
        <content type="html"><![CDATA[<p>同余</p><p>本章主要记录有关同余、费马小定理、欧拉定理、扩展欧几里得算法、裴蜀定理、乘法逆元、威尔逊定理、线性同余方程、中国剩余定理、扩展中国剩余定理、BSGS以及扩展BSGS的学习笔记。</p><p>由于内容复杂且关联较少，建议配备 <code>ctrl+F</code>进行快乐食用。</p><p>正在继更ing</p><h1 id="一基础知识">一、基础知识</h1><p>这个板块着重介绍同余的基本知识，虽然多为数学竞赛内容，但也对信息学竞赛有不少帮助，定理和性质为拓展内容。</p><p>本部分参考《初等数论》进行撰写。</p><h2 id="quad基本定义定理与性质">1.1<spanclass="math inline">\(\quad\)</span>基本定义、定理与性质</h2><p><strong>定义1</strong>（<strong>同余</strong>）<spanclass="math inline">\(\quad\)</span> 设 <spanclass="math inline">\(m\neq0\)</span>。若 <spanclass="math inline">\(m\mid a-b\)</span>，即 <spanclass="math inline">\(a-b=km\)</span>，则称 <spanclass="math inline">\(m\)</span> 为<strong>模</strong>，<spanclass="math inline">\(a\)</span> <strong>同于与</strong> <spanclass="math inline">\(b\)</span> <strong>模</strong> <spanclass="math inline">\(m\)</span> 以及 <spanclass="math inline">\(b\)</span> <strong>是</strong> <spanclass="math inline">\(a\)</span> <strong>对模</strong> <spanclass="math inline">\(m\)</span> <strong>的剩余</strong>，记作 <spanclass="math display">\[a\equiv b\pmod{m} \tag{1}\]</span> 不然，则称 <span class="math inline">\(a\)</span><strong>不同余于</strong> <span class="math inline">\(b\)</span><strong>模</strong> <span class="math inline">\(m\)</span>，<spanclass="math inline">\(b\)</span> <strong>不是</strong> <spanclass="math inline">\(a\)</span> <strong>对模</strong> <spanclass="math inline">\(m\)</span> <strong>的剩余</strong>，记作 <spanclass="math inline">\(a\not\equiv b\pmod{m}\)</span></p><p>式 <span class="math inline">\((1)\)</span> 称为<strong>模</strong><span class="math inline">\(m\)</span><strong>的同余式</strong>，或简称<strong>同余式</strong>。</p><p>由于 <span class="math inline">\(m\mid a-b\)</span> 等价于 <spanclass="math inline">\(-m\mid a-b\)</span> ，所以同余式 <spanclass="math inline">\((1)\)</span> 等价于</p><p><span class="math display">\[a\equiv b\pmod{(-m)}\]</span> <strong>定理1</strong><spanclass="math inline">\(\quad\)</span> <spanclass="math inline">\(a\)</span> 同余于 <spanclass="math inline">\(b\)</span> 模 <spanclass="math inline">\(m\)</span> 的充要条件是 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 被 <spanclass="math inline">\(m\)</span> 除后所得的最小非负余数相等，即若 <spanclass="math display">\[\begin{aligned}a=q_1m+r_1&amp;,0\leq r_1&lt;m\\b=q_2m+r_2&amp;,0\leq r_2&lt;m,\end{aligned}\]</span> 则 <span class="math inline">\(r_1=r_2\)</span>。</p><p><strong>性质Ⅰ</strong><span class="math inline">\(\quad\)</span>同余是一种等价关系，即有 <span class="math display">\[\begin{aligned}a\equiv a\pmod{m}\\a\equiv b\pmod{m}\iff b\equiv a\pmod{m}\\a\equiv b\pmod{m}\;,\;b\equiv c\pmod{m}\Rightarrow a\equiv c\pmod{m}\end{aligned}\]</span> <strong>性质Ⅱ</strong><spanclass="math inline">\(\quad\)</span> 同余式可以相加，即若有 <spanclass="math display">\[a\equiv b\pmod{m}\;,\;c\equiv d\pmod{m}\tag{2}\]</span></p><p>则有</p><p><span class="math display">\[a+c\equiv b+d\pmod m\]</span></p><p><strong>性质Ⅲ</strong><span class="math inline">\(\quad\)</span>同余式可以相乘，即若式 <span class="math inline">\((2)\)</span>成立，则</p><p><span class="math display">\[ac\equiv bd\pmod m\]</span></p><p><strong>性质Ⅳ</strong><span class="math inline">\(\quad\)</span> 设<span class="math inline">\(f(x)=a_nx^n+\cdots+a_0\)</span>，<spanclass="math inline">\(g(x)=b_nx^n+\cdots+b_0\)</span>是两个整系数多项式，满足</p><p><span class="math display">\[a_j\equiv b_j\pmod m\;,\;0\leq j&lt;n\tag{3}\]</span></p><p>那么，若 <span class="math inline">\(a\equiv b\pmodm\)</span>，则</p><p><span class="math display">\[f(a)\equiv g(b)\pmod m\]</span></p><p>特别地，<strong>对所有整数</strong> <spanclass="math inline">\(x\)</span> 有</p><p><span class="math display">\[f(x)\equiv g(x)\pmod m\tag{4}\]</span></p><p><strong>定义2</strong><span class="math inline">\(\quad\)</span> 设<span class="math inline">\(f(x)=a_nx^n+\cdots+a_0\)</span> 和 <spanclass="math inline">\(g(x)=b_nx^n+\cdots+b_0\)</span>是两个整系数多项式。当满足条件 <span class="math inline">\((3)\)</span>时，称<strong>多项式</strong> <span class="math inline">\(f(x)\)</span><strong>同余于多项式</strong> <span class="math inline">\(g(x)\)</span><strong>模</strong> <span class="math inline">\(m\)</span>，记作</p><p><span class="math display">\[f(x)\equiv g(x)\pmod m\]</span></p><p>当满足 <span class="math inline">\(f(x)\equiv g(x)\pmod m\)</span>时，称<strong>多项式</strong> <span class="math inline">\(f(x)\)</span><strong>等价于多项式</strong> <span class="math inline">\(g(x)\)</span><strong>模</strong> <span class="math inline">\(m\)</span>，式 <spanclass="math inline">\((4)\)</span>称为<strong>模</strong> <spanclass="math inline">\(m\)</span> <strong>的恒等同余式</strong></p><p><strong>性质Ⅴ</strong><span class="math inline">\(\quad\)</span> 设<span class="math inline">\(d\geq1\)</span>，<spanclass="math inline">\(d\mid m\)</span>，那么，若式 <spanclass="math inline">\((1)\)</span> 成立，则 <spanclass="math inline">\(a\equiv b\pmod d\)</span></p><p><strong>性质Ⅵ</strong><span class="math inline">\(\quad\)</span> 设<span class="math inline">\(d\not=0\)</span>，那么 <spanclass="math inline">\(a\equiv b\pmod m\)</span> 等价于 <spanclass="math inline">\(da\equiv db\pmod{\left\vert d\right\vertm}\)</span></p><p><strong>性质Ⅶ</strong><span class="math inline">\(\quad\)</span>同余式 <span class="math inline">\(ca\equiv cb\pmod m\)</span> 等价于<span class="math inline">\(a\equiv b\pmod{\fracm{\gcd(c,m)}}\)</span></p><p>特别地，当 <span class="math inline">\(\gcd(c,m)=1\)</span>时，上述同余式等价于 <span class="math inline">\(a\equiv b\pmodm\)</span></p><p><strong>性质Ⅷ</strong><span class="math inline">\(\qquad\)</span> 若<span class="math inline">\(m\geq1\)</span>，<spanclass="math inline">\(\gcd(a,m)=1\)</span>，则存在 <spanclass="math inline">\(c\)</span> 使得</p><p><span class="math display">\[ca\equiv1\pmod m\tag{5}\]</span></p><p><strong>定义3</strong><span class="math inline">\(\quad\)</span>若存在 <span class="math inline">\(m\geq1\)</span>，<spanclass="math inline">\(\gcd(a,m)=1\)</span>，且满足式 <spanclass="math inline">\((5)\)</span>，我们把 <spanclass="math inline">\(c\)</span> 称为 <spanclass="math inline">\(a\)</span> 对模 <spanclass="math inline">\(m\)</span> 的逆，记作 <spanclass="math inline">\(a^{-1}\pmod m\)</span> 或 <spanclass="math inline">\(a^{-1}\)</span></p><p><strong>性质Ⅸ</strong><span class="math inline">\(\quad\)</span>同余式组</p><p><span class="math display">\[a\equiv b\pmod{m_j}\;,\;j=1,2,\cdots,k\]</span></p><p>同时成立的充要条件是</p><p><span class="math display">\[a\equiv b\pmod{[m_1,m_2,\cdots,m_k]}\]</span></p><h2 id="quad同余类与剩余系">1.2<spanclass="math inline">\(\quad\)</span>同余类与剩余系</h2><p><strong>定义4（同余类和剩余系）</strong><spanclass="math inline">\(\quad\)</span> 对于 <spanclass="math inline">\(\forall a\in [0,m-1]\)</span>，集合 <spanclass="math inline">\(\{a+km\}(k\in\mathbb{Z})\)</span> 的所有数模 <spanclass="math inline">\(m\)</span> 同余，余数都是 <spanclass="math inline">\(a\)</span>，该集合成为模 <spanclass="math inline">\(m\)</span> 的<strong>同余类</strong>，简记为 <spanclass="math inline">\(\overline{a}\)</span>。</p><p>模 <span class="math inline">\(m\)</span> 的同余类一共有 <spanclass="math inline">\(m\)</span> 个，分别为 <spanclass="math inline">\(\overline{0},\overline{1},\overline{2},\cdots,\overline{m-1}\)</span>。它们构成<span class="math inline">\(m\)</span>的<strong>完全剩余系</strong>。</p><p><span class="math inline">\(1\sim m\)</span> 中与 <spanclass="math inline">\(m\)</span> 互质的数代表的同余类共有 <spanclass="math inline">\(\phi(m)\)</span> 个，它们构成 <spanclass="math inline">\(m\)</span> 的<strong>简化剩余系</strong>。</p><h1 id="二费马小定理和欧拉定理">二、费马小定理和欧拉定理</h1><p>前置芝士：欧拉函数。</p><p>利用同余基本知识和欧拉函数，即可证明费马小定理和欧拉定理。</p><h2 id="quad费马小定理">2.1<spanclass="math inline">\(\quad\)</span>费马小定理</h2><p><strong>定理2（费马小定理）</strong><spanclass="math inline">\(\quad\)</span> 若 <spanclass="math inline">\(p\)</span> 是质数，则对于任意整数 <spanclass="math inline">\(a\)</span>，有</p><p><span class="math display">\[a^p\equiv a\pmod p\]</span></p><h2 id="quad欧拉定理">2.2<spanclass="math inline">\(\quad\)</span>欧拉定理</h2><p><strong>定理3（欧拉定理）</strong><spanclass="math inline">\(\quad\)</span> 若正整数 <spanclass="math inline">\(a,n\)</span> 互质，则</p><p><span class="math display">\[a^{\phi(n)}\equiv1\pmod n\]</span></p><p>其中，<span class="math inline">\(\phi(n)\)</span> 为欧拉函数。</p><p>特别地，当 <span class="math inline">\(p\)</span> 是质数时，<spanclass="math inline">\(\phi(p)=p-1\)</span>，并且只有 <spanclass="math inline">\(p\)</span> 的倍数与 <spanclass="math inline">\(p\)</span> 不互质，所以，只要 <spanclass="math inline">\(a\)</span> 不是 <spanclass="math inline">\(p\)</span> 的倍数，就有</p><p><span class="math display">\[a^{p-1}\equiv1\pmod p\]</span></p><p>两边同乘 <span class="math inline">\(a\)</span> 就是费马小定理。</p><p><strong>证</strong><span class="math inline">\(\quad\)</span> 设<span class="math inline">\(n\)</span> 的简化剩余系为 <spanclass="math inline">\(\{\overline{a_1},\overline{a_2},\cdots,\overline{a_{\phi(n)}}\}\)</span>。对于<span class="math inline">\(\forall a_i,a_j\)</span>，若 <spanclass="math inline">\(a\times a_i\equiv a\times a_j\pmod n\)</span>，则<span class="math inline">\(a\times(a_i-a_j)\equiv 0\)</span>。因为<span class="math inline">\(a,n\)</span> 互质，所以 <spanclass="math inline">\(a_i-a_j\equiv 0\)</span>，即 <spanclass="math inline">\(a_i\equiv a_j\)</span>。故当 <spanclass="math inline">\(a_i\not=a_j\)</span> 时，<spanclass="math inline">\(aa_1,aa_j\)</span> 也代表不同的同余类。</p><p>又因为简化剩余系关于模 <span class="math inline">\(n\)</span>乘法封闭，故 <span class="math inline">\(\overline{aa_1}\)</span>也在简化剩余系集合中。因此，集合 <spanclass="math inline">\(\{\overline{a_1},\overline{a_2},\cdots,\overline{a_{\phi(n)}}\}\)</span>与集合 <spanclass="math inline">\(\{\overline{aa_1},\overline{aa_2},\cdots,\overline{aa_{\phi(n)}}\}\)</span>都能表示 <span class="math inline">\(n\)</span> 的简化剩余系，故有</p><p><span class="math display">\[a^{\phi(n)}\prod\limits_{i=1}^{\phi(n)}a_i\equiv\prod\limits_{i=1}^{\phi(n)}aa_i\equiv\prod\limits_{i=1}^{\phi(n)}a_i\pmod n\]</span></p><p>两边同时除以 <spanclass="math inline">\(\prod\limits_{i=1}^{\phi(n)}a_i\)</span> 可得</p><p><span class="math display">\[a^{\phi(n)}\equiv1\pmod n\]</span></p><p>当 <span class="math inline">\(p\)</span> 为质数时，<spanclass="math inline">\(\phi(p)=p-1\)</span>，并且只有 <spanclass="math inline">\(p\)</span> 的倍数与 <spanclass="math inline">\(p\)</span> 不互质。所以，只要 <spanclass="math inline">\(a\)</span> 不是 <spanclass="math inline">\(p\)</span> 的倍数，<spanclass="math inline">\(a^{p-1}\equiv1\pmod p\)</span> 显然成立。两边同乘<span class="math inline">\(a\)</span> 即费马小定理。</p><p><strong>证毕。</strong></p><h2 id="quad欧拉定理的推论">2.3<spanclass="math inline">\(\quad\)</span>欧拉定理的推论</h2><p><strong>推论1（欧拉定理推论）</strong><spanclass="math inline">\(\quad\)</span> 若正整数 <spanclass="math inline">\(a,n\)</span> 互质，则对于任意正整数 <spanclass="math inline">\(b\)</span>，有</p><p><span class="math display">\[a^b\equiv a^{b\mod{\phi(n)}}\pmodn\]</span></p><p><strong>证</strong><span class="math inline">\(\quad\)</span> 设<span class="math inline">\(b=q\times\phi(n)+r\)</span>，其中 <spanclass="math inline">\(0\leq r&lt;\phi(n)\)</span>，即 <spanclass="math inline">\(r=b\mod{\phi(n)}\)</span>。利用欧拉定理有</p><p><span class="math display">\[a^b\equiv a^{q\times\phi(n)+r}\equiv(a^{\phi(n)})^q\times a^r\equiv1^q\times a^r\equiv a^r\equiv a^{b\mod{\phi(n)}+\phi(n)}\pmod n\]</span></p><p><strong>证毕。</strong></p><p>特别地，当 <span class="math inline">\(a,n\)</span> 不一定互质且<span class="math inline">\(b&gt;\phi(n)\)</span> 时，有</p><p><span class="math display">\[a^b\equiv a^{b\mod{\phi(n)+\phi(n)}}\pmod n\]</span></p><h2 id="quad光速幂">2.4<spanclass="math inline">\(\quad\)</span>光速幂</h2><p>给定 <span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(c\)</span>，每次询问给出 <spanclass="math inline">\(b\)</span>，求 <spanclass="math inline">\(a^b\bmod c\)</span>。</p><p>我们可以先运用 <span class="math inline">\(a^b\bmod a^{b\bmod\phi(n)+\phi(n)}\pmod c\)</span>，将 <spanclass="math inline">\(b\)</span> 缩小到 <spanclass="math inline">\(2\phi(c)(&lt;2c)\)</span> 的范围，有</p><p><span class="math display">\[a^b=(a^{\sqrt c})^{\left\lfloor\frac{b}{\sqrt c}\right\rfloor}\timesa^{b\bmod \sqrt c}\]</span></p><p>其中，<span class="math inline">\(\frac{b}{\sqrt c}&lt;2\sqrtc\)</span>，<span class="math inline">\(b\bmod \sqrt c&lt;\sqrtc\)</span></p><p>我们预处理 <span class="math inline">\((a^{\sqrt c})^i\)</span> 和<span class="math inline">\(a^j\)</span> 即可 <spanclass="math inline">\(O(\sqrt c)\)</span> 预处理，<spanclass="math inline">\(O(1)\)</span> 回答询问。</p><h1 id="三扩展欧几里得算法">三、扩展欧几里得算法</h1><p>前置芝士：欧几里得算法。</p><p>本部分着重介绍扩展欧几里得算法、裴蜀定理和乘法逆元相关知识。</p><h2 id="quad裴蜀定理">3.1<spanclass="math inline">\(\quad\)</span>裴蜀定理</h2><p><strong>定理4（裴蜀定理）</strong> <spanclass="math inline">\(\quad\)</span> <span class="math inline">\(\foralla,b\in\mathbb{Z}\)</span>，一定存在一组 <spanclass="math inline">\(x,y\in\mathbb{Z}\)</span>，满足</p><p><span class="math display">\[ax+by=\gcd(a,b)\]</span></p><p><strong>证</strong><span class="math inline">\(\qquad\)</span>在欧几里得算法的最后一步，即 <span class="math inline">\(b=0\)</span>时，我们一定会得出一组整数 <spanclass="math inline">\(\begin{cases}x=1\\b=0\end{cases}\)</span>，使得<span class="math inline">\(a\times1+0\times0=\gcd(a,0)\)</span>。</p><p>由欧几里得算法得 <span class="math inline">\(\gcd(a,b)=\gcd(b,a\bmodb)\)</span>。假设存在一组整数 <spanclass="math inline">\(x,y\)</span>，满足 <spanclass="math inline">\(bx+(a\bmod b)y=\gcd(b,a\bmod b)\)</span>。</p><p>因为 <span class="math inline">\(bx+(a\bmod b)y\)</span></p><p><span class="math inline">\(\begin{aligned}\;\;&amp;=bx+(a-b\left\lfloor\dfrac{a}{b}\right\rfloor)y \\&amp;=bx+ay-b\left\lfloor\dfrac{a}{b}\right\rfloor y \\&amp;=ay+b(x-b\left\lfloor\dfrac{a}{b}\right\rfloor)\end{aligned}\)</span></p><p>所以，令 <span class="math inline">\(x&#39;=y\)</span>，<spanclass="math inline">\(y&#39;=x-\left\lfloor\dfrac{a}{b}\right\rfloory\)</span>，就得到了 <spanclass="math inline">\(ax&#39;+by&#39;=\gcd(a,b)\)</span>。</p><p>对以上过程应用数学归纳法，可知裴蜀定理一定成立。</p><p><strong>证毕。</strong></p><h2 id="quad扩展欧几里得算法">3.2<spanclass="math inline">\(\quad\)</span>扩展欧几里得算法</h2><p>上面证明的过程中，我们通过 <span class="math inline">\(ax+(a\bmodb)y=\gcd(a,b)\)</span> 推出了 <spanclass="math inline">\(ax&#39;+by&#39;=\gcd(a,b)\)</span>。按照欧几里得算法的思路，并给出整数<span class="math inline">\(x\)</span> 和整数 <spanclass="math inline">\(y\)</span>的计算方法成为<strong>扩展欧几里得算法</strong>。</p><p>下面给出扩展欧几里得算法过程：</p><ol type="1"><li><p>给定 <span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span>，递归 <spanclass="math inline">\(\operatorname{exgcd}(a,b)\)</span>；</p></li><li><p>是否 <span class="math inline">\(b=0\)</span>。如果是，返回 <spanclass="math inline">\(\begin{cases}x=1\\y=0\end{cases}\)</span>；如果不是，递归<span class="math inline">\(\operatorname{exgcd}(b,a\bmodb)\)</span>，并重复进行1和2操作，直至条件成立；</p></li><li><p>每次递归结束后，计算 <spanclass="math inline">\(\begin{cases}x&#39;=y\\y&#39;=x-\left\lfloor\dfrac{a}{b}\right\rfloory\end{cases}\)</span>。</p></li></ol><p>也可以在算法过程中顺便记录 <spanclass="math inline">\(\gcd(a,b)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll&amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d=<span class="built_in">exgcd</span>(b,a%b,x,y);</span><br><span class="line">    ll temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a,b,x,y;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">ll d=<span class="built_in">exgcd</span>(a,b,x,y);</span><br></pre></td></tr></table></figure><p>上述程序求出方程 <span class="math inline">\(ax+by=\gcd(a,b)\)</span>的一组特解 <span class="math inline">\(x_0,y_0\)</span>，并返回 <spanclass="math inline">\(\gcd(a,b)\)</span>，即 <spanclass="math inline">\(d\)</span>。</p><p>对于方程 <span class="math inline">\(ax+by=c\)</span>，当且仅当 <spanclass="math inline">\(d\mid c\)</span> 时有解。我们可以求出 <spanclass="math inline">\(ax+by=d\)</span> 的一组特解 <spanclass="math inline">\(x_0,y_0\)</span>，然后令 <spanclass="math inline">\(x_0,y_0\)</span> 同时乘上 <spanclass="math inline">\(\dfrac{c}{d}\)</span>，就得到了<strong>方程</strong><span class="math inline">\(ax+b=c\)</span> <strong>的特解</strong></p><p><span class="math display">\[\dfrac{c}{d}x_0\;,\;\dfrac{c}{d}y_0\]</span></p><p>对于方程 <spanclass="math inline">\(ax+by=d\)</span>，我们将其特解表示为 <spanclass="math inline">\(x_0,y_0\)</span>，有 <spanclass="math inline">\(a(x+m)+b(y-n)=ax+by+am-bn=d\)</span>。因为 <spanclass="math inline">\(ax+by=d\)</span>，可以推出 <spanclass="math inline">\(am-bn=0\Rightarrow am=bn\Rightarrow\dfrac{a}{b}=\dfrac{n}{m}\)</span>。由于 <spanclass="math inline">\(\gcd(a,b)=d\)</span>，故 <spanclass="math inline">\(m\)</span> 和 <spanclass="math inline">\(n\)</span> 最小只能取 <spanclass="math inline">\(\dfrac{b}{d}\)</span> 和 <spanclass="math inline">\(\dfrac{a}{d}\)</span>，能保证 <spanclass="math inline">\(m\)</span> 和 <spanclass="math inline">\(n\)</span> 为整数。所以，<strong>方程</strong><span class="math inline">\(ax+by=d\)</span><strong>的通解</strong>为</p><p><span class="math display">\[\begin{cases}x_1=x_0+\dfrac{b}{d}k\\\\y_1=y_0-\dfrac{a}{d}k\end{cases}(k\in\mathbb{Z})\]</span></p><h2 id="quad线性同余方程">3.3<spanclass="math inline">\(\quad\)</span>线性同余方程</h2><p>给定整数 <span class="math inline">\(a,b,m\)</span>，求一个整数 <spanclass="math inline">\(x\)</span> 满足 <spanclass="math inline">\(ax\equiv b\pmod m\)</span>，或者给出无解。</p><p><strong>定义5（线性同余方程）</strong><spanclass="math inline">\(\qquad\)</span> 在整数域内，关于 <spanclass="math inline">\(x\)</span> 的同余方程 <spanclass="math inline">\(ax\equiv b\pmod m\)</span>称为<strong>一次同余方程</strong>，也称<strong>线性同余方程</strong>。</p><p><span class="math inline">\(ax\equiv b\pmod m\)</span> 等价于 <spanclass="math inline">\(m\mid (ax-b)\)</span>，一定存在一个整数 <spanclass="math inline">\(k\)</span>，有 <spanclass="math inline">\(ax+mk=b\)</span>。我们可以利用扩展欧几里得算法对其进行计算。</p><h2 id="quad乘法逆元">3.4<spanclass="math inline">\(\quad\)</span>乘法逆元</h2><p><strong>定义6（乘法逆元）</strong><spanclass="math inline">\(\qquad\)</span> 若整数 <spanclass="math inline">\(b,m\)</span> 互质，并且 <spanclass="math inline">\(b\mid a\)</span>，则存在一个整数 <spanclass="math inline">\(x\)</span>，使得 <spanclass="math inline">\(\dfrac{a}{b}\equiv ax\pmod m\)</span>。称 <spanclass="math inline">\(x\)</span> 为 <spanclass="math inline">\(b\)</span> <strong>的模</strong> <spanclass="math inline">\(m\)</span> <strong>乘法逆元</strong>，记为 <spanclass="math inline">\(b^{-1}\pmod m\)</span>。</p><p>因为 <span class="math inline">\(\dfrac{a}{b}\equiv a\timesb^{-1}\equiv\dfrac{a}{b}\times b\times b^{-1}\pmod m\)</span>，所以<span class="math inline">\(b\times b^{-1}\equiv1\pmod m\)</span>。</p><p>下面是一些求解乘法逆元的方法。</p><p><strong>方法一：解线性同余方程求解乘法逆元</strong></p><p>如果只保证 <span class="math inline">\(b,m\)</span>互质，那么乘法逆元可以通过求解同余方程 <spanclass="math inline">\(bx\equiv1\pmod m\)</span>得到。算法过程已在上文中提及，不再赘述。</p><p><strong>方法二：快速幂求解乘法逆元</strong></p><p>本方法使用有前提条件。</p><p>如果 <span class="math inline">\(m\)</span> 是质数，并用 <spanclass="math inline">\(p\)</span> 表示 <spanclass="math inline">\(m\)</span>，并且 <spanclass="math inline">\(b&lt;p\)</span>，根据费马小定理， <spanclass="math inline">\(b^{p-1}\equiv1\pmod p\)</span>，即</p><p><span class="math display">\[b\times b^{p-2}\equiv1\pmod p\]</span></p><p>因此，<strong>当模数</strong> <span class="math inline">\(p\)</span><strong>为质数时，</strong><span class="math inline">\(b^{p-2}\)</span><strong>即为</strong> <span class="math inline">\(b\)</span><strong>的乘法逆元</strong>。</p><p>我们直接对 <span class="math inline">\(b^{p-2}\)</span>进行快速幂计算即可得到答案。</p><p><strong>方法三：线性求解乘法逆元</strong></p><p>给定 <span class="math inline">\(n,p\)</span>，求出 <spanclass="math inline">\(1,2,\cdots,n\)</span> 在模 <spanclass="math inline">\(p\)</span> 意义下的乘法逆元。</p><p>显而易见，<span class="math inline">\(1^{-1}\equiv1\pmodp\)</span>。</p><p>假设当我们递归到 <span class="math inline">\(i(i&gt;1)\)</span>时已经把前 <span class="math inline">\(i-1\)</span>个的乘法逆元算出来了，我们设 <span class="math inline">\(j=p\bmodi\)</span>，<spanclass="math inline">\(k=\left\lfloor\dfrac{p}{i}\right\rfloor\)</span>，有<span class="math inline">\(p=ki+j\)</span>，即</p><p><span class="math display">\[ki+j\equiv 0\pmod p\]</span></p><p>两边同乘 <span class="math inline">\(i^{-1}j^{-1}\)</span> 得</p><p><span class="math display">\[\begin{aligned}kj^{-1}+i^{-1}&amp;\equiv0\pmod p\\i^{-1}&amp;\equiv kj^{-1}\pmod p\\i^{-1}&amp;\equiv \left\lfloor\dfrac{p}{i}\right\rfloor(p\bmodi)^{-1}\pmod p\end{aligned}\]</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;p);</span><br><span class="line">    inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        inv[i]=(<span class="type">long</span> <span class="type">long</span>)(p - p / i) * inv[p % i] % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,inv[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法四：线性求解任意 <span class="math inline">\(n\)</span>个数的逆元</strong></p><p>任意给定 <span class="math inline">\(n\)</span> 个数 <spanclass="math inline">\(a_1,a_2,\cdots,a_n\)</span>，求它们在模 <spanclass="math inline">\(p\)</span> 意义下的乘法逆元，其中，<spanclass="math inline">\(p\)</span> 为质数。</p><p>我们设</p><p><span class="math display">\[s_i=\prod_{i=1}^ia_i\]</span></p><p>通过快速幂或者扩展欧几里得算法求得 <spanclass="math inline">\(s_i\)</span> 的乘法逆元记为 <spanclass="math inline">\(sv_i\)</span>，即</p><p><span class="math display">\[sv_i=s_i^{-1}\pmod p\]</span></p><p>我们将 <span class="math inline">\(sv_1\)</span> 乘上 <spanclass="math inline">\(a_i\)</span>，会与 <spanclass="math inline">\(a_i^{-1}\pmod p\)</span> 相消，得</p><p><span class="math display">\[a_i\times sv_1=sv_{i-1}\]</span></p><p>我们就能递推线性求解乘法逆元。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ll n,p,k,a[MAXN],s[MAXN],t[MAXN];</span><br><span class="line">ll ans=<span class="number">0</span>,temp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(<span class="type">long</span> <span class="type">long</span>)ans*a%mod;</span><br><span class="line">        a=(<span class="type">long</span> <span class="type">long</span>)a*a%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    s[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    t[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]*a[i]%p;</span><br><span class="line">    &#125;</span><br><span class="line">    t[n+<span class="number">1</span>]=<span class="built_in">qpow</span>(s[n],p<span class="number">-2</span>,p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)&#123;</span><br><span class="line">        t[i]=t[i+<span class="number">1</span>]*a[i]%p;</span><br><span class="line">    &#125;</span><br><span class="line">    temp=k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=(ans+(t[i+<span class="number">1</span>]*s[i<span class="number">-1</span>]%p)*temp)%p;</span><br><span class="line">        temp=temp*k%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quad威尔逊定理">3.5<spanclass="math inline">\(\quad\)</span>威尔逊定理</h2><p><strong>定理5（威尔逊定理）</strong><spanclass="math inline">\(\quad\)</span> 对于任意素数 <spanclass="math inline">\(p\)</span>，有 <spanclass="math inline">\((p-1)!\equiv-1\pmod p\)</span>。</p><p><strong>证</strong><span class="math inline">\(\quad\)</span>我们知道，<span class="math inline">\(x^2\equiv1\pmod p\)</span>的解只有 <span class="math inline">\(x\equiv\pm1\pmod p\)</span>，所以<span class="math inline">\(2\sim p-2\)</span> 和逆元两两对应。剩下<span class="math inline">\(1\times (p-1)\equiv -1\pmod p\)</span>。</p><p><strong>证毕。</strong></p><h1 id="四中国剩余定理">四、中国剩余定理</h1><p>前置芝士：乘法逆元。</p><p>本节主要介绍有关中国剩余定理和扩展中国剩余定理，是解决线性同余方程组问题的重要方法。</p><h2 id="quad中国剩余定理">4.1<spanclass="math inline">\(\quad\)</span>中国剩余定理</h2><p><strong>定理6（中国剩余定理，孙子定理）</strong><spanclass="math inline">\(\quad\)</span> 设 <spanclass="math inline">\(m_1,m_2,\cdots,m_n\)</span>是两两互质的整数，<spanclass="math inline">\(m=\prod_{i=1}^n{m_i}\)</span>，<spanclass="math inline">\(M_i=m/m_i\)</span>，<spanclass="math inline">\(t_i\)</span> 是线性同余方程 <spanclass="math inline">\(M_it_i\equiv1\pmod{m_i}\)</span>的一个解。对于任意的 <span class="math inline">\(n\)</span>个整数 <spanclass="math inline">\(a_1,a_2,\cdots,a_n\)</span>，方程组</p><p><span class="math display">\[\begin{cases}x\equiv a_1\pmod{m_1}\\x\equiv a_2\pmod{m_2}\\\cdots\\x\equiv a_n\pmod{m_n}\end{cases}\]</span></p><p>有整数解，解为 <spanclass="math inline">\(x=\sum_{i=1}^na_iM_it_i\)</span>。</p><p><strong>证</strong><span class="math inline">\(\quad\)</span> 因为<span class="math inline">\(M_i=m/m_i\)</span> 是除 <spanclass="math inline">\(m_i\)</span> 之外所有模数的倍数，所以 <spanclass="math inline">\(\forallk\not=i\;,\;a_iM_it_i\equiv0\pmod{m_k}\)</span>。又因为 <spanclass="math inline">\(a_iM_it_i\equiv a_i\pmod{m_i}\)</span>，所以代入<spanclass="math inline">\(x=\sum_{i=1}^na_iM_it_i\)</span>，原方程组成立。</p><p><strong>证毕。</strong></p><p>按照中国剩余定理，我们可以计算线性同余方程组的一个通解（最小解）。另外，我们可以用扩展欧几里得算法求解逆元。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,a[MAXN],m[MAXN];</span><br><span class="line">ll M,ans,summ[MAXN];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line">    ll w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) w=w*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    M=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;m[i]&gt;&gt;a[i];</span><br><span class="line">        M*=m[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) summ[i]=M/m[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">exgcd</span>(summ[i],m[i],x,y);</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x+=m[i];</span><br><span class="line">        ans+=a[i]*summ[i]*x;</span><br><span class="line">        ans%=M;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quad扩展中国剩余定理">4.2<spanclass="math inline">\(\quad\)</span>扩展中国剩余定理</h2><p>中国剩余定理只能处理模数两两互质的情况，无法处理普遍情况。我们可以使用扩展中国剩余定理进行推算。</p><p>对于每两个线性同余方程组 <span class="math inline">\(x\equiv a_1\pmod{m_1}\;,\;x\equiv a_2\pmod{m_2}\)</span>，将其转化为不定方程 <spanclass="math inline">\(x=pm_1+a_1=qm_2+a_2\)</span>，移项有</p><p><span class="math display">\[pm_1-qm_2=a_2-a_1\]</span></p><p>有裴蜀定理得，方程组有整数解当且仅当 <spanclass="math inline">\(\gcd(m_1,m_2)|(a_2-a_1)\)</span>。这时我们就可以用扩展欧几里得算法得到一组可行解<spanclass="math inline">\((p,q)\)</span>，则原来的两个方程可以合并为</p><p><span class="math display">\[x\equiv m_1p+a_1\pmod{\text{lcm}(m_1,m_2)}\]</span></p><p>我们逐一进行合并即可求解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __int128 ll;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    ll a,m;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; qu;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll&amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d=<span class="built_in">exgcd</span>(b,a%b,x,y);</span><br><span class="line">    ll temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">lcm</span><span class="params">(ll x,ll y,ll d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x/d*y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        qu.<span class="built_in">push</span>(node&#123;b,a&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        node a,b;</span><br><span class="line">        a=qu.<span class="built_in">front</span>();qu.<span class="built_in">pop</span>();</span><br><span class="line">        b=qu.<span class="built_in">front</span>();qu.<span class="built_in">pop</span>();</span><br><span class="line">        ll k1,k2;</span><br><span class="line">        <span class="keyword">if</span>(a.a&gt;b.a) <span class="built_in">swap</span>(a,b);</span><br><span class="line">        ll c=b.a-a.a;</span><br><span class="line">        ll d=<span class="built_in">exgcd</span>(a.m,b.m,k1,k2);</span><br><span class="line">        k1*=c/d;</span><br><span class="line">        k2*=c/d;</span><br><span class="line">        ll q=b.m/d,p=a.m/d;</span><br><span class="line">        <span class="keyword">if</span>(k1&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            ll k=<span class="built_in">ceil</span>((<span class="number">1.0</span>-k1)/q);</span><br><span class="line">            k1+=k*q;</span><br><span class="line">            k2-=k*p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ll k=(k1<span class="number">-1</span>)/q;</span><br><span class="line">            k1-=k*q;</span><br><span class="line">            k2+=k*p;</span><br><span class="line">        &#125;</span><br><span class="line">        node now;</span><br><span class="line">        now.a=k1*a.m+a.a;</span><br><span class="line">        now.m=q*a.m;</span><br><span class="line">        now.a%=now.m;</span><br><span class="line">        qu.<span class="built_in">push</span>(now);</span><br><span class="line">    &#125;</span><br><span class="line">    node ans=qu.<span class="built_in">front</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(<span class="type">long</span> <span class="type">long</span>)(ans.a%ans.m));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五高次同余方程与bsgs算法">五、高次同余方程与BSGS算法</h1><h2 id="quadbsgs算法">5.1<spanclass="math inline">\(\quad\)</span>BSGS算法</h2><p>给定 <span class="math inline">\(a,b,p\)</span>，已知 <spanclass="math inline">\(a\perp p\)</span>，求解 <spanclass="math inline">\(x\)</span> 满足</p><p><span class="math display">\[a^x\equiv b\pmod p\]</span></p><p>令 <span class="math inline">\(x=A\left\lceil\sqrtp\right\rceil-B\)</span>，其中， <span class="math inline">\(0\leqA,B\leq \left\lceil\sqrt p\right\rceil\)</span>，有 <spanclass="math inline">\(a^{A\left\lceil\sqrt p\right\rceil-B}\equiv b\pmodp\)</span>，整理得</p><p><span class="math display">\[a^{A\left\lceil\sqrt p\right\rceil}\equiv ba^B\pmod p\]</span></p><p>我们逐一枚举 <span class="math inline">\(B\)</span> 即可知道所有<span class="math inline">\(ba^B\)</span>。然后建立 <code>hash</code>表，逐一计算 <span class="math inline">\(a^{A\left\lceil\sqrtp\right\rceil}\)</span>，找到与之相等的 <spanclass="math inline">\(ba^B\)</span> 即可求出 <spanclass="math inline">\(x=A\left\lceil\sqrt p\right\rceil-B\)</span>。</p><p>时间复杂度 <span class="math inline">\(O(\sqrt p)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">BSGS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    map&lt;ll,ll&gt; hash;</span><br><span class="line">    hash.<span class="built_in">clear</span>();</span><br><span class="line">    b%=p;</span><br><span class="line">    ll t=<span class="built_in">sqrt</span>(p)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">        ll val=b*<span class="built_in">qpow</span>(a,i,p)%p;</span><br><span class="line">        hash[val]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    a=<span class="built_in">qpow</span>(a,t,p);</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">return</span> (b==<span class="number">0</span>?<span class="number">1</span>:<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=t;i++)&#123;</span><br><span class="line">        ll val=<span class="built_in">qpow</span>(a,i,p);</span><br><span class="line">        ll j=hash.<span class="built_in">find</span>(val)==hash.<span class="built_in">end</span>()?<span class="number">-1</span>:hash[val];</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span>&amp;&amp;i*t-j&gt;=<span class="number">0</span>) <span class="keyword">return</span> i*t-j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基环树</title>
      <link href="/post/e57ca2fa6cfe.html"/>
      <url>/post/e57ca2fa6cfe.html</url>
      
        <content type="html"><![CDATA[<p>基环树</p><h1 id="一基本概念">一、基本概念</h1><p>如果一张无向连通图包含恰好一个环，则称它是一棵<strong>基环树(Pseudotree)</strong>。</p><p>如果一张有向弱连通图每个点的入度都为 ，则称它是一棵<strong>基环外向树</strong>。</p><p>如果一张有向弱连通图每个点的出度都为 ，则称它是一棵<strong>基环内向树</strong>。</p><p>多棵树可以组成一个<strong>森林(Forest)</strong>，多棵基环树可以组成<strong>基环森林(Pseudoforest)</strong>，多棵基环外向树可以组成<strong>基环外向树森林</strong>，多棵基环内向树可以组成<strong>基环内向森林(Functionalgraph)</strong> 。</p><h1 id="二算法实现">二、算法实现</h1><p>在基环树中，有许多独一无二的性质，这也就成为<del>良心</del>出题人增加题目难度的一种措施。通常会结合<strong>树的直径</strong>进行考察。</p><p>下面就一些例题进行分析</p><p>下面以 <a href="https://www.luogu.com.cn/problem/P4381">[IOI2008]Island</a> 举例。</p><pre><code>题目大意：现有一个基环森林，求出森林中每颗基环树的直径的和。</code></pre><p>基环树直径，就是图中最长链的长度。因为基环树的一些特性，这也成为常考点。显然，基环树的最长链可能有两种情况：</p><ul><li><p>在去掉“环”的某棵子树中。</p></li><li><p>经过“环”，其两端分别在去掉“环”上所有边之后的两颗不同子树中。</p></li></ul><p>我们可以先用一次dfs找出基环树中的“环”，把“环”上的节点做标记，并用数组<code>ring[]</code> 记录。设环上的节点为 <spanclass="math inline">\(s_1,s_2,\cdots,s_t\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> last)</span></span>&#123;<span class="comment">//用bool数组进行记录：true表示在环上；false表示不在环上</span></span><br><span class="line">    <span class="keyword">if</span>(temp[x]==<span class="number">1</span>)&#123;<span class="comment">//如果这个点被访问过，说明是环的衔接点，记录，停止深入搜索</span></span><br><span class="line">        temp[x]=<span class="number">2</span>;</span><br><span class="line">        ring[++cnt]=x;</span><br><span class="line">        c[x]=<span class="number">1</span>;<span class="comment">//标记这个点已访问</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp[x]=<span class="number">1</span>;<span class="comment">//标记这个点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="type">int</span> y=to[i];</span><br><span class="line">        <span class="keyword">if</span>(i!=(last^<span class="number">1</span>)&amp;&amp;<span class="built_in">dfs</span>(y,i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[x]!=<span class="number">2</span>)&#123;<span class="comment">//如果这个点不是环的衔接点</span></span><br><span class="line">                c[x]=<span class="number">1</span>;</span><br><span class="line">                ring[++cnt]=x;</span><br><span class="line">                s[cnt]=s[cnt<span class="number">-1</span>]+edge[i];<span class="comment">//前缀和记录（后面会提到）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//如果这个点是环的衔接点</span></span><br><span class="line">                s[start<span class="number">-1</span>]=s[start]-edge[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从每个 <span class="math inline">\(s_i\)</span>出发，在不经过环上其他节点的前提下，再次执行dfs，即可访问去掉“环”之后以<span class="math inline">\(s_i\)</span>为根的子树。在这样的每棵子树中，按照求树的直径的方法进行树形DP并更新答案，即可处理第一种情况。同时，还可以计算出<span class="math inline">\(d[s_i]\)</span>，表示从节点 <spanclass="math inline">\(s_i\)</span> 出发走向以 <spanclass="math inline">\(s_i\)</span>为根的子树，能够到达的最远节点距离。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tree_dp</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//树形DP</span></span><br><span class="line">    c[x]=<span class="number">1</span>;<span class="comment">//标记这个点已访问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="type">int</span> y=to[i];</span><br><span class="line">        <span class="keyword">if</span>(c[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">tree_dp</span>(y);</span><br><span class="line">        treeans=<span class="built_in">max</span>(treeans,d[x]+d[y]+edge[i]);</span><br><span class="line">        d[x]=<span class="built_in">max</span>(d[x],d[y]+edge[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，考虑第二种情况。这相当于找到环上两个不同的节点 <spanclass="math inline">\(s_i,s_j\)</span>，使得 <spanclass="math inline">\(d[s_i]+d[s_j]+dist(s_i,s_j)\)</span>最大。其中，<span class="math inline">\(dist(s_i,s_j)\)</span> 表示<span class="math inline">\(s_i,s_j\)</span>在环上的距离，有顺时针、逆时针两种走法，取较长的一种。可以将环断开成链再复制一倍，再用单调队列解决。（还可以用前缀和的方法快速求出，下面会提及）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">slove</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    start=cnt+<span class="number">1</span>;<span class="comment">//因为这是一张基环森林，所以要记录入点下标</span></span><br><span class="line">    ll ans_1=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(x,<span class="number">0</span>);<span class="comment">//找环上的点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=cnt;i++)&#123;</span><br><span class="line">        treeans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">tree_dp</span>(ring[i]);<span class="comment">//对每一个树进行树形DP，找到树上直径</span></span><br><span class="line">        ans_1=<span class="built_in">max</span>(ans_1,treeans);<span class="comment">//记录最大直径</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll ans_2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=cnt;i++)&#123;<span class="comment">//复制环</span></span><br><span class="line">        dp[i+cnt-start+<span class="number">1</span>]=dp[i]=d[ring[i]];</span><br><span class="line">        s[i+cnt-start+<span class="number">1</span>]=s[i+cnt-start]+s[i]-s[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=<span class="number">2</span>*cnt-start+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;q.<span class="built_in">front</span>()&lt;=i-cnt+start<span class="number">-1</span>)&#123;<span class="comment">//优先队列，先清除不在区域范围内的点</span></span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">size</span>())&#123;<span class="comment">//如果队列里还有点，进行记录</span></span><br><span class="line">            ans_2=<span class="built_in">max</span>(ans_2,dp[i]+dp[q.<span class="built_in">front</span>()]+s[i]-s[q.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;dp[q.<span class="built_in">back</span>()]-s[q.<span class="built_in">back</span>()]&lt;=dp[i]-s[i])&#123;<span class="comment">//清除比这个点小的点</span></span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);<span class="comment">//插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(ans_1,ans_2);<span class="comment">//取最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要，可以打开<ahref="https://www.luogu.com.cn/paste/867bnw9o">完整的代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉回路</title>
      <link href="/post/9b4a4404d6ab.html"/>
      <url>/post/9b4a4404d6ab.html</url>
      
        <content type="html"><![CDATA[<p>欧拉回路</p><blockquote><p>2023.09 updated</p></blockquote><h1 id="一基本概念">一、基本概念</h1><p><strong>欧拉路径</strong>：从图中一个结点出发走出一条道路，每条边恰好经过一次的路径。</p><p><strong>欧拉回路</strong>：从图中任意一个顶点出发走出一条道路，每条边恰好经过一次，并最终回到起点。这样的路径称为“欧拉回路”。（类似于一笔画问题）</p><p><strong>欧拉图</strong>：具有欧拉回路的图。</p><p><strong>半欧拉图</strong>：具有欧拉路径但不具有欧拉回路的图</p><h1 id="二算法实现">二、算法实现</h1><p>对于求欧拉回路，我们可以分为两种情况解决：</p><p><imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/bv9xrrv9.png" /></p><ul><li><p><strong>无向图</strong>的欧拉回路(图a、b)：对于无向图，只要是一个<strong>连通图</strong>并且每个点的度是<strong>偶数</strong>，那么这个图就能构成欧拉回路。</p></li><li><p><strong>有向图</strong>的欧拉回路(图c、d)：对于有向图，只要是一个<strong>连通图</strong>并且每个点的<strong>入度等于出度</strong>，那么这个图就能构成欧拉回路。</p></li></ul><p>对于求欧拉路径，我们也可以分为两种情况解决：</p><ul><li><p><strong>无向图</strong>的欧拉路径：对于无向图，只有是一个<strong>连通图</strong>，并且<strong>两个点的度为奇数</strong>，剩余为偶数是，那么这个图就能有欧拉路径。</p></li><li><p><strong>有向图</strong>的欧拉路径：对于有向图，只要是一个<strong>连通图</strong>，并且一<strong>个点的入度等于出度加一，一个点的入度等于出度减一</strong>，其余点入度等于出度时，这个图就有欧拉路径。</p></li></ul><p><strong>一个欧拉图一定有欧拉路径。</strong></p><h2 id="quad-无向图的欧拉路径">2.1 <spanclass="math inline">\(\quad\)</span> 无向图的欧拉路径</h2><p>我们首先判断存在性：</p><ul><li>连通；</li><li>奇点个数为 <span class="math inline">\(0\)</span> 或 <spanclass="math inline">\(2\)</span>。</li></ul><p>通常使用<strong>并查集</strong>判断连通性，或者走完所有边，判断是否走到了所有的边（这一步在算法流程中进行，否则会破坏时间复杂度）。</p><p>考虑如果存在奇点，则路径只能从奇点走若干边（顺序是随意的，不妨自己证明一下）再次到达另一个奇点。</p><p>我们找到奇点（或者不存在），然后按边进行dfs，注意，每条边在欧拉路径中存在且仅存在一次，且顺序随意，所以我们必须标记使用过的边，以避免反复遍历所造成的时间复杂度破坏。我们使用栈记录走过的点，输出时从栈顶以此弹出。</p><p>时间复杂度 <span class="math inline">\(O(m)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> &amp;i=head[u];i;i=nxt[i])&#123;<span class="comment">//使用链式前向星存图，注意i变量要取地址，以标记使用过的边，不会再次遍历。</span></span><br><span class="line"><span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> v=to[i];</span><br><span class="line">vis[i]=vis[i^<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">s[++top]=u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quad-无向图的欧拉回路">2.2 <spanclass="math inline">\(\quad\)</span> 无向图的欧拉回路</h2><p>和上面类似地，判断存在性：</p><ul><li>连通图；</li><li>均为偶点。</li></ul><p>随意找一个点开始遍历。注意：因为找的是欧拉回路，<strong>不必要访问或判断没有边相连的点的连通性</strong>。所以，严格地说，找一个有边相连的点开始遍历。</p><p>遍历的注意事项和 2.1大致相同，注意避免重复遍历。唯一不同的是，因为是欧拉回路，会构成一个环，所以，不必要使用栈记录走过的点。当然，这样记录也没有问题。</p><p>时间复杂度 <span class="math inline">\(O(m)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="type">int</span> n,m,tot=<span class="number">1</span>,s[MAXN],top,du[MAXN];</span><br><span class="line"><span class="type">int</span> head[MAXN],nxt[MAXN&lt;&lt;<span class="number">1</span>],to[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">bool</span> vis[MAXN&lt;&lt;<span class="number">1</span>],viss[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> &amp;i=head[u];i;i=nxt[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> v=to[i];</span><br><span class="line">vis[i]=vis[i^<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">s[++top]=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">to[++tot]=y,nxt[tot]=head[x],head[x]=tot;</span><br><span class="line">to[++tot]=x,nxt[tot]=head[y],head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x,y,i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">add</span>(x,y);</span><br><span class="line">du[x]++,du[y]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(du[i])&#123;</span><br><span class="line"><span class="built_in">dfs</span>(i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(top&lt;=m)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(top) cout&lt;&lt;s[top--]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quad-有向图的欧拉路径">2.3 <spanclass="math inline">\(\quad\)</span> 有向图的欧拉路径</h2><p>我们首先判断存在性：</p><ul><li>连通；</li><li>如下两个条件满足其一：<ul><li>所有点入度等于出度；</li><li>“有且仅有一个点出度比入度大一”、“与有且仅有一个点出度比入度小一”两个条件同时成立。</li></ul></li></ul><p>如果满足条件1，随意找点开始遍历（同样抛弃孤立点）；如果满足条件2，找到“出度比入度大一”的点开始遍历，最后一定会回到“出度比入度小一”的点。</p><p>按边进行 dfs，详细内容与 2.1类似，可以用邻接表存图。</p><p>时间复杂度 <span class="math inline">\(O(m)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=now[u];i&lt;g[u].<span class="built_in">size</span>();i=now[u])&#123;</span><br><span class="line"><span class="type">int</span> v=g[u][i];</span><br><span class="line">now[u]++;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">s[++top]=u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quad-有向图的欧拉回路">2.4 <spanclass="math inline">\(\quad\)</span> 有向图的欧拉回路</h2><p>首先判断存在性：</p><ul><li>连通；</li><li>每个点的入度等于出度。</li></ul><p>随便找一个非孤立点开始遍历，内容同上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="type">int</span> n,m,in[MAXN],out[MAXN],now[MAXN];</span><br><span class="line"><span class="type">int</span> s[MAXN],top;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=now[u];i&lt;g[u].<span class="built_in">size</span>();i=now[u])&#123;</span><br><span class="line"><span class="type">int</span> v=g[u][i];</span><br><span class="line">now[u]++;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">s[++top]=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x,y,i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">in[y]++;</span><br><span class="line">out[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> st=<span class="number">0</span>,numin=<span class="number">0</span>,numout=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(in[i]!=out[i])&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(numin&gt;<span class="number">1</span>||numout&gt;<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(out[i])&#123;</span><br><span class="line">st=i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(st);</span><br><span class="line"><span class="keyword">if</span>(top!=m+<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(top)&#123;</span><br><span class="line">cout&lt;&lt;s[top--]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三样例练习">三、样例练习</h1><ul><li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1878">hdu 1878欧拉回路</a>：</li></ul><p>一道模板题。主要知识点是欧拉回路，只需要求出是否含有欧拉回路，不需要求路径。<ahref="https://www.luogu.com.cn/paste/pvhqvc2s">模板代码</a></p><ul><li><a href="https://www.luogu.com.cn/problem/UVA10054">UVA10054 TheNecklace</a>：</li></ul><p>题解见<ahref="https://www.luogu.com.cn/blog/liyunchen/solution-uva10054">我的博客</a></p><ul><li><a href="https://www.luogu.com.cn/problem/UVA10129">UVA10129 单词Play on Words</a>（<ahref="http://acm.hdu.edu.cn/showproblem.php?pid=1116">hdu 1116 Play onWords</a>）：</li></ul><p>题解见<ahref="https://www.luogu.com.cn/blog/liyunchen/solution-uva10129">我的博客</a></p><ul><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5883">hdu 5883The Best Path</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P1341">P1341无序字母对</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P3520">P3520[POI2011]SMI-Garbage</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P2731">P2731[USACO3.3]骑马修栅栏 Riding the Fences</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有向图的连通性</title>
      <link href="/post/f22be4884efb.html"/>
      <url>/post/f22be4884efb.html</url>
      
        <content type="html"><![CDATA[<p>有向图的连通性</p><h1 id="一基本概念">一、基本概念</h1><p><strong>强连通</strong>：在有向图 <spanclass="math inline">\(G\)</span> 中，如果两点 <spanclass="math inline">\(u\)</span> , <spanclass="math inline">\(v\)</span> 是互相可达的，则称 <spanclass="math inline">\(u\)</span> 和 <spanclass="math inline">\(v\)</span> 是<strong>强连通</strong>的。如果 <spanclass="math inline">\(G\)</span> 中的任意两个点都是互相可达的，那么<span class="math inline">\(G\)</span>就是<strong>强连通图</strong>。</p><p><strong>强连通分量</strong>：如果一个有向图 <spanclass="math inline">\(G\)</span>不是强连通图，那么可以把它分成多个子图，其中每个子图的内部是强连通的，而且这些子图已经扩展到最大，不能与子图外的任一点强连通，像这样的一个“极大强连通”子图是<spanclass="math inline">\(G\)</span>的一个<strong>强连通分量</strong>( <spanclass="math inline">\(\text{Strongly ConnectedComponent}\)</span>，<span class="math inline">\(\text{SCC}\)</span>).</p><p><spanclass="math inline">\(Tarjan\)</span>算法能在一次DFS中吧所有点都按 <spanclass="math inline">\(\text{SCC}\)</span>分开。这并不是不可思议的，它利用了 <spanclass="math inline">\(\text{SCC}\)</span> 的特点。</p><p><strong>定理：一个 <spanclass="math inline">\(\text{SCC}\)</span>，从其中任何一个点出发。都至少有一条路径能绕回到自己。</strong></p><h1 id="二算法实现">二、算法实现</h1><p>在讲解之前，先了解<span class="math inline">\(low\)</span>和<spanclass="math inline">\(num\)</span>操作。</p><p>下面是一个例子，下图有三个 <spanclass="math inline">\(\text{SCC}\)</span>，也就是<spanclass="math inline">\(\{a,b,d,c\}\)</span>、<spanclass="math inline">\(\{e\}\)</span>、<spanclass="math inline">\(\{f\}\)</span>.</p><p><imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/9nl2pcnf.png" /></p><p>图1.a是原图。图1.b是对它做<spanclass="math inline">\(DFS\)</span>，每个点左边的数字标记了<spanclass="math inline">\(DFS\)</span>访问它的顺序，也就是<spanclass="math inline">\(num[]\)</span>值，右边的划线数字是<spanclass="math inline">\(low[]\)</span>值，即能返回到的最远的祖先。每个点的<spanclass="math inline">\(low[]\)</span>初始值等于<spanclass="math inline">\(num[]\)</span>，即连到自己。观察<spanclass="math inline">\(c\)</span>的<spanclass="math inline">\(low[]\)</span>值是如何更新的：它的初始值是<spanclass="math inline">\(6\)</span>，然后有一个回退到<spanclass="math inline">\(a\)</span>，所以更新为<spanclass="math inline">\(1\)</span>；它的递归祖先<spanclass="math inline">\(d\)</span>、<spanclass="math inline">\(b\)</span>的<spanclass="math inline">\(low[]\)</span>值也跟着更新为<spanclass="math inline">\(1\)</span>。<spanclass="math inline">\(e\)</span>和<spanclass="math inline">\(f\)</span>的<spanclass="math inline">\(low[]\)</span>值不能更新。</p><p>图1.b是从<span class="math inline">\(a\)</span>开始<spanclass="math inline">\(DFS\)</span>的，<spanclass="math inline">\(a\)</span>成为{<spanclass="math inline">\(a,b,d,c\)</span>}这个<spanclass="math inline">\(SCC\)</span>的祖先.其实，从{<spanclass="math inline">\(a,b,d,c\)</span>}中<strong>任意</strong>一个点开始<spanclass="math inline">\(DFS\)</span>，这个点都会成为这个<spanclass="math inline">\(SCC\)</span>的祖先。认识到这些，可以帮助我们理解后面的解释：可以用栈分离不同的<spanclass="math inline">\(SCC\)</span>。</p><p>图1.b中的<span class="math inline">\(low[]\)</span>值有<spanclass="math inline">\(3\)</span>部分，即等于<spanclass="math inline">\(1\)</span>的{<spanclass="math inline">\(a,b,d,c\)</span>}、等于<spanclass="math inline">\(4\)</span>的{<spanclass="math inline">\(f\)</span>}、等于<spanclass="math inline">\(5\)</span>的{<spanclass="math inline">\(e\)</span>}。这就是<spanclass="math inline">\(3\)</span>个<spanclass="math inline">\(SCC\)</span>。</p><p>完成以上步骤，似乎已经就解决了问题。每个点都有了自己的<spanclass="math inline">\(low[]\)</span>值，相同<spanclass="math inline">\(low[]\)</span>值的点属于一个<spanclass="math inline">\(SCC\)</span>。那么只要再对所有点做一个查询，按<spanclass="math inline">\(low[]\)</span>值分开就行了，其复杂度是<spanclass="math inline">\(O(V)\)</span>。</p><p>其实有更好的办法，即在<spanclass="math inline">\(DFS\)</span>的同时把点按<spanclass="math inline">\(SCC\)</span>（有相同的<spanclass="math inline">\(low[]\)</span>值）分开。</p><p>以图2为例，其中有3个<span class="math inline">\(SCC\)</span>，即<spanclass="math inline">\(A\)</span>、<spanclass="math inline">\(E\)</span>、<spanclass="math inline">\(F\)</span>。假设从F中的一个点开始<spanclass="math inline">\(DFS\)</span>，<spanclass="math inline">\(DFS\)</span>过程可能会中途跳出<spanclass="math inline">\(F\)</span>，转入<spanclass="math inline">\(A\)</span>或者<spanclass="math inline">\(E\)</span>，总之，最后会进入一个<spanclass="math inline">\(SCC\)</span>。</p><ol type="1"><li><p>假设DFS过程是<span class="math inline">\(F\)</span>-&gt;<spanclass="math inline">\(E\)</span>-&gt;<spanclass="math inline">\(A\)</span>，最后进入<spanclass="math inline">\(A\)</span>。</p></li><li><p>在<span class="math inline">\(A\)</span>这个<spanclass="math inline">\(SCC\)</span>中将完成<spanclass="math inline">\(A\)</span>内所有点的<spanclass="math inline">\(DFS\)</span>过程，也就是说，最后的几步<spanclass="math inline">\(DFS\)</span>会集中在A中的点<spanclass="math inline">\(a\)</span>、<spanclass="math inline">\(b\)</span>、<spanclass="math inline">\(c\)</span>、<spanclass="math inline">\(d\)</span>。这几个点会计算得到相同的<spanclass="math inline">\(low[]\)</span>值，标记为一个<spanclass="math inline">\(SCC\)</span>，这样就好了。</p></li><li><p><span class="math inline">\(DFS\)</span>递归从<spanclass="math inline">\(A\)</span>回到<spanclass="math inline">\(E\)</span>。并在E中完成<spanclass="math inline">\(E\)</span>内部的<spanclass="math inline">\(DFS\)</span>过程。</p></li><li><p>回到<span class="math inline">\(F\)</span>，在<spanclass="math inline">\(F\)</span>内完成递归过程。</p></li></ol><p>以上过程如何编程？那你可能想起来，<spanclass="math inline">\(DFS\)</span>搜索是用递归实现的，而递归和栈这种数据结构在本质上是一致的。<strong>所以，可以用栈来帮助处理。</strong></p><ol type="1"><li><p>从<spanclass="math inline">\(F\)</span>开始递归搜索，访问到的某些点进入栈；</p></li><li><p><span class="math inline">\(E\)</span>中的某些点进入栈；</p></li><li><p>在<spanclass="math inline">\(DFS\)</span>的最底层，A的所有点将被访问到并进入栈，当前栈顶的几个元素就是<spanclass="math inline">\(A\)</span>的点，标记为同一个<spanclass="math inline">\(SCC\)</span>，并弹出栈；</p></li><li><p><span class="math inline">\(DFS\)</span>回到<spanclass="math inline">\(E\)</span>，在<spanclass="math inline">\(E\)</span>中完成所有点的搜索并且入栈，当前栈顶的元素就是<spanclass="math inline">\(F\)</span>的点，标记为同一个<spanclass="math inline">\(SCC\)</span>，并弹出栈；</p></li><li><p>回到<span class="math inline">\(F\)</span>，完成<spanclass="math inline">\(F\)</span>的所有点的搜索并且入栈，当前栈顶的几个元素就是<spanclass="math inline">\(F\)</span>的点，标记为同一个<spanclass="math inline">\(SCC\)</span>，并弹出栈、结束。</p></li></ol><p>为加深对上述过程中栈的理解，我们可以思考最先进入栈的点。每进入一个新的<spanclass="math inline">\(SCC\)</span>，访问并进入栈的第一个点都是这个<spanclass="math inline">\(SCC\)</span>的祖先，它的<spanclass="math inline">\(num[]\)</span>值等于<spanclass="math inline">\(low[]\)</span>值，这个<spanclass="math inline">\(SCC\)</span>中所有点的<spanclass="math inline">\(low[]\)</span>值都等于它。</p><h1 id="三样例练习">三、样例练习</h1><ul><li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1269">hdu 1269迷宫城堡</a>：</li></ul><p>一道模板题。<ahref="https://www.luogu.com.cn/paste/6u1aax1d">代码</a></p><ul><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1827">hdu 1827Summer Holiday</a>: Tarjan 缩点模板题。</p></li><li><p><a href="https://www.luogu.com.cn/problem/P3387">P3387【模板】缩点</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P2341">P2341[USACO03FALL][HAOI2006]受欢迎的牛 G</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P2863">P2863[USACO06JAN]The Cow Prom S</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P2746">P2746[USACO5.3]校园网Network of Schools</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P1407">P1407[国家集训队]稳定婚姻</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P2194">P2194HXY烧情侣</a></p></li><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3072">hdu 3072Intelligence System</a>: Tarjan+贪心。</p></li><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3836">hdu 3836Equivalent Sets</a></p></li><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3639">hdu 3639Hawk-and-Chicken</a>: 强连通分量+缩点。</p></li><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3861">hdu 3861The King’s Problem</a>： 最小路径覆盖。</p></li><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1530">hdu 1530Maximum Clique</a>: 最大团简单题目。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/post/e5fab92033d0.html"/>
      <url>/post/e5fab92033d0.html</url>
      
        <content type="html"><![CDATA[<p>线段树</p><p>线段树，OI中重要的数据结构，用于维护区间信息，也可以辅助维护。线段树的性能比树状数组强（但是码量大），普遍复杂度在<span class="math inline">\(O(\log n)\)</span> 左右。</p><h1 id="一基本概念">一、基本概念</h1><p>线段树是一种二叉树，也就是对于一个线段，我们会用一个二叉树来表示。比如说一个长度为4的线段，我们可以表示成这样：<imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/dvvdl05x.png" /></p><p>这是什么意思呢？如果你要表示线段的和，那么最上面的根节点的权值表示的是这个线段 <spanclass="math inline">\(1\sim 4\)</span>的和。根的两个儿子分别表示这个线段中 <span class="math inline">\(1\sim2\)</span> 的和，与 <span class="math inline">\(3\sim 4\)</span>的和。以此类推。</p><p>然后我们还可以的到一个性质：节点i的权值=她的左儿子权值+她的右儿子权值。因为<span class="math inline">\(1\sim 4\)</span> 的和就是等于 <spanclass="math inline">\(1\sim 2\)</span> 的和加上 <spanclass="math inline">\(3\sim 4\)</span> 的和。</p><p>根据这个思路，我们就可以建树了，我们设一个结构体<code>tree</code>，<code>tree[i].l</code> 和 <code>tree[i].r</code>分别表示这个点代表的线段的左右下标， <code>tree[i].sum</code>表示这个节点表示的线段和。</p><p>我们知道，一颗二叉树，她的左儿子和右儿子编号分别是 <spanclass="math inline">\(p\times2\)</span> 和 <spanclass="math inline">\(p\times2+1\)</span>。</p><p>再根据刚才的性质，得到式子：<code>tree[i].sum=tree[i*2].sum+tree[i*2+1].sum</code>就可以建一颗线段树了！</p><p>代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//递归建树</span></span><br><span class="line">    tree[i].l=l;tree[i].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;<span class="comment">//如果这个节点是叶子节点</span></span><br><span class="line">        tree[i].sum=input[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(i*<span class="number">2</span>,l,mid);<span class="comment">//分别构造左子树和右子树</span></span><br><span class="line">    <span class="built_in">build</span>(i*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    tree[i].sum=tree[i*<span class="number">2</span>].sum+tree[i*<span class="number">2</span>+<span class="number">1</span>].sum;<span class="comment">//刚才我们发现的性质return ;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>嗯，这就是线段树的构建，你可能会问为什么要开好几倍的内存去储存一条线段。这是因为我们还没有让这个过大的数组干一些实事，那么什么是实事呢？让我们进入下一部（在你看懂这一部的情况下）</p><h1 id="二简单的线段树">二、简单的线段树</h1><h2 id="quad单点修改区间查询">2.1<spanclass="math inline">\(\quad\)</span>单点修改，区间查询</h2><p>其实这一章开始才是真正的线段树，我们要用线段树干什么？答案是维护一个线段（或者区间），比如你想求出一个<span class="math inline">\(1\sim 100\)</span> 区间中， <spanclass="math inline">\(4\sim 67\)</span>这些元素的和，你会怎么做？朴素的做法是<code>for(i=4;i&lt;=67;i++) sum+=a[i]</code>，这样固然好，但是算得太慢了。</p><p>我们想一种新的方法，先想一个比较好画图的数据，比如一个长度为4的区间，分别是1、2、3、4,我们想求出第<span class="math inline">\(1\sim 3\)</span>项的和。按照上一部说的，我们要建出一颗线段树，其中点权（也就是红色）表示和：<imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/vf6zzggf.png" /></p><p>然后我们要求 <span class="math inline">\(1\sim 3\)</span>的和，我们先从根节点开始查询，发现她的左儿子 <spanclass="math inline">\(1\sim 2\)</span> 这个区间和答案区间 <spanclass="math inline">\(1\sim 3\)</span>有交集，那么我们跑到左儿子这个区间。</p><p>然后，我们发现这个区间 <span class="math inline">\(1\sim 2\)</span>被完全包括在答案区间 <span class="math inline">\(1\sim 3\)</span>这个区间里面，那就把她的值3返回。</p><p>我们回到了 <span class="math inline">\(1\sim 4\)</span>区间，发现她的右儿子 <span class="math inline">\(3\sim 4\)</span>区间和答案区间 <span class="math inline">\(1\sim 3\)</span>有交集，那么我们走到 <span class="math inline">\(3\sim 4\)</span>区间</p><p>到了 <span class="math inline">\(3\sim 4\)</span>区间，我们发现她并没有完全包含在答案区间 <spanclass="math inline">\(1\sim 3\)</span> 里面，但发现她的左儿子 <spanclass="math inline">\(3\sim 3\)</span> 区间和 <spanclass="math inline">\(1\sim 3\)</span> 区间又交集，那么久走到 <spanclass="math inline">\(3\sim 3\)</span> 区间</p><p>到了 <span class="math inline">\(3\sim 3\)</span>区间，发现其被答案区间完全包含，就返回她的值3一直到最开始</p><p><span class="math inline">\(3\sim 32\)</span> 区间的 <spanclass="math inline">\(3+1\sim 2\)</span> 区间的3=6，我们知道了 <spanclass="math inline">\(1\sim 3\)</span> 区间和为6。</p><p>我们总结一下，线段树的查询方法：</p><ol type="1"><li>如果这个区间被完全包括在目标区间里面，直接返回这个区间的值</li><li>如果这个区间的左儿子和目标区间有交集，那么搜索左儿子</li><li>如果这个区间的右儿子和目标区间有交集，那么搜索右儿子</li></ol><p>写成代码，就会变成这样： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].l&gt;=l &amp;&amp; tree[i].r&lt;=r)<span class="comment">//如果这个区间被完全包括在目标区间里面，直接返回这个区间的值</span></span><br><span class="line">        <span class="keyword">return</span> tree[i].sum;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].r&lt;l || tree[i].l&gt;r)  <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果这个区间和目标区间毫不相干，返回0</span></span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>].r&gt;=l)  s+=<span class="built_in">search</span>(i*<span class="number">2</span>,l,r);<span class="comment">//如果这个区间的左儿子和目标区间又交集，那么搜索左儿子</span></span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>+<span class="number">1</span>].l&lt;=r)  s+=<span class="built_in">search</span>(i*<span class="number">2</span>+<span class="number">1</span>,l,r);<span class="comment">//如果这个区间的右儿子和目标区间又交集，那么搜索右儿子</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>关于那几个if的条件一定要看清楚，最好背下来，以防考场上脑抽推错。</p><p>然后,我们怎么修改这个区间的单点，其实这个相对简单很多，你要把区间的第<code>dis</code> 位加上 <span class="math inline">\(k\)</span>。</p><p>那么你从根节点开始，看这个 <code>dis</code>是在左儿子还是在右儿子，在哪往哪跑，</p><p>然后返回的时候，还是按照<code>tree[i].sum=tree[i*2].sum+tree[i*2+1].sum</code>的原则，更新所有路过的点。</p><p>如果不理解，我还是画个图吧，其中紫色是去的路径，粉色是返回的路径，回来时候红色的+标记就是把这个点加上这个值。</p><p><imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/n4ptxjmh.png" /></p><p>把这个过程变成代码，就是这个样子： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> dis,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].l==tree[i].r)&#123;<span class="comment">//如果是叶子节点，那么说明找到了</span></span><br><span class="line">        tree[i].sum+=k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis&lt;=tree[i*<span class="number">2</span>].r)  <span class="built_in">add</span>(i*<span class="number">2</span>,dis,k);<span class="comment">//在哪往哪跑</span></span><br><span class="line">    <span class="keyword">else</span>  <span class="built_in">add</span>(i*<span class="number">2</span>+<span class="number">1</span>,dis,k);</span><br><span class="line">    tree[i].sum=tree[i*<span class="number">2</span>].sum+tree[i*<span class="number">2</span>+<span class="number">1</span>].sum;<span class="comment">//返回更新</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 2.2<spanclass="math inline">\(\quad\)</span>区间修改，单点查询</p><p>区间修改和单点查询，我们的思路就变为：如果把这个区间加上 <spanclass="math inline">\(k\)</span>，相当于把这个区间涂上一个 <spanclass="math inline">\(k\)</span>的标记，然后单点查询的时候，就从上跑道下，把沿路的标记加起来就好。</p><p>这里面给区间贴标记的方式与上面的区间查找类似，原则还是那三条，只不过第一条：如果这个区间被完全包括在目标区间里面，直接返回这个区间的值变为了如果这个区间如果这个区间被完全包括在目标区间里面，讲这个区间标记<span class="math inline">\(k\)</span>。</p><p>具体做法很像，这里贴上代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].l&gt;=l &amp;&amp; tree[i].r&lt;=r)&#123;<span class="comment">//如果这个区间被完全包括在目标区间里面，讲这个区间标记k</span></span><br><span class="line">        tree[i].sum+=k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>].r&gt;=l)</span><br><span class="line">        <span class="built_in">add</span>(i*<span class="number">2</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>+<span class="number">1</span>].l&lt;=r)</span><br><span class="line">        <span class="built_in">add</span>(i*<span class="number">2</span>+<span class="number">1</span>,l,r,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>然后就是单点查询了，这个更好理解了，就是 <code>dis</code>在哪往哪跑，把路径上所有的标价加上就好了： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> dis)</span></span>&#123;</span><br><span class="line">    ans+=tree[i].num;<span class="comment">//一路加起来</span></span><br><span class="line">    <span class="keyword">if</span>(tree[i].l==tree[i].r)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(dis&lt;=tree[i*<span class="number">2</span>].r)</span><br><span class="line">        <span class="built_in">search</span>(i*<span class="number">2</span>,dis);</span><br><span class="line">    <span class="keyword">if</span>(dis&gt;=tree[i*<span class="number">2</span>+<span class="number">1</span>].l)</span><br><span class="line">        <span class="built_in">search</span>(i*<span class="number">2</span>+<span class="number">1</span>,dis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>不知不觉，这第二章已经结束。这样的简单（原谅我用这个词）线段树，还可除了求和，还可以求区间最小最大值，还可以区间染色。</p><p>但是！这样的线段树展现不出来她的魅力，因为区间求和，树状数组比她少了一个很大的常熟。二区间最值，ST的那神乎其技的<spanclass="math inline">\(O(n)\)</span>查询也能完爆她。这是为什么？因为线段树的魅力还没有展现出来，她最美丽的地方：<spanclass="math inline">\(\text{pushdown}\)</span>还未展现于世，如果你已经对这一章充足的了解，并且能不看博客把洛谷上树状数组模板1、2都能写出来，那么请你进入下一部。</p><h1 id="三进阶线段树">三、进阶线段树</h1><p>区间修改、区间查询，你可能会认为，把上一章里面的这两个模块加在一起就好了，然后你就会发现你大错特错。</p><p>因为如果对于1~4这个区间，你把1<sub>3区间+1，相当于把节点1</sub>2和3标记，但是如果你查询2<sub>4时，你会发现你加的时没有标记的2节点和没有标记的3</sub>4节点加上去，结果当然是错的。</p><p>那么我们应该怎么办？这时候 <spanclass="math inline">\(\text{pushdown}\)</span> 的作用就显现出来了。</p><p>你会想到，我们只需要在查询的时候，如果我们要查的2节点在1<sub>2区间的里面，那我们就可以把1</sub>2区间标记的那个+1给推下去这样就能顺利地加上了。怎么记录这个标记呢？我们需要记录一个“懒标记” <spanclass="math inline">\(\text{lazytage}\)</span>，来记录这个区间</p><p>区间修改的时候，我们按照如下原则：</p><ol type="1"><li>如果当前区间被完全覆盖在目标区间里，讲这个区间的<code>sum+k*(tree[i].r-tree[i].l+1)</code></li><li>如果没有完全覆盖，则先下传懒标记</li><li>如果这个区间的左儿子和目标区间有交集，那么搜索左儿子</li><li>如果这个区间的右儿子和目标区间有交集，那么搜索右儿子</li></ol><p>然后查询的时候，将这个懒标记下传就好了，下面图解一下：</p><p>如图，区间1<sub>4分别是1、2、3、4，我们要把1</sub>3区间+1。因为1~2区间被完全覆盖，所以将其+2，并将紫色的<span class="math inline">\(\text{lazytage}+1\)</span>，3区间同理 <imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/xcs9o21v.png" /></p><p>注意我们处理完这些以后，还是要按照<code>tree[i].sum=tree[i*2].sum+tree[i*2+1].sum</code>的原则返回，代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].r&lt;=r &amp;&amp; tree[i].l&gt;=l)<span class="comment">//如果当前区间被完全覆盖在目标区间里，讲这个区间的sum+k*(tree[i].r-tree[i].l+1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[i].sum+=k*(tree[i].r-tree[i].l+<span class="number">1</span>);</span><br><span class="line">        tree[i].lz+=k;<span class="comment">//记录lazytage</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(i);<span class="comment">//向下传递</span></span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>].r&gt;=l)</span><br><span class="line">        <span class="built_in">add</span>(i*<span class="number">2</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>+<span class="number">1</span>].l&lt;=r)</span><br><span class="line">        <span class="built_in">add</span>(i*<span class="number">2</span>+<span class="number">1</span>,l,r,k);</span><br><span class="line">    tree[i].sum=tree[i*<span class="number">2</span>].sum+tree[i*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中的 <spanclass="math inline">\(\text{pushdown}\)</span>，就是把自己的 <spanclass="math inline">\(\text{lazytage}\)</span>归零，并给自己的儿子加上，并让自己的儿子加上 <spanclass="math inline">\(k\times(r-l+1)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].lz!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[i*<span class="number">2</span>].lz+=tree[i].lz;<span class="comment">//左右儿子分别加上父亲的lz</span></span><br><span class="line">        tree[i*<span class="number">2</span>+<span class="number">1</span>].lz+=tree[i].lz;</span><br><span class="line">        init mid=(tree[i].l+tree[i].r)/<span class="number">2</span>;</span><br><span class="line">        tree[i*<span class="number">2</span>].data+=tree[i].lz*(mid-tree[i*<span class="number">2</span>].l+<span class="number">1</span>);<span class="comment">//左右分别求和加起来</span></span><br><span class="line">        tree[i*<span class="number">2</span>+<span class="number">1</span>].data+=tree[i].lz*(tree[i*<span class="number">2</span>+<span class="number">1</span>].r-mid);</span><br><span class="line">        tree[i].lz=<span class="number">0</span>;<span class="comment">//父亲lz归零</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询的时候，和上一章的几乎一样，就是也要像修改一样加入 <spanclass="math inline">\(\text{pushdown}\)</span>，这里用图模拟一下。我们要查询2~4区间的和，这是查询前的情况，所有紫色的代表<span class="math inline">\(\text{lazytage}\)</span> <imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/ky84qvuc.png" /></p><p>然后，我们查到区间1~2时，发现这个区间并没有被完全包括在目标区间里，于是我们就<span class="math inline">\(\text{pushdown}\)</span>，<spanclass="math inline">\(\text{lazytage}\)</span> 下传，并让每个区间<code>sum</code> 加上 <spanclass="math inline">\((r-l)\text{lazytage}\)</span>。 <imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/rbaq35e6.png" /></p><p>然后查到2<sub>2区间，发现被完全包含，所以就返3，再搜索到3</sub>4区间，发现被完全包含，那么直接返回8，最后3+8=11就是答案</p><p>这里是代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].l&gt;=l &amp;&amp; tree[i].r&lt;=r)</span><br><span class="line">        <span class="keyword">return</span> tree[i].sum;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].r&lt;l || tree[i].l&gt;r)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">push_down</span>(i);</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>].r&gt;=l)  s+=<span class="built_in">search</span>(i*<span class="number">2</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>+<span class="number">1</span>].l&lt;=r)  s+=<span class="built_in">search</span>(i*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，到了这里，我们就学会了用线段树进行区间加减操作，大家可以完成洛谷的线段树模板1</p><h1 id="四乘法根号线段树">四、乘法（根号）线段树</h1><h2 id="quad乘法线段树">4.1<spanclass="math inline">\(\quad\)</span>乘法线段树</h2><p>如果这个线段树只有乘法，那么直接加入 <spanclass="math inline">\(\text{lazytage}\)</span> 变成乘，然后<code>tree[i].sum*=k</code>就好了。但是，如果我们是又加又乘，那就不一样了。</p><p>当 <span class="math inline">\(\text{lazytage}\)</span>下标传递的时候，我们需要考虑，是先加再乘还是先乘再加。我们只需要对 <spanclass="math inline">\(\text{lazytage}\)</span> 做这样一个处理。</p><p><spanclass="math inline">\(\text{lazytage}\)</span>分为两种，分别是加法的<code>plz</code> 和乘法的 <code>mlz</code>。</p><p><span class="math inline">\(mlz\)</span>很简单处理，<spanclass="math inline">\(pushdown\)</span>时直接<spanclass="math inline">\(\times\)</span>父亲的就可以了，那么加法呢？</p><p>我们需要把原先的 <code>plz</code> 乘上父亲的 <code>mlz</code>再加上父亲的 <code>plz</code>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">long</span> <span class="type">long</span> i)</span></span>&#123;<span class="comment">//注意这种级别的数据一定要开long long</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k1=tree[i].mlz,k2=tree[i].plz;</span><br><span class="line">    tree[i&lt;&lt;<span class="number">1</span>].sum=(tree[i&lt;&lt;<span class="number">1</span>].sum*k1+k2*(tree[i&lt;&lt;<span class="number">1</span>].r-tree[i&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>))%p;<span class="comment">//</span></span><br><span class="line">    tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum=(tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum*k1+k2*(tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>))%p;</span><br><span class="line">    tree[i&lt;&lt;<span class="number">1</span>].mlz=(tree[i&lt;&lt;<span class="number">1</span>].mlz*k1)%p;</span><br><span class="line">    tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mlz=(tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mlz*k1)%p;</span><br><span class="line">    tree[i&lt;&lt;<span class="number">1</span>].plz=(tree[i&lt;&lt;<span class="number">1</span>].plz*k1+k2)%p;</span><br><span class="line">    tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].plz=(tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].plz*k1+k2)%p;</span><br><span class="line">    tree[i].plz=<span class="number">0</span>;</span><br><span class="line">    tree[i].mlz=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>然后加法和减法的函数同理，维护 <spanclass="math inline">\(\text{lazytage}\)</span>的时候加法标记一定要记得现乘再加。</p><p>值得一提的是，计算$$2时一定要改成 <spanclass="math inline">\(i&lt;&lt;1\)</span> 这样能解决很多时间。</p><h2 id="quad根号线段树">4.2<spanclass="math inline">\(\quad\)</span>根号线段树</h2><p>其实，根号线段树和除法线段树一样。她们乍眼一看感觉直接用<code>lazytage</code> 标记除了多少，但是实际上，会出现精度问题。</p><p>C++的除法是向下取整，很明显，<spanclass="math inline">\(\dfrac{a+b}{k}!=\dfrac{a}{k}+\dfrac{b}{k}\)</span>（在向下取整的情况下），而根号，很明显<spanclass="math inline">\(\sqrt{a}+\sqrt{b}!=\sqrt{a+b}\)</span>那么怎么办？</p><p>第一个想法就是暴力，对于每个要改动的区间l~r,把里面的每个点都单独除，但这样就会把时间复杂度卡得比大暴力都慢（因为多个常数），所以怎么优化？</p><p>我们对于每个区间，维护她的最大值和最小值，然后每次修改时，如果这个区间的最大值根号和最小值的根号一样，说明这个区间整体根号不会产生误差，就直接修改（除法同理）</p><p>其中， <code>lazytage</code>把除法当成减法，记录的是这个区间里每个元素减去的值。</p><p>下面是根号线段树的修改过程： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Sqrt</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].l&gt;=l &amp;&amp; tree[i].r&lt;=r &amp;&amp; (tree[i].minn-(<span class="type">long</span> <span class="type">long</span>)<span class="built_in">sqrt</span>(tree[i].minn))==(tree[i].maxx-(<span class="type">long</span> <span class="type">long</span>)<span class="built_in">sqrt</span>(tree[i].maxx)))&#123;<span class="comment">//如果这个区间的最大值最小值一样</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> u=tree[i].minn-(<span class="type">long</span> <span class="type">long</span>)<span class="built_in">sqrt</span>(tree[i].minn);<span class="comment">//计算区间中每个元素需要减去的</span></span><br><span class="line">        tree[i].lz+=u;</span><br><span class="line">        tree[i].sum-=(tree[i].r-tree[i].l+<span class="number">1</span>)*u;</span><br><span class="line">        tree[i].minn-=u;</span><br><span class="line">        tree[i].maxx-=u;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].r&lt;l || tree[i].l&gt;r)  <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">push_down</span>(i);</span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>].r&gt;=l)  <span class="built_in">Sqrt</span>(i*<span class="number">2</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(tree[i*<span class="number">2</span>+<span class="number">1</span>].l&lt;=r)  <span class="built_in">Sqrt</span>(i*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">    tree[i].sum=tree[i*<span class="number">2</span>].sum+tree[i*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">    tree[i].minn=<span class="built_in">min</span>(tree[i*<span class="number">2</span>].minn,tree[i*<span class="number">2</span>+<span class="number">1</span>].minn);<span class="comment">//维护最大值和最小值</span></span><br><span class="line">    tree[i].maxx=<span class="built_in">max</span>(tree[i*<span class="number">2</span>].maxx,tree[i*<span class="number">2</span>+<span class="number">1</span>].maxx);</span><br><span class="line">    <span class="comment">//cout&lt;&lt;&quot;i&quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;tree[i].sum&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 然后 <code>pushdown</code>没什么变化，就是要记得 <code>tree[i].minn$、$tree[i].maxx</code>也要记得 <code>-lazytage</code>。</p><h1 id="五样例练习">五、样例练习</h1><ul><li><p><a href="https://www.luogu.com.cn/problem/P3374">P3374树状数组模板1</a>：单点修改，区间查询</p></li><li><p><a href="https://www.luogu.com.cn/problem/P3368">P3368树状数组模板2</a>：区间修改，单点查询</p></li><li><p><a href="https://www.luogu.com.cn/problem/P3372">P3372线段树模板1</a>区间加法：</p></li><li><p><a href="https://www.luogu.com.cn/problem/P3373">P3373线段树模板2</a>区间乘法：</p></li><li><p><a href="https://www.luogu.com.cn/problem/P4588">P4588[TJOI2018]数学计算</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P1502">P1502窗口的星星</a>：离散化</p></li><li><p><a href="https://www.luogu.com.cn/problem/P2471">P2471[SCOI2007]降雨量</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P3722">P3722[AH2017/HNOI2017]影魔</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P4198">P4198楼房重建</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P4513">P4513小白逛公园</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P4145">P4145上帝造题的七分钟 2 / 花神游历各国</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P2023">P2023 [AHOI2009]维护序列</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
